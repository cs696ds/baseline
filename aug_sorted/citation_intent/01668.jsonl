{"text": "In other words , it would be nice if we could use macros to access foreign bindings - in this case object slots - as if they were lexical bindings .Although this is undeniably useful for abbreviation purposes , its most important implication is its ability to give dualities of syntax to our existing and future macros .", "label": "", "metadata": {}, "score": "32.6684"}
{"text": "When this situation occurs , it is an indication that the grammar is full - blown LR(1 ) , because two or more states could not be combined , as would be the case if the grammar was LALR(1 ) or simpler .", "label": "", "metadata": {}, "score": "33.146667"}
{"text": "Note I. .Once an item set can be moved from the to - do list to the incomplete / done list , it is a permanent set of the grammar .The algorithm spends the majority of its time in the mergeLoop searching for an existing item set that can be merged with a newly created transition item set .", "label": "", "metadata": {}, "score": "35.08108"}
{"text": "It is easiest if the Marpa definition and the traditional definition were extensionally equivalent --- that is , if Marpa 's set of ambiguous grammars was exactly the same as the set of traditionally ambiguous grammars .This can be accomplished by using a slightly altered definition .", "label": "", "metadata": {}, "score": "36.501766"}
{"text": "The algorithm also differs from the classical LALR(k ) parser generation algorithm by Aho and Ullman , because it is not limited to LALR(k ) grammars but is capable of handling the complete universe of LR(k ) grammars .Rather than synthesizing the look - ahead symbols for a given item , each item and its specific look - ahead symbol are processed together , providing the same capabilities of a canonical LR(k ) parser generator .", "label": "", "metadata": {}, "score": "37.049866"}
{"text": "From the purely structural point of view this can be , in one sense , true .But from the lexical point of view it 's clearly quite false .Combining the two levels of description , it is very hard to justify an assertion that \" whitespace is ignored \" .", "label": "", "metadata": {}, "score": "37.354584"}
{"text": "The second criteria for merging two item sets is that the result of merging them can not result in any reduce / reduce conflicts .The reduction items in example sets i6 and i11 are identical and thus do not cause a conflict .", "label": "", "metadata": {}, "score": "37.594536"}
{"text": "On the other hand , if the old item set has not been marked as complete yet , all of the items from the new set must be merged into it , including all closure ( non - kernel shift ) items .", "label": "", "metadata": {}, "score": "37.6503"}
{"text": "This algorithm differs from the classical LR(k ) parser generation algorithm by Knuth .The algorithm performs the merging as it goes , producing the same collection of states that would result if the entire canonical LR(k ) item sets were generated and then a final pass was made to merge all similar states .", "label": "", "metadata": {}, "score": "37.903233"}
{"text": "Clearly the placement of the whitespace makes a vast difference , and has a major effect on the structure of string , which in turn has a determining effect on its semantics .Why the structural level ?As we 've seen , the structural level ignores essential aspects of the language .", "label": "", "metadata": {}, "score": "38.35025"}
{"text": "After the algorithm completes , the done list contains all of the item sets generated for the grammar .These item sets can then be transformed into states for the DFA parser engine .This algorithm works for any LR(k ) grammar , for any k , i.e. , it works for any fixed size set of look - ahead symbols .", "label": "", "metadata": {}, "score": "38.423157"}
{"text": "Instead , the lexical ( L0 ) level will simply \" discard \" what it has found .In the example , whitespace is discarded .Lexemes .Tokens at the boundary between L0 and G1 have special significance .The top - level undiscarded symbols in L0 , which will be called \" L0 lexemes \" , go on to become the terminals in G1 .", "label": "", "metadata": {}, "score": "38.679733"}
{"text": "Parsing .Let 's look now at an actual example of how a bottom - up LR(k ) parser works .Using the partial grammar shown in Example 3 , it is fed an input stream composed of the following terminal symbols : .", "label": "", "metadata": {}, "score": "39.729984"}
{"text": "For convenience , the items in the newer set ( i11 ) are added to the older set ( i6 ) , resulting in the following combined item set : .Example 9C - Merged Item Set . i6 .goto('+ ' ) from i2 , i4 . , ' , ' ] .", "label": "", "metadata": {}, "score": "40.048256"}
{"text": "Several points should be kept in mind regarding this notation .The syntax of first - order logic is not context - free , so EBNF can not capture the syntax of RIF - BLD precisely .For instance , it can not capture the well - formedness conditions , i.e. , the requirement that each symbol in RIF - BLD can occur in at most one context .", "label": "", "metadata": {}, "score": "40.132317"}
{"text": "Converting Item Sets into Parser States .Once the LR(k ) item sets for a grammar have been constructed , the next step is to convert them into parser states .There is a direct one - to - one mapping between item sets and parser states .", "label": "", "metadata": {}, "score": "40.232224"}
{"text": "So why have a structural ( G1 ) level of description ?Why not a \" unified \" instead of a \" split \" description .It turns out that , for most languages of practical size , particularly those that deploy whitespace in a natural and intuitive way , a \" unified \" description rapidly becomes unwriteable , and even more rapidly becomes unreadable .", "label": "", "metadata": {}, "score": "40.313572"}
{"text": "In this example , the symbol strong_e is lexical only , the symbol \" \" .( space ) is surface only .All the other symbols are bi - level .All the strings appearing in the rest of the grammar will be made .", "label": "", "metadata": {}, "score": "40.470963"}
{"text": "Any other answers will lead straight back to the way you probably should have done it in the first place : with a macro .But let 's say that you really do want to eval something , if only you could carry along that pesky lexical context .", "label": "", "metadata": {}, "score": "40.75643"}
{"text": "// Clean up .end .+ INCOMPLETE .Practical LR(k ) Parsing .The classic LR(k ) parsing algorithm describes the configuration of a parser at any given moment during a parse .This is a tuple of two parts , one being the current contents of the parser stack and the other part being the current input symbol stream .", "label": "", "metadata": {}, "score": "40.851944"}
{"text": "For instance , here we create a hotpatchable closure and store it in the symbol - function cell of the symbol hotpatch - test for later use : .Have n't we seen this sort of run - time destructuring on keyword symbols before ?", "label": "", "metadata": {}, "score": "40.865704"}
{"text": "In this particular example , there is exactly one more state generated for the LR(1 ) parser than would be generated for an LALR(1 ) parser .Another observation to be made about merging item sets is the case in which the existing old set has been marked as complete , i.e. , transition ( goto ) sets have already been generated for the shift items in the set .", "label": "", "metadata": {}, "score": "40.893703"}
{"text": "level symbols and classes ) . s_x_z_2 : s x z VowelPair3 : Vowel .In a pair disjunction all lexical parts should be disjoint .This means .you can not specify for the same pair disjunction a / a and o / a or a / a and Vowel / Vowel .", "label": "", "metadata": {}, "score": "40.99466"}
{"text": "Example 9A - Generated Transition Item Set . i6 .goto('+ ' ) from i2 . , ' , ' ] .Also assume that other item set is generated during the course of constructing the item sets for the grammar : .", "label": "", "metadata": {}, "score": "41.008938"}
{"text": "Interweaving the two levels .The scanless interface interweaves the \" split \" and \" unified \" approaches and , I hope , preserves the best features of each .Here is full syntax of the example whitespace - and - digit language , described using Marpa::R2 's scanless interface : .", "label": "", "metadata": {}, "score": "41.28959"}
{"text": "( See also Note C above . )Note H. .After an item set is complete ( i.e. , after all of its reduction items have been marked and all of its shift items have gotos assigned to them ) , it can be compressed , which removes redundant items from it .", "label": "", "metadata": {}, "score": "41.60466"}
{"text": "i8 .cores : . i9 .cores : .However , merging these two sets would result in the following combined set : .Example 11D - Merged LR(1 ) Item Sets .i8 .Therefore , these two item sets can not be safely merged and still produce a usable LR(1 ) parser state .", "label": "", "metadata": {}, "score": "41.608818"}
{"text": "Syntactic and Semantic Analysis .A parser for a grammar parses an input stream of tokens ( terminal symbols ) , attempting to recognize syntactic constructs defined by the grammar .Each time that it finds a sequence of symbols matching one of the grammar rules , it is said to recognize a production rule of the grammar .", "label": "", "metadata": {}, "score": "41.66809"}
{"text": "Specifically , there is the problem of how to deal with the type of terminal symbols versus the type of nonterminal symbols .For an implementation that uses only one stack for both kinds of symbols , this means that both terminals and nonterminals must be represented by the same structure or object data type .", "label": "", "metadata": {}, "score": "41.747467"}
{"text": "It is important to note that redundant items can only be removed from item sets that have been marked as completed .Removing redundant items from an incomplete item set destroys useful information about the set that is required for later merging operations .", "label": "", "metadata": {}, "score": "42.006508"}
{"text": "Here is a typical use of a sub - lexical G - bang symbol : .Sub - lexical scoping turns up surprisingly often in complex macros .As well as defmacro ! , we 've seen it in at least one other example : the with - all - cxrs macro from section 5.6 , Recursive Solutions sub - lexically binds list accessor functions .", "label": "", "metadata": {}, "score": "42.08943"}
{"text": "The term parsing is used in a strict and a loose sense .Parsing in the loose sense is all phases of finding a grammar 's structure , including a separate recognition phase if the parser has one .( Marpa does . )", "label": "", "metadata": {}, "score": "42.176292"}
{"text": "Thus we could say that , for these speakers , [ l- ] is an allophone of /r-/ .Referring to a language , a system where the set of phonemic sounds , or phonemes , are represented by graphemes ( characters or letters ) which , standing alone , carry no meaning ; these are in turn built - up to form the meaning - carrying words .", "label": "", "metadata": {}, "score": "42.29189"}
{"text": "In the traditional method of evaluating a parse tree , every node which represents a terminal symbol has a value associated with it on input .Non - null inner nodes take their semantics from the production whose LHS they represent .", "label": "", "metadata": {}, "score": "42.328102"}
{"text": "The term LR(k ) means a parse using a Left - to - right scan with Right - most derivation requiring k symbols of look - ahead .( This will all be explained later . )Practically all computer languages are LR(1 ) grammars or simpler .", "label": "", "metadata": {}, "score": "42.473408"}
{"text": "Two item sets can be merged if they have identical LR(0 ) item cores .The LR(0 ) core of an item is the item without its look - ahead symbol .( Such items are generated during the course of constructing item sets for an LR(0 ) parser for a given grammar , which is a parser that makes its state transitions without using any look - ahead symbols . )", "label": "", "metadata": {}, "score": "42.7018"}
{"text": "Not only does alet bind this for us invisibly , but the use of this by our alet - fsm macro is similarly invisible .Alet - fsm injects a free variable into our lexical context without us being able to see it at all in the lexical context .", "label": "", "metadata": {}, "score": "42.741547"}
{"text": "This is determined by comparing their item cores , which are : .Example 9B - Item Cores .i6 .cores : . i11 .cores : .( Items having the same rule and marker position but with different look - ahead symbols have the same core , only one of which needs to be considered . )", "label": "", "metadata": {}, "score": "42.880093"}
{"text": "This document develops RIF - BLD ( the B asic L ogic D ialect of the R ule I nterchange F ormat ) based on a set of foundational concepts that are supposed to be shared by all logic - based RIF dialects .", "label": "", "metadata": {}, "score": "42.938766"}
{"text": "This is what is meant by the k in the term LR(k ) parser - the next k input symbols are used as look - ahead symbols for each state , and these k symbols determine the next state to transition to .", "label": "", "metadata": {}, "score": "43.131817"}
{"text": "For example : . r1 .Expr : Factor .Such rules are called single productions , since they define a production with only a single RHS symbol .Lexical Analysis .The parser reads streams of symbols and acts on them , recognizing grammatical constructs defined by the rules of the grammar .", "label": "", "metadata": {}, "score": "43.538025"}
{"text": "It is possible that a new item set will be merged into an incomplete existing item set , in which case none of the shift items will have their actions established yet .Eventually , when the merged item set is processed in Phase 2 , it will have the actions of all of its shift items established .", "label": "", "metadata": {}, "score": "43.55134"}
{"text": "Second , a single syntax for both accessing and setting an accessor is is implemented with get - pandoric and defsetf .Finally , the macro with - pandoric uses symbol - macrolet to install these generalised variables as seemingly new lexical variables with the same names as the closed - over variables .", "label": "", "metadata": {}, "score": "43.72291"}
{"text": "In the current implementation only the surface part of a pair can be a . sequence of more than one element .The special symbol \u00e2\u20ac\u02dc ?\u00e2\u20ac \u2122 stands for .the class of all possible symbols , including the morpheme and word . boundary .", "label": "", "metadata": {}, "score": "43.741722"}
{"text": "argument n . ) inst # class . sub # # super .The translation between the presentation syntax and the XML syntax of the RIF - BLD Rule Language is given by a table that extends the translation table of Section Translation of RIF - BLD Condition Language as follows .", "label": "", "metadata": {}, "score": "43.892063"}
{"text": "Some of the items being merged already existed in the set .Since item set i8 was merged into set i2 , all of the transitions ( gotos ) to set i8 must be fixed to make transitions to i2 instead .", "label": "", "metadata": {}, "score": "43.944046"}
{"text": "Sounds which do not contribute to meaning in speech are not rendered .In this way , the native alphabet of a language , as well as any transcription system which is designed to convey significant speech distinction , can be considered phonemic .", "label": "", "metadata": {}, "score": "43.97608"}
{"text": "The phonetic realization of a phoneme , that is , a particular phonetic instance of some abstract meaning - carrying unit in a language .For many phonemes , variation is permitted , and the set of these variations , or allophones , taken together , define the phoneme .", "label": "", "metadata": {}, "score": "44.18875"}
{"text": "Syntactically , RIF - BLD has a number of extensions to support features such as objects and frames , internationalized resource identifiers ( or IRIs , defined by RFC 3987 [ RFC 3987 ] ) as identifiers for concepts , and XML Schema data types .", "label": "", "metadata": {}, "score": "44.193794"}
{"text": "An item represents one of the steps in the recognition of a particular rule of a grammar .An item consists of the following components : .+ -----+----+-- RHS symbols .+ - LHS symbol + - look - ahead symbol .", "label": "", "metadata": {}, "score": "44.23756"}
{"text": "This situation arises within the item set because such a grammar allows nested if statements .This means that it is possible for an ELSE keyword symbol to follow a THEN Stmt sequence , as shown in the following example : .", "label": "", "metadata": {}, "score": "44.386253"}
{"text": "Consider the hypothetical grammar : .Example 11A - A Simple LR(1 ) Grammar . r1 .S : a A d r2 .S : a B e r3 .S : b A e r4 .S : b B d r5 .", "label": "", "metadata": {}, "score": "44.392937"}
{"text": "The non - redundant shift items that have not been eliminated have their look - ahead symbols replaced with a ' # ' mark to indicate that they are no longer needed at this point in the parser construction process .( They are still needed in the reduction items , however . )", "label": "", "metadata": {}, "score": "44.600735"}
{"text": "Sometimes this access limitation is useful , sometimes not .In with - all - cxrs , sub - lexicality could be considered undesirable .When our accessor is in with - all - cxrs 's sub - lexical scope , there is no problem : .", "label": "", "metadata": {}, "score": "44.901855"}
{"text": "In ordinary use , the word \" language \" means far more than a unordered list of its sentences .In parsing terminology , meaning ( or semantics as it is called ) is a separate issue .For parsing theory a language is exactly a set of strings -- that and nothing more .", "label": "", "metadata": {}, "score": "45.036522"}
{"text": "Consequently , some of the descriptions might not be purely accurate or correct when viewed from a formal academic perspective .Language parsing is generally divided into two categories : top - down parsing and bottom - up parsing .Top - down parsing generally refers to the parsing and recognition of LL(k ) grammars , and such parsers are typically implemented using a technique known as recursive - descent parsing .", "label": "", "metadata": {}, "score": "45.05774"}
{"text": "i8 i2 ) .A similar thing happens to item set i9 , i10 , i11 , and i17 , which are merged into sets i3 , i4 , i5 , and i6 , respectively .At the end of the algorithm , the to - do list is empty , all item sets have been marked as complete , and the done list contains the following item sets : .", "label": "", "metadata": {}, "score": "45.326683"}
{"text": "Standard definitions usually sharply distinguish terminal symbols from non - terminals .Marpa does not .Stages of parsing .A recognizer is a program that determines whether its input is in the language of a grammar and a start symbol .", "label": "", "metadata": {}, "score": "45.33634"}
{"text": "LR(1 ) items are constructed from grammar rules in a similar fashion to the way LR(0 ) are constructed , except that they also have one look - ahead symbol .For example : .Example 5B - LR(1 ) Item .", "label": "", "metadata": {}, "score": "45.395996"}
{"text": "Vowel_y : Vowel y Consonant : b c d f g h j k l m n p q r s t v w x z . @Pairs .This optional section contains the definition of pair disjunctions .Each disjunction is defined as a set of pairs .", "label": "", "metadata": {}, "score": "45.47039"}
{"text": "Eventually the configuration indicates that the parser has reached the state with an accept action and with no more look - ahead input symbols , signaling the end of a successful parse : .State and Symbol Stacks .The original theory assumes , in a typically mathematical fashion , that the state numbers , terminal symbols , and nonterminal symbols shifted onto the stack can assume any type or value within the confines of the given grammar .", "label": "", "metadata": {}, "score": "45.47821"}
{"text": "The details of their interaction are hidden from the user .Typically , the L0 parser finds tokens and passes them up to the G1 parser .The interface described in this document is surprisingly implementation - agnostic .The author developed the basics of this interface while trying an implementation approach , that used a single Marpa grammar , before changing to the dual grammar implementation .", "label": "", "metadata": {}, "score": "45.484726"}
{"text": "But there is still nothing to prevent us from installing a new closure , with its own lexical bindings and perhaps with changed behaviour in the indirection environment installed by alet .Much of the remainder of this chapter is about useful things we can do with indirection environments created by alet .", "label": "", "metadata": {}, "score": "45.555557"}
{"text": "The arguments of a term with named arguments constitute a finite bag of argument / value pairs rather than a finite ordered sequence of simple elements .Bags ( multisets ) are used here because the order of the argument / value pairs in a term with named arguments is immaterial and the pairs may repeat .", "label": "", "metadata": {}, "score": "45.736633"}
{"text": "Example 6B - Generated Closure Items .Factor ' + ' num , ' ( ' ] .Most of these items are redundant ( which will be explained below ) and will be eliminated from the set at a later point in the parser construction process .", "label": "", "metadata": {}, "score": "45.796043"}
{"text": "Each symbol macro will expand references to its symbol in the lexical scope of the symbol - macrolet into generalised variable references using our get - pandoric accessor / setter to access the result of evaluating the second argument to the macro : o!box ( stored in g!box ) .", "label": "", "metadata": {}, "score": "46.220596"}
{"text": "A language is a set of symbol strings .A grammar defines a language , as will be described later .It is important to note that the term language , as it is used in parsing theory , means something very different from what it means in ordinary use .", "label": "", "metadata": {}, "score": "46.222958"}
{"text": "Item 2 is the next progression , moving the marker to the right of the first symbol ( ' ( ' ) , representing a point where the first symbol has been successfully recognized by the parse .Similarly , items 3 and 4 are the next stages in the recognition of the grammar rule by the parse , moving the marker over the next symbols in the RHS of the rule , left to right , one at a time .", "label": "", "metadata": {}, "score": "46.29058"}
{"text": "( See also Note G below . )Note D. .Merging an item set into an existing item set involves moving all of the items from the new set into the existing set , discarding any duplicate items .Reduction items will already have their actions set , but shift items from the new set must have their actions set to be the same as corresponding shift items in the existing set which shift the same symbol .", "label": "", "metadata": {}, "score": "46.34211"}
{"text": "Note also that whitespace characters ( spaces and tabs ) and newlines are mostly irrelevant , and only serve to separate the characters of each symbol and punctuation mark .These should be used to make the grammar definition easier for humans to read .", "label": "", "metadata": {}, "score": "46.35505"}
{"text": "Are these symbols eq ?Why or why not ?Alet and Finite State Machines .With lambda and if there is only one useful anaphoric configuration .But the most interesting types of anaphoric macros make use of expansions in unforeseen ways .", "label": "", "metadata": {}, "score": "46.383404"}
{"text": "The parser machine ( DFA ) deals only with syntactic elements and has no knowledge of such higher - level concepts .LR(k ) Parser Construction .+ INCOMPLETE , need into paragraphs .Preliminary Concepts .The construction of a parser for an LR(k ) grammar involves generating transition tables for a DFA .", "label": "", "metadata": {}, "score": "46.396362"}
{"text": "For a group of items having the same rule and marker position , and differing only by their look - ahead symbols , all but one of the items is redundant .Thus all but one of the items can be eliminated from the set without removing any useful information from the set .", "label": "", "metadata": {}, "score": "46.541283"}
{"text": "Compare to phonology , which is the study of the systematization of these sounds in a particular language or languages .Some of the ( non - sonorant ) low - class consonants have phonetic equivalents in high - class , which allows any of the five lexical tones to be delivered in any phonetic syllable .", "label": "", "metadata": {}, "score": "46.545303"}
{"text": "usually is used to indicate the canonical form of the word or an . identifier of an external database entry .If the stem string and the reference strings are identical , only one . needs to be specified .FORMAL SYNTAX .", "label": "", "metadata": {}, "score": "46.578453"}
{"text": "With the exception of lexeme values , the semantics of the G1 grammar are exactly the same as for ordinary grammars .Actions may be specified for G1 rules and will behave as described in Marpa::R2::Semantics .Implementation .The scannerless interface uses two co - operating Marpa grammars , an approach pioneered by Andrew Rodland .", "label": "", "metadata": {}, "score": "46.622078"}
{"text": "The finer points are subtle the idea is simple : accessing a generalised variable is syntactically dual to setting it .You have only one setter form , setf , which is capable of setting all types of variables by using the same syntax you would use to access them .", "label": "", "metadata": {}, "score": "46.711838"}
{"text": "Transitions and Gotos .Once the closure of an item set has been constructed , the next step is to generate transitions for the items of the set .A transition is the progression of the parsing operation that occurs when the parser recognizes the next input symbol and shifts ( or pushes ) it onto its internal symbol stack .", "label": "", "metadata": {}, "score": "46.82014"}
{"text": "Marpa also sometimes uses a standard term with a definition which is slightly different from the standard one .( \" Ambiguous grammar \" is one example , and \" grammar \" itself is another . )When this is the case , it is explicitly pointed out .", "label": "", "metadata": {}, "score": "46.82184"}
{"text": "Note also that the resulting merged set has been labeled as being a transition from both set i2 and set i4 , since set i2 generated i6 and set i4 generated i9 .This means that the items in set i4 that formerly transitioned to i9 have to be updated to transition instead to i6 ( in the same way that was done in Example 8C above ) : .", "label": "", "metadata": {}, "score": "46.822"}
{"text": "It has , possibly , failed silently and thus un - safely .However , when you inject a free variable and there is no environment there to capture it , your entire expression has become free .When this happens , you need to decide what to do before you can evaluate that expression .", "label": "", "metadata": {}, "score": "46.897797"}
{"text": "+ INCOMPLETE .Item Set Merging .During the process of connstructing item sets for a grammar , transition item sets are generated ( as discussed above ) .Recall that a transition item set is constructed by generating one or more new transition kernel items , by shifting the same symbol from one or more items in the generating set .", "label": "", "metadata": {}, "score": "47.03271"}
{"text": "To find the \" L0 lexemes \" , Marpa looks for symbols which are on the LHS of a L0 rule , but not on the RHS of any L0 rule .To find the \" G1 lexemes \" , Marpa looks for symbols on the RHS of at least one G1 rule , but not on the LHS of any G1 rule .", "label": "", "metadata": {}, "score": "47.08684"}
{"text": "Traditionally , a grammar is considered useless if it is not cycle - free .The traditional deprecation of cycles is well - founded .A cycle is the parsing equivalent of an infinite loop .Once a cycle appears , it can be repeated over and over again .", "label": "", "metadata": {}, "score": "47.09854"}
{"text": "But programs are composed of simpler elements than symbols .Generally , a sequence of input symbols is fed into a parser as a stream of characters , usually stored in a simple text file .Lexical analysis is the process of reading an input character stream and separating and grouping the characters together into distinct lexical units .", "label": "", "metadata": {}, "score": "47.10485"}
{"text": "We will see shortly how I frame is used to determine the truth valuation of frame terms .Bags are used here because the order of the attribute / value pairs in a frame is immaterial and pairs may repeat .I sub gives meaning to the subclass relationship .", "label": "", "metadata": {}, "score": "47.1221"}
{"text": "It is not intended as a concrete syntax for a rule language .RIF defines a concrete syntax only for exchanging rules , and that syntax is XML - based , obtained as a refinement and serialization of the EBNF syntax .", "label": "", "metadata": {}, "score": "47.122948"}
{"text": "This kind of character - level information is not convenient to represent at the structural ( G1 ) level .It is certainly possible to write whitespace - aware BNF for the fragment of the C language above .And it is certainly possible to extend it to include more and more of the declaration syntax .", "label": "", "metadata": {}, "score": "47.134308"}
{"text": "RIF - BLD supports several kinds of terms : constants and variables , positional terms , terms with named arguments , equality , membership , and subclass terms , and frames .The word \" term \" will be used to refer to any kind of terms .", "label": "", "metadata": {}, "score": "47.19909"}
{"text": "The item sets in the done list are then compared to this item set for possible merging .This set has the same kernel item cores as item set i2 , which are : .Since there are no reduce / reduce conflicts between item sets i2 and i8 , the two sets can be merged .", "label": "", "metadata": {}, "score": "47.269127"}
{"text": "In phonemic transcription , this is done in a manner such that only semantically significant phonemes are rendered .In phonetic transcription , attempt is made at a detailed rendering of all sonic details of speech , even those that may have little or no distinctive significance in the source language .", "label": "", "metadata": {}, "score": "47.281776"}
{"text": "For example , Perl 's perlpodspec page has a number of statements like this : .The lexical level is character by character .The structural level is less well - defined , but in practice it ignores most of the character - by - character issues , and it almost always avoids dealing with whitespace .", "label": "", "metadata": {}, "score": "47.28648"}
{"text": "Moreover , the ordinary capture problem can be solved with gensym or even cooler feature , automatic gensyms ( look at the documentation of the syntax - quote reader macro if you want to know more ) .Speaking as a non - expert , Clojure macros seem to fare pretty well with respect to the hygiene issue .", "label": "", "metadata": {}, "score": "47.298573"}
{"text": "A mechanism to introduce identifiers , i.e. a mechanism to break hygiene , is needed if you want to define binding forms .Such identifiers can then be introduced in macros and made visible to expanded code .In order to understand the mechanism , you must always remember that identifiers in Scheme - in the technical sense of objects recognized by the identifier ? predicate - are not just raw symbols , they are syntax objects with lexical information attached to them .", "label": "", "metadata": {}, "score": "47.36123"}
{"text": "Although the topics are very practical for use in real code , their main purpose is as a platform for discussing the properties and variations of anaphoric macros .Using macros to extend the concept of a closure is currently a hot research topic [ FIRST - CLASS - EXTENTS ] [ OPENING - CLOSURES ] .", "label": "", "metadata": {}, "score": "47.39823"}
{"text": "Pairs section .A morpheme boundary is . /e .Constraints may be specified in the form of a list of typed feature . structures .They are affix - driven : the rule is licensed if at least .one of them subsumes the closest corresponding affix .", "label": "", "metadata": {}, "score": "47.405075"}
{"text": "Allophonic variation does not change the semantic content of the phoneme .In the phonemic transcription scheme used by this website , each syllable is presented in two parts : a phonemic portion and a tone indicator .\" Phonemic portion \" refers to the basic sounds of the consonants and vowels present .", "label": "", "metadata": {}, "score": "47.51442"}
{"text": "Ambiguous Grammars .Most typical programming languages use grammars that are ambiguous .This means that they when they are implemented as pure LR(k ) parsers , they contain grammar conflicts .Such conflicts come in two varieties : shift / reduce conflicts and reduce / reduce conflicts .", "label": "", "metadata": {}, "score": "47.516197"}
{"text": "All reduction items are marked by setting their actions to the appropriate grammar reduce rule and look - ahead symbol .Doing this insures that any possible reduce / reduce conflicts will be detected when attempting to merge the item set with another existing ( complete ) item set .", "label": "", "metadata": {}, "score": "47.617554"}
{"text": "When the Marpa documents use the term parsing in its strict sense , they will speak explicitly of \" parsing in the strict sense \" .Otherwise , parsing will mean parsing in the loose sense .Parsers often use a lexical analyzer to convert raw input , usually input text , into a token stream , which is a series of tokens .", "label": "", "metadata": {}, "score": "47.82338"}
{"text": "It takes more involved checking to determine if the token sequence makes sense at a higher , semantic level .To illustrate , consider the following sequence of Java tokens : .While this particular sequence of tokens is syntactically correct ( forming a Java expression ) , it is semantically incorrect because the types of the operands do not match the operators .", "label": "", "metadata": {}, "score": "47.88646"}
{"text": "This solves the problem of representing terminal symbols ( lexical tokens ) as arbitrarily complex data types , but there is another related problem concerning nonterminal symbols .Nonterminal Stack .Nonterminal symbols represent production rules of the grammar matching sequences of zero or more input tokens .", "label": "", "metadata": {}, "score": "47.902634"}
{"text": "When a single word is pronounced for demonstration purposes , a speaker may use different prosody ( intonation , duration , stress ) than if the word is pronunced in the midst of natural speech .These prosodic characteristics are called citation form .", "label": "", "metadata": {}, "score": "47.928776"}
{"text": "This section contains the rules that specify the structure of words .It has the general shape of a context free grammar over typed feature structures .There are three basic types of rules : binary , goal and affixes .Binary rules specify the result of the concatenation of two elements . where Lhs is called the left hand side , and Rhs1 and Rhs2 the first and . second part of the right hand side .", "label": "", "metadata": {}, "score": "47.993366"}
{"text": "Lexicon . below ) .An affix rule consists of lexical string associated to a typed . feature structure .Goal rules specify the valid results constructed by the grammar .They . consist of just a typed feature structure .In addition to these three basic rule types , there are prefix or suffix .", "label": "", "metadata": {}, "score": "48.026978"}
{"text": "Sub - Lexical Scope .Our defmacro ! macro - defining macros that we defined in section 3.5 , Unwanted Capture look for the presence of automatic gensyms in the provided code using Graham 's flatten utility .Now is the time to confess a small lie we have been telling through this book .", "label": "", "metadata": {}, "score": "48.06034"}
{"text": "This is true because all of the remaining items from the new set are non - kernel shift ( closure ) items that do not add any useful information to the merged set .Reduction items always need to be added to the merged set because they are used to convert the item set into a parser state .", "label": "", "metadata": {}, "score": "48.350235"}
{"text": "num from Factor . '+ ' from Factor .+ INCOMPLETE .First Set Generation Algorithm .The look - ahead symbols for LR(k ) items are generated from first sets generated from the symbols of the grammar .An LR(k ) parser with k - symbol look - ahead requires first k symbol sets .", "label": "", "metadata": {}, "score": "48.35685"}
{"text": "Programmers must supply a lexical analyzer class that implements the Lexer YACC / M library class .The crucial method is getToken ( ) , which is responsible for reading the next token from the input stream and returning an integer token code or zero if no more tokens are available .", "label": "", "metadata": {}, "score": "48.454636"}
{"text": "Here is a brief description of each . section : . @Alphabets .In this section the lexical and surface alphabet are declared .All symbols forming each alphabet has to be listed .Symbols may appear in both the lexical and surface alphabet definition in which case it is considered a bi - level symbol , otherwise it is a lexical only or surface only symbol .", "label": "", "metadata": {}, "score": "48.51083"}
{"text": "We conclude this chapter with such an example .A limitation of lexical scope sometimes lamented upon is the fact that the C OMMON L ISP function eval will throw out your current lexical environment when it evaluates the form passed to it .", "label": "", "metadata": {}, "score": "48.56318"}
{"text": "They inject the symbol this which we rely on being captured by the expansion of an alet macro .This sort of injection of symbols might seem to be bad style or error - prone , but it is actually a common macro technique .", "label": "", "metadata": {}, "score": "48.5974"}
{"text": "A production consists of a left hand side and a right hand side .In a context - free grammar , like those Marpa parses , the left hand side of a production is always a symbol string of length 1 .", "label": "", "metadata": {}, "score": "48.689186"}
{"text": "B : c .In the process of constructing item sets for this grammar , the following two sets are generated : .Example 11B - LR(1 ) Item Sets .i8 .These two item sets have identical kernel item cores , which are : .", "label": "", "metadata": {}, "score": "48.7238"}
{"text": "With this framework , one can extend RIF - BLD with default negation , higher - order features , and so on .Then RIF - BLD is described independently of the RIF Framework , for the benefit of those who desire a quicker path to RIF - BLD and are not interested in the extensibility issues .", "label": "", "metadata": {}, "score": "48.736626"}
{"text": "LR(k ) grammars can handle all of these forms of recursive rules .The only limitation on recursive productions for LR(k ) grammars is that for a given rule in which the LHS symbol appears in the RHS , there must be more than one symbol in the RHS .", "label": "", "metadata": {}, "score": "48.976143"}
{"text": "In this example , three of the scanless interface 's extensions to the Stuifzand interface are used .Character classes .Perl character classes are now allowed on the RHS of prioritized and quantified rules .The example shows character classes only in L0 rules , but character classes can also be used in G1 rules .", "label": "", "metadata": {}, "score": "49.01727"}
{"text": "Which Perl am I compiled for ?PERL.version for formerly $ ^V $ ] % ?LANG . . . . . .Hash of Grammar # What is the current set of interwoven languages ?GRAMMAR . . .current grammar $ ?", "label": "", "metadata": {}, "score": "49.054047"}
{"text": "Also note that the production rules appear in the reverse order that they occur during the parsing actions above .At this point in the discussion , the details about how the parser knows when to push a symbol and when to reduce a production rule have not been explained .", "label": "", "metadata": {}, "score": "49.07161"}
{"text": "This class of scoping leads into another category of mostly unexplored macros : macros that change how lisp macros work , when they are expanded , where references are valid , how special forms are interpreted , etc .Eventually , a macro - programmable macro expander .", "label": "", "metadata": {}, "score": "49.12256"}
{"text": "Example 7A - Transition Item Generation . i2 .+ ' num , ' ) ' ] .This item set was reached by shifting a Factor symbol , as indicated by the marker being positioned to the right of that symbol in each of the items in the set .", "label": "", "metadata": {}, "score": "49.204903"}
{"text": "The structure of a parse can be represented as a series of derivation steps from the start symbol to the input .Another way to represent structure is as a parse tree .Every symbol used in the parse is represented by a node of the parse tree .", "label": "", "metadata": {}, "score": "49.378296"}
{"text": "Sometimes abstractions just feel right and it is hard to exactly say why .Probably because most programming is the disharmonious combining of disjoint parts , it is surprising and pleasant when you discover abstractions that - seemingly by chance - fit together perfectly .", "label": "", "metadata": {}, "score": "49.38743"}
{"text": "It defines the syntax and semantics for the bodies of the rules in RIF - BLD .However , it is envisioned that this fragment will have a wider use in RIF .In particular , it will be used as queries , constraints , and in the conditional part in production rules ( see RIF PRD ) , reactive rules , and normative rules .", "label": "", "metadata": {}, "score": "49.392105"}
{"text": "Closure Traits .in every block can be inserted several special named blocks that are started at certain times .Because they are treated as part of a block object , they are called traits .They also can be used as prefix operators , called contextualizers , that force different contexts , but there are much more different contexts then 3 .", "label": "", "metadata": {}, "score": "49.426804"}
{"text": "Redundant items are those that do not contribute any useful distinguishing information about the item set that is not already known from other items in the set .The result is more efficient use of memory space and faster item set comparisons during phase 1 .", "label": "", "metadata": {}, "score": "49.492214"}
{"text": "Example 5C - LR(2 ) Item .Expr ' ) ' , ' + ' num ] .Thus an LR(k ) item has k look - ahead symbols .Item Sets .As was stated above , the construction of parser states for a grammar involves first constructing LR(k ) item sets from the grammar , and then converting these sets into parser states .", "label": "", "metadata": {}, "score": "49.499855"}
{"text": "This optional section contains the definition of symbol classes .Each class is defined as a set of symbols , or other classes .If the class contains only bi - level elements it is a bi - level class , otherwise it is a lexical or surface class .", "label": "", "metadata": {}, "score": "49.541508"}
{"text": "All of the nonterminal symbols in a grammar are defined by one or more rules , and occur as the left - hand - side ( LHS ) symbol of these rules .Nonterminal symbols do not comprise input to a parser but are only used internally by the parser to represent the progress of a parse .", "label": "", "metadata": {}, "score": "49.588146"}
{"text": "This assumption must now be demonstrated to be true with some degree of analytical rigor .Loose Ends .The Honalee Algorithm , as far as the author knows , is the first LR(k ) parser construction algorithm of its kind .", "label": "", "metadata": {}, "score": "49.6248"}
{"text": "Sequences of symbols given as input to a parser are composed entirely of terminal symbols from the grammar .Terminal symbols are also called lexical tokens ( which will be explained in more detail below ) .The grammar of Example 1 contains the following terminal symbols : .", "label": "", "metadata": {}, "score": "49.705544"}
{"text": "The abstract meaning of a word , sentence , text , or utterance -- the idea that a phrase denotes in the world -- is its semantics .Assuming the function of language is to communicate meaning , it is semantics that syntax hopes to efficiently transmit .", "label": "", "metadata": {}, "score": "49.77793"}
{"text": "( r2 ) $ any reduce 2 .LR(k ) Parsing Algorithm .The following pseudo - code is the fundamental LR(k ) parser algorithm .It assumes the existence of a parser state stack capable of holding state numbers , as well as a value stack capable of holding parsing symbols .", "label": "", "metadata": {}, "score": "49.784817"}
{"text": "The simplest unit of sound that distinguishes meaning in a language .For some phonemes , phonetic variation may be permissible ( regional accents or speech variation of an individual ) ; each of these realizations of the phoneme is called an allophone .", "label": "", "metadata": {}, "score": "49.84298"}
{"text": "Instead , it is inferred as follows .Each constant symbol in a RIF - BLD formula ( or a set of formulas ) is expected to occur in at most one context : as an individual , a function symbol of a particular arity , a predicate symbol of a particular arity , or an individual .", "label": "", "metadata": {}, "score": "49.86189"}
{"text": "As a whole , such means may be termed marking resources , since sundry languages give them different functional roles .In Thai , for example , lexical tone is given a semantic function , and the function of expressing aspect is achieved with special lexemes .", "label": "", "metadata": {}, "score": "49.874928"}
{"text": "Such marking can be obligatory or discretionary , and can signal sundry semantic , discourse , or information - structural function .In some Thai words , a single written consonant may serve as the final consonant of a closed syllable and then be pronounced again as the initial consonant of the following syllable .", "label": "", "metadata": {}, "score": "49.883606"}
{"text": "What extra bindings could be useful to forms inside the body of a let form ?The very purpose of let is to create such bindings so capturing the variable introductions given to a let form is already done .However , a macro enhancement to let can have complete access to all the forms given to it , even the body of expressions intended to be evaluated with the new bindings .", "label": "", "metadata": {}, "score": "49.95964"}
{"text": "This macro uses sublet underneath but changes each form in the body by macro expanding them with the macroexpand-1 function .Now , instead of appearing in the raw list structure , references to symbols must occur after the first step of macro expansion .", "label": "", "metadata": {}, "score": "50.015938"}
{"text": "num , ' ) ' ] .Items 1 and 2 of this set produce the following new transition set by shifting symbol ' + ' : .Example 8B - New Transition Item Set . i9 .goto('+ ' ) from i4 .", "label": "", "metadata": {}, "score": "50.10154"}
{"text": "i0 .Factor ' + ' num , ' + ' ]( Factor , i2 ) .One possibility when displaying this as a state is to list only the item cores of the set .This means that the cores of items 4 and 5 , and items 6 and 7 , and items 8 and 9 would be combined and shown on a single line : .", "label": "", "metadata": {}, "score": "50.21591"}
{"text": "If a sequence of symbols from a grammar is fed into a machine that implements a parser for that grammar , the machine can determine whether or not the input symbols form a valid sentence of the grammar .If the sequence is valid , the parser accepts the input sentence without error , otherwise the parser may detect one or more syntax errors in the input sequence .", "label": "", "metadata": {}, "score": "50.317677"}
{"text": "The Thai language does not generally alter lemmas in this way , so it is called an isolating language .In linguistics , information structure refers to the manner in which discourse participants tacitly negotiate , manage and organize ongoing elaboration .", "label": "", "metadata": {}, "score": "50.454693"}
{"text": "For example , if all references to a are sub - lexical , it will replace them with gensyms : .However , because sub - lexical scope does n't involve expanding macros , and thus necessarily does n't involve interpreting special forms like quote , instances of the symbol a that are n't supposed to be variable references are also changed : .", "label": "", "metadata": {}, "score": "50.48523"}
{"text": "The symbol ' a here is being promoted to a bona fide identifier , by adding to it the lexical context associated to the macro name .You can check that the identifier a is really introduced as follows : .For that purpose I have added an identifier - append utility in my ( aps lang ) library , defined as follow : . ; ; take an identifier and return a new one with an appended suffix ( define ( identifier - append i d .", "label": "", "metadata": {}, "score": "50.629852"}
{"text": "This is represented with a special $ other action : .$ other error .If this happens , the parser issues an appropriate error message and may optionally perform some kind of error recovery action .Combining all of the pieces above that are displayed for the conversion of item set i0 into a complete parser state yields the following output , which neatly summarizes the shift , goto , and error actions for the state : .", "label": "", "metadata": {}, "score": "50.667088"}
{"text": "The symbol being shifted governs which state the parser makes a transition to , based on rules of the grammar .When an item set ( representing a parsing state ) makes a transition to another item set , ... .+ INCOMPLETE .", "label": "", "metadata": {}, "score": "50.767494"}
{"text": "This in turn implies that tokens are the same type as ( or a derived subtype of ) parse tree nodes .This constraint does not always lead to a satisfactory implementation solution .The approach taken by YACC / M is to split the parser symbol stack into two separate stacks , one for terminal symbols ( tokens ) and another for nonterminal ( LHS ) symbols .", "label": "", "metadata": {}, "score": "50.81095"}
{"text": "The major problem of syntax - case is a cosmetic one : it looks very complex and cumbersome to use , but that can be easily solved by providing a nicer API - which I did with sweeet - macros .Actually I have been able to use sweet - macros for twenty episodes without explaining the intricacies of the hygienic expansion .", "label": "", "metadata": {}, "score": "50.828262"}
{"text": "An LALR(1 ) parser does not carry along enough information about how it arrived at the merged state i8+i9 , so it can not decide whether to reduce an A or a B LHS symbol .A canonical LR(1 ) parser , on the other hand , carries along enough information because it will enter either state i8 or i9 depending on the previous input symbols , and can therefore safely decide whether to reduce an A or a B .", "label": "", "metadata": {}, "score": "50.85919"}
{"text": "The left - most k symbols of this list are the current look - ahead symbols for the LR(k ) parser .In this example , the current look - ahead symbol for an LR(1 ) parser is the one symbol ' + ' .", "label": "", "metadata": {}, "score": "50.91937"}
{"text": "\\W. . . . .Match anything but a word character .\\x [ ... ] .Match a character given in hexadecimal ( brackets optional ) .\\X [ ... ] .Match anything but the character given in hexadecimal ( brackets optional ) .", "label": "", "metadata": {}, "score": "50.928574"}
{"text": "Item sets are identical if they contain the same kernel items .If this occurs , the algorithm discards the newly generated transition set and uses the previously existing set in its place .Sometimes the newly generated transition set is almost identical to another existing item set , but contains kernel items with different look - ahead symbols .", "label": "", "metadata": {}, "score": "50.969963"}
{"text": "goto('+ ' ) from i4 . , ' , ' ] .The newly generated transition set i11 is similar to , but not exactly the same , as the previously generated set i9 .Since the sets are not identical , set i9 can not simply be used in place of i11 .", "label": "", "metadata": {}, "score": "51.039963"}
{"text": "Contextual symbols in my or any caller 's lexical scope .The following relative names are also reserved but may be used anywhere in a name : .OUTER . . . .Symbols in the next outer lexical scope UNIT . . . . .", "label": "", "metadata": {}, "score": "51.09677"}
{"text": "The same process of creating transition item sets and kernel items is performed for all of the items in the current set .All of the new transition item sets that are generated from item set i0 are : . i1 .", "label": "", "metadata": {}, "score": "51.10296"}
{"text": "The production for the non - terminal TERM defines RIF - BLD terms -- constants , variables , or COMPOUND terms .The RIF - BLD presentation syntax does not commit to any particular vocabulary for the names of variables or for the literals used in constant symbols .", "label": "", "metadata": {}, "score": "51.164146"}
{"text": "This change affects these items : . i3 .Factor , ' ) ' ]( Factor , .i8 i2 ) .Factor ' + ' num , ' ) ' ]( Factor , .i8 i2 ) .Factor ' + ' num , ' + ' ]", "label": "", "metadata": {}, "score": "51.170486"}
{"text": "These items are part of a transition set which is generated from the set currently under consideration .In this newly generated item set , the marker is advanced over the ' + ' symbol to create the following new items : .", "label": "", "metadata": {}, "score": "51.219353"}
{"text": "PERL.version for formerly $ ^V $ ] % ?LANG . . . . . .Hash of Grammar # What is the current set of interwoven languages ?GRAMMAR . . . .current grammar $ ?FILE . . . . . . .", "label": "", "metadata": {}, "score": "51.235962"}
{"text": "Wherever symbol or string X derives Y , we may also say that Y matches X or that X matches Y .It is particularly common to say that X matches Y when X or Y is a sentence .The parse of an input by a grammar is successful if and only if , according to the grammar , the start symbol produces the input sentence .", "label": "", "metadata": {}, "score": "51.290092"}
{"text": "Completely evaluated ( hence immutable ) sequence Range . . . .A pair of Ordered endpoints ; generates immutables when iterated Set . . . . .Unordered collection of values that allows no duplicates Bag . . . . .", "label": "", "metadata": {}, "score": "51.557762"}
{"text": "An action can be something like adding a new identifier to the compiler 's symbol table , setting an attribute of an identifier , generating intermediate code , issuing an error message , and so forth .Actions generally perform some kind of semantic analysis , which involves checking that the input stream of tokens makes sense .", "label": "", "metadata": {}, "score": "51.568893"}
{"text": "If a derivation is not trivial or direct , that is , if it has more than one step , then it is an indirect derivation .Technically , a symbol X and a string that consists of only that symbol are two different things .", "label": "", "metadata": {}, "score": "51.582565"}
{"text": "Before we continue with pandoric macros , first we need to point out one of the most important examples of duality of syntax in C OMMON L ISP : generalised variables .The details of this are complicated , and I wo n't describe all of them here .", "label": "", "metadata": {}, "score": "51.695393"}
{"text": "If the macros do n't do either of these things - or if the forms are n't macros at all - this type of super sub - lexical scope acts just like sub - lexical scope : .As mentioned above , super sub - lexical scope is actually an infinite class of scopes , one that is almost completely unexplored intellectually .", "label": "", "metadata": {}, "score": "51.706078"}
{"text": "Item set i0 now has all of its reduction and shift actions filled in , and is marked complete : .Completed Item Set - i0 .i0 .Factor ' + ' num , ' + ' ]( Factor , i2 ) .", "label": "", "metadata": {}, "score": "51.72969"}
{"text": "Note that match is longest TOKENS .There may be more than one longest match , in which case Marpa uses the full set of longest matches .Semantics .The value of a L0 rule is always the string it matches , and the value of a lexeme from the G1 point of view is the same as its value from the L0 point of view .", "label": "", "metadata": {}, "score": "51.730164"}
{"text": "A grammar is also composed of rules ( also known as syntax rules ) , which define how sequences of symbols can be strung together to form valid sentences .The grammar of Example 1 contains the following rules : .Example 3 - Simple Grammar Rules .", "label": "", "metadata": {}, "score": "51.833515"}
{"text": "An example of a non - alphabetic language is Chinese ; it is ideographic .In linguistics , aspect refers to the way that a language might express the manner in which events progress or unfold over time .This is in contrast to tense , which places events in time relative to one another .", "label": "", "metadata": {}, "score": "51.845734"}
{"text": "Unlike format , sharp - backquote does n't use sequential positioning .Instead it uses the number on our anaphoric bindings .As a consequence , the order can be mixed up and we can even splice in bindings more than once : .", "label": "", "metadata": {}, "score": "51.90226"}
{"text": "The most common programming languages are LALR(1 ) grammars , which are a proper subset of LR(1 ) grammars .Grammars .A grammar is simply a set of symbols and rules that define a particular language .More precisely , the symbols and rules define valid sentences of the grammar .", "label": "", "metadata": {}, "score": "51.982292"}
{"text": "Example 7C - Transition Item Generation . i2 .+ ' num , ' + ' ] ( ' + ' , i6 ) .+ ' num , ' ) ' ] ( ' + ' , i6 ) .Sometimes in the course of generating a new transition item set T by shifting symbol s from set G , the new set T will have an identical set of items as another set P which has already been generated .", "label": "", "metadata": {}, "score": "52.04985"}
{"text": "Long before you finish , I expect you will realize that the \" unified \" approach is simply not workable .The authors of the C language relegated lexical issues to their own brief section , and ignored them in most of their language description .", "label": "", "metadata": {}, "score": "52.137146"}
{"text": "Ambiguity .Marpa allows ambiguous grammars .Traditionally we say that a parse is ambiguous if , for a given grammar and a given input , more than one derivation tree is possible .However , Marpa allows ambiguous input tokens , which the traditional definition does not take into account .", "label": "", "metadata": {}, "score": "52.180027"}
{"text": "This simple optimization can speed up the merging algorithm by an order of magnitude or so .Consider , for example , the following item set , which contains one kernel item and several non - kernel closure items : .Example 10A - Item Set .", "label": "", "metadata": {}, "score": "52.234367"}
{"text": "A transition item inherits the same look - ahead symbol from the item that generates it .Thus item i6.1 has the same look - ahead symbol ( ' + ' ) as item i2.1 from which it was generated , and the same relationship holds for items i6.2 and i2.2 .", "label": "", "metadata": {}, "score": "52.255753"}
{"text": "That is , I C must map the constants of a data type dt in accordance with L dt .RIF - BLD does not impose restrictions on I C for constants in the lexical spaces that do not correspond to primitive datatypes in DTS .", "label": "", "metadata": {}, "score": "52.35598"}
{"text": "They act like macros and are not visible in instance markup .For the XML Schema Definition ( XSD ) of the RIF - BLD condition language see Appendix Specification .The XML syntax for symbol spaces utilizes the type attribute associated with XML term elements such as Const .", "label": "", "metadata": {}, "score": "52.380817"}
{"text": "Reduce / Reduce Conflicts .Reduce / reduce conflicts are more difficult to resolve .These conflicts occur within states that have two different reduction actions for the same look - ahead symbol .+ INCOMPLETE .Resulting Parser States .Converting all of the item sets of the example grammar produces the following parser states : .", "label": "", "metadata": {}, "score": "52.384995"}
{"text": "num , ' ) ' ] .But set i9 is identical to the previously generated set i6 .That being the case , i9 is discarded and all of the transitions out of set i4 going to i9 are changed to go to i6 instead : .", "label": "", "metadata": {}, "score": "52.38549"}
{"text": "Factor : ' + ' Factor r5 .Factor :Factor ' + ' num Nonterminal Symbols n1 .Expr n2 .Factor .This grammar is composed of four terminal symbols , two nonterminal symbols , and five production rules .", "label": "", "metadata": {}, "score": "52.436558"}
{"text": "If a symbol from Const occurs in more than one context , the formula ( or a set of formulas ) is not considered to be well - formed in RIF - BLD .Any term ( positional or with named arguments ) of the form p ( ... ) , where p is a predicate symbol , is also an atomic formula .", "label": "", "metadata": {}, "score": "52.466217"}
{"text": "That is an important observation - one with ramifications still not completely explored .Sublet interprets your code differently than does the code - walker provided with C OMMON L ISP .Here we are standing on one of the many edges of macro understanding .", "label": "", "metadata": {}, "score": "52.483322"}
{"text": "Example : \u0e40\u0e2a\u0e21\u0e35\u0e22\u0e19 /sa L miian R / in which the cluster / \u0e2a\u0e21 / is straddled .Considering semantics to be the meaning that we wish to convey with language , syntax is the vehicle that arranges ideas structurally -- according to the grammar rules of a language -- into a linear form suitable for spoken or written communication .", "label": "", "metadata": {}, "score": "52.50036"}
{"text": "The following pseudo - code is an algorithm for constructing the first symbol sets for all of the nonterminals in an LR(1 ) grammar .// LR(1 )First Set Generation Algorithm . begin .// Initialize . step 1 .Add all of the nonterminals of the grammar to the nonterminals queue ; . loop : . while queue is not empty , .", "label": "", "metadata": {}, "score": "52.539356"}
{"text": "As long as all the states go back to the original state - instead of going to each other - alet over alambda is a convenient way to specify nameless state machines .The following is a typical counter closure that takes an argument n and can have its direction toggled between increment and decrement by n when we pass the symbol invert as the argument instead of a number : .", "label": "", "metadata": {}, "score": "52.545715"}
{"text": "An undifferentiated mass of bits .Object Introspection .WHAT . . .prototyp des objekttyps , short name in string context WHICH . . .object ID WHO . . . .package , that support that object , long name in string context WHERE . . .", "label": "", "metadata": {}, "score": "52.712326"}
{"text": "The effect of the syntax .RIF - BLD does not support negation .This is the only obvious simplification with respect to RIF - FLD as far as the semantics is concerned .Truth values .Recall that logical entailment in RIF - FLD is defined with respect to an unspecified set of intended semantic structures and that dialects of RIF must make this notion concrete .", "label": "", "metadata": {}, "score": "52.8446"}
{"text": "Thanks to our use of implicitisation with the tree - leaves macro , it is easy to find and understand the code duplication because the code is close together .Sublet takes the form representing the let bindings and applies our let - binding - transform utility , generating new list structure in the process .", "label": "", "metadata": {}, "score": "52.85239"}
{"text": "and andthen X .Loose or . . . . . . . .or xor orelse X .Categories .Metaoperators .They appear mostly before regular operators and give them different meaning or greater range .In the example V stands for Value , L for left Value , and R for right .", "label": "", "metadata": {}, "score": "52.995453"}
{"text": "Note that VowelPair1 and VowelPair2 don\u00e2\u20ac \u2122 t specify the same thing : VowelPair2 would match a / o but VowelPair1 would not .Implicit pairs are specified by the name of a bi - level symbol or a bi- .level class .", "label": "", "metadata": {}, "score": "53.049446"}
{"text": "You will also notice that , as quickly as it is becoming hard to write , it is even more quickly becoming \" write - only \" -- impossible to read .In making your BNF whitespace - aware , you are more than doubling its size .", "label": "", "metadata": {}, "score": "53.128532"}
{"text": "This means that the parser expects to see no more input tokens once the goal symbol has been recognized .The initial item set ( i0 ) is further constructed by adding all of the closure items to it .Closure items are generated from the items that already exist in the set which have their marker to the left of all of their RHS symbols .", "label": "", "metadata": {}, "score": "53.174286"}
{"text": "In practice , it makes for shorter and less confusing listings if only the kernel item cores are shown .Such non - kernel items really do not contribute much to the understanding of the state , especially if there are large numbers of them , and they tend to clutter the listing with a lot of redundant items .", "label": "", "metadata": {}, "score": "53.199867"}
{"text": "This section is optional and can also be repeated .This section lists all the lexical entries of the morphological description .Unlike the other sections , definitions do not have a name .A definition consist of a typed feature strucure followed by a list of lexical stems that share that feature structure .", "label": "", "metadata": {}, "score": "53.233047"}
{"text": "Closures are now even more first - class data structures than they used to be .Bindings that were previously closed to outside code are now wide open for us to tinker with , even if those bindings were compiled to something efficient and have long since had their accessor symbols forgotten .", "label": "", "metadata": {}, "score": "53.256775"}
{"text": "LR(k ) item sets generally contain a lot of redundant items , which are items that do not contribute any additional information about the set that is not already contributed by other items in the set .+ INCOMPLETE .Reduction items are never redundant because they and their look - ahead symbols are used to determine whether or not to reduce on that symbol when converting the item set into a parser state .", "label": "", "metadata": {}, "score": "53.26365"}
{"text": "The two levels of language description .Programmers usually describe the syntax of a language at two levels .The same two - level approach can be convenient for implementing a parser of the language .But , implementation aside , a two - level description seems to be a natural approach to the design issues that arise in languages intended for practical use .", "label": "", "metadata": {}, "score": "53.29888"}
{"text": "+ ' num , ' + ' ] ( ' + ' , . i9 i6 ) .+ ' num , ' ) ' ] ( ' + ' , . i9 i6 ) .It must be noted that when comparing the cores of two item sets , it is necessary to compare only the cores of kernel items , and non - kernel items can be safely ignored .", "label": "", "metadata": {}, "score": "53.3921"}
{"text": "Single value that could be one of several alternatives Pair . . . . .A single key - to - value association Mapping .Set of Pairs with no duplicate keys Signature .Function parameters ( left - hand side of a binding ) Capture . . .Function call arguments ( right - hand side of a binding ) Blob . . . . .", "label": "", "metadata": {}, "score": "53.400745"}
{"text": "So describing lexical scope as creating variables only accessible to code in the textual body of a binding construct is actually a lie too - macros can inject variable references .Such variables are injected from outside the textual body of the binding construct .", "label": "", "metadata": {}, "score": "53.505768"}
{"text": "A frame term is a term composed of an object I d and a collection of attribute - value pairs .Example 1 shows conditions that are composed of uniterms , frames , and existentials .The examples of the frames show that variables can occur in the syntactic positions of object Ids , object properties , or property values .", "label": "", "metadata": {}, "score": "53.532143"}
{"text": "Factor ( r1 ) .Factor + num ( r5 ) .num ( r3 ) .This diagram shows the derivation of each nonterminal symbol encountered in the parse of the input tokens .The terminal symbols are underlined , which graphically illustrates why they are called terminal symbols - they occur at the terminal leaf nodes of the derivation tree .", "label": "", "metadata": {}, "score": "53.592598"}
{"text": "\\b . . . . .Match a word boundary .\\B. . . . .Match when not on a word boundary .\\c [ ... ] .Match a named character or control character .\\C [ ... ] .", "label": "", "metadata": {}, "score": "53.617996"}
{"text": "The addition of the look - ahead symbol ( i.e. , the ' + ' symbol in the items above ) represents the fact that at the point in the parse represented by an item , the current input symbol is expected to be that particular look - ahead symbol .", "label": "", "metadata": {}, "score": "53.618954"}
{"text": "As with all chaining constructs , be sure you do n't end up in an infinite loop .Three methods are presented that can be used on our closures created with make - stats - counter or any other pandoric closure that exports the necessary variable names .", "label": "", "metadata": {}, "score": "53.677246"}
{"text": "Categories .Metaoperators .They appear mostly before regular operators and give them different meaning or greater range .In the example V stands for Value , L for left Value , and R for right .A number is the array index . hyper . . . . . .", "label": "", "metadata": {}, "score": "53.734432"}
{"text": "for each shItem in comeFrom , [ Note F ] .if shItem.action is goto(T , set ) , . end for ; .// Discard the new set , replace with merged gSet .break mergeLoop ; . else . mark the grammar as not LALR ; [ Note E ] .", "label": "", "metadata": {}, "score": "53.812256"}
{"text": "Plambda can export any variables in your lexical environment , transparently making them available for other lexical scopes to access - even ones written and compiled before or after the plambda form is .This is an incremental improvement to our let over lambda closure system designed to maximise dual syntax .", "label": "", "metadata": {}, "score": "53.876"}
{"text": "The Honalee algorithm works by merging item sets ( states ) as they are constructed , whereas the canonical LR(k ) construction algorithm works by constructing all of the item sets ( states ) first and then merging those that can be merged afterwards .", "label": "", "metadata": {}, "score": "53.913048"}
{"text": "RIF - BLD uses no extra syntax for declaring signatures .Instead , signatures are inferred .Since RIF - BLD requires that each symbol is associated with a unique signature , the signature can be determined from the context in which the symbol is used .", "label": "", "metadata": {}, "score": "53.938118"}
{"text": "So in actual practice , the parser stack is usually implemented as two separate stacks , one for state numbers and the other for symbols .Classic YACC , for instance , implements the parser stack in this fashion .Terminal Stack .", "label": "", "metadata": {}, "score": "53.977753"}
{"text": "Expr : ' ( ' Expr ' ) ' .The items resemble the rule from which they are constructed , with a few additions ., has been inserted between symbols in the right hand side ( RHS ) of the rule .", "label": "", "metadata": {}, "score": "53.998512"}
{"text": "In this way , both Thai and English can be represented using a single - byte per character .Although nowawdays becoming obsolete because of the prevalance of Unicode , which uses a 16-bit character width , this mapping or \" encoding \" is still sometimes favored for its compactness in transmission or storage .", "label": "", "metadata": {}, "score": "54.04853"}
{"text": "Each list contains all of the sets with identical kernel cores ( as well as other sets that happen to have the same hash value ) , which is much quicker to search for a merging set than the entire done list .", "label": "", "metadata": {}, "score": "54.104164"}
{"text": "The semantics for a production describe how to calculate the value of the node which represents the LHS ( the parent node ) from the values of zero or more of the nodes which represent the RHS symbols ( child nodes ) .", "label": "", "metadata": {}, "score": "54.115303"}
{"text": "LR(k ) Parsing Theory .Background .The following is a simplified explanation of LR(k ) bottom - up parsing theory .Some of the concepts and terminology are presented in simplified form so that it is more easily understood by novices .", "label": "", "metadata": {}, "score": "54.183228"}
{"text": "If there is no such indication , then the affix adjacent . to the morpheme where the first character of the focus occurs is used .In case there is no affix , the typed feature structure of the lexical .stem is used . @", "label": "", "metadata": {}, "score": "54.192337"}
{"text": "The signature for the variable symbols does not permit them to occur in the context of predicates , functions , or formulas .In particular , unlike in RIF - FLD , a variable is not an atomic formula in RIF - BLD .", "label": "", "metadata": {}, "score": "54.201004"}
{"text": "If they do not , the programmer receives a fatal message which describes the problem and the symbols involved .So in practice I will usually simply refer to \" lexemes \" .Longest tokens match .The L0 grammar looks for tokens on a longest tokens match basis .", "label": "", "metadata": {}, "score": "54.21643"}
{"text": "The values of these local . attributes ar not stored in the database or written on the final output . of the program .Typed feature structures .Typed feature structures are used in the grammar and spelling rules .It is the specification of a type and the value of some associated attributes .", "label": "", "metadata": {}, "score": "54.306618"}
{"text": "These states are constructed from item sets , which are in turn derived from the grammar itself .Items .The process of constructing parser states for a grammar involves the construction of item sets , which are simply sets of items .", "label": "", "metadata": {}, "score": "54.31318"}
{"text": "Strangely , this really is the right thing to do because it allows macros that completely hide the presence of generalised variables from the macro 's users , even if they choose to use setq .When using setq for this remember that it only helps for its splicing safety property ; as we 've seen , a symbol can reference any generalised variable thanks to symbol - macrolet .", "label": "", "metadata": {}, "score": "54.31713"}
{"text": "( For historic reasons , L0 is sometimes also called G0 . )It is important to realize that the difference between L0 and G1 is one of level of description and NOT one of precision or exactness .A structural description of Perl 's use statement , much like the one I showed above , is in Perl 's source code ( perly.y ) , along with many other , similar , structural - level descriptions .", "label": "", "metadata": {}, "score": "54.377644"}
{"text": "This is usually achieved in a manner such that the original script can be reconstructed from the transliteration result .In linguistics , underspecification refers to the general ability of languages to represent incomplete information .Since this is an inherent feature of language , it is considered important for linguistic formalisms to be able to capture the precise semantic content of an utterance , nothing more and nothing less .", "label": "", "metadata": {}, "score": "54.44285"}
{"text": "No new transition sets can be generated from this set because it does not contain any shift items .+ INCOMPLETE .+ REDO The processing of every item set is not shown , but there are two item sets that should be noted : item sets i ? ? ?", "label": "", "metadata": {}, "score": "54.471786"}
{"text": "Closures are no longer closed ; we can open closures as easily as re - writing our lambda forms to be plambda forms .We use plambda to export lexical variables and with - pandoric to import them as completely equivalent lexical variables .", "label": "", "metadata": {}, "score": "54.513763"}
{"text": "This is why in Scheme the macro expansion is not literally inserted in the original code , and a lot of magic takes place to avoid name clashes .In practice , the implementation of Scheme macros takes care of distinguishing the introduced identifiers with some specific mechanism ( it could be based on marking the names , or on explicit renaming ) .", "label": "", "metadata": {}, "score": "54.692566"}
{"text": "Thus , by itself a symbol can not be a proposition in RIF - BLD , but a term of the form p ( ) can be .The constant symbols that correspond to XML Schema data types all have the signature term in RIF - BLD .", "label": "", "metadata": {}, "score": "54.696983"}
{"text": "a gensym to each binding with a print name corresponding to the binding name .Sublet expands into a let form which binds these gensym symbols to the values passed into the binding form , then uses tree - leaves to replace all occurrences of the binding name symbols in the provided code with their corresponding gensyms .", "label": "", "metadata": {}, "score": "54.76872"}
{"text": "Therefore there is no technical reason why hygienic macros are not widespread in the whole Lisp world , just a matter of different opinions on the importance of the problem and the different tradeoffs .I believe that eventually all Lisp dialects will start using hygienic macros , but that could take decades , because of inertia and backward - compatibility concerns .", "label": "", "metadata": {}, "score": "54.772118"}
{"text": "+ INCOMPLETE .Extra Whatever ? ?+ MOVE Each terminal symbol has a precedence associated with it , which is its rank relative to the other terminal symbols , and is used to resolve any syntactic conflicts in the grammar .", "label": "", "metadata": {}, "score": "54.787357"}
{"text": "values [ R5RS - P25 ] .C OMMON L ISP , of course , is designed right -everything is a boolean .It must also be pointed out that aif and alambda , like all anaphoric macros , violate lexical transparency .", "label": "", "metadata": {}, "score": "54.83969"}
{"text": "There are much better ways to define records in Scheme , as we will see in part VI of these Adventures .Anyway , def - book works as follows .Given a single identifier name and two values it introduces three identifiers in the current lexical scope : name ( bound to a vector containing the two values ) , name - title ( bound to the first value ) and name - author ( bound to the second value ) .", "label": "", "metadata": {}, "score": "54.845463"}
{"text": "More Phors ?Some of the most interesting macros from Paul Graham 's On Lisp are anaphoric macros .An anaphoric macro is one that deliberately captures a variable from forms supplied to the macro .Thanks to their transparent specifications , these deliberately captured variables allow us windows of control over the macro expansion .", "label": "", "metadata": {}, "score": "55.04697"}
{"text": "i0 .Factor ' + ' num , ' + ' ] .The next step in phase 1 is to mark all of the reduction items in the set .Set i0 has no reduction items , so nothing is done .", "label": "", "metadata": {}, "score": "55.14745"}
{"text": "Marpa knows this and \" does what you mean . \"Discard rules .A new type of rule is introduced : a \" discard \" rule .A discard rule has a : discard pseudo - symbol on its LHS and one symbol name on its RHS .", "label": "", "metadata": {}, "score": "55.147552"}
{"text": "This is ensured by a restriction in Section Interpretation of Formulas .I isa gives meaning to class membership .The relationships # and # # are required to have the usual property that all members of a subclass are also members of the superclass , i.e. , o # cl and cl # # scl must imply o # scl .", "label": "", "metadata": {}, "score": "55.187805"}
{"text": "Eventually , though , the error will be detected by the parser .The parser may perform other reduction actions , but eventually it will reach a state requiring a shift action .It is in this eventual state that no shift action for the current ( erroneous ) look - ahead symbol will be found and the parser will declare a syntax error .", "label": "", "metadata": {}, "score": "55.24435"}
{"text": "^ ^ L .& div mod L .^ L .Replication . . . . . . .x xx X .Junctive and . . . . .& also X .Named unary . . . . .", "label": "", "metadata": {}, "score": "55.2474"}
{"text": "x17 i6 ) .x17 i6 ) .x13 .x14 .i9 .x15 .goto(num ) from i6 .i10 .x16 . goto ( ' ) ' ) from i7 .x17 .Item sets with names like ' .", "label": "", "metadata": {}, "score": "55.2621"}
{"text": "In linguistics , determiner refers to a class of words which modify noun phrases , adding information about definiteness , deixis , relevance , reference , quantification , selection , degree , etc .Although Thai does n't have words which correspond to the English articles ' a ' , ' an ' , and ' the ' , Thai achieves these linguistic functions with a variety of other determiner constructions .", "label": "", "metadata": {}, "score": "55.281914"}
{"text": "( plural : lemmata )The canonical citation form of a word , also known as a dictionary headword .Since thai - language . com is a Thai - to - English dictionary , each Thai lemma appears with a definition written in English .", "label": "", "metadata": {}, "score": "55.29779"}
{"text": "When the parser reaches this particular point during a parse , it has successfully recognized the rule from which the item was generated ( rule r2 in this case ) .+ MOVE THIS PARA .At this point , the parser reduces the rule , replacing the symbols on the parser stack representing the three RHS symbols of the rule ( ' ( ' , Expr , and ' ) ' ) with the single LHS symbol of the rule ( Expr ) .", "label": "", "metadata": {}, "score": "55.386604"}
{"text": "These symbols , also known as lexical tokens ( or just tokens ) , are passed to the parser .The parser , in turn , performs syntactic analysis on the stream of input tokens .For example , consider the following stream of characters from a sample Java program .", "label": "", "metadata": {}, "score": "55.415306"}
{"text": "In other words , if one or more kernel items in an old set have the same core as one or more kernel items in another new set , then the closure items generated from these kernel items will all have the same cores as well .", "label": "", "metadata": {}, "score": "55.421402"}
{"text": "Match a word boundary .\\B . . . .Match when not on a word boundary .\\c [ ... ] .Match a named character or control character .\\C [ ... ] .Match any character except the bracketed named or control character . \\d . . . .", "label": "", "metadata": {}, "score": "55.46779"}
{"text": "The parser uses only the terminal symbol number of a token , which does not need to be anything more complicated than a simple integer value .However , any user - defined semantic actions taken by the parser usually need more information about each token , hence the need to allow terminal symbols to be represented by user - defined structures or object types .", "label": "", "metadata": {}, "score": "55.46998"}
{"text": "- - From this augmented grammar rule , an initial item is constructed , which is the first item to be added to the initial item set ( which is named i0 ): .i0 .The initial item represents the progress of the parse at the very start of reading an stream of input symbols ( tokens ) .", "label": "", "metadata": {}, "score": "55.478313"}
{"text": "As one example , consider declarations in the C language .In the first of the two lines above the whitespace is necessary .In the second of the two lines whitespace would be allowed , but is not necessary .You can not simply insist on whitespace between all symbols , because whitespace is and should be optional between some symbols and not between others .", "label": "", "metadata": {}, "score": "55.481327"}
{"text": "The Thai language has an elaborate system of linguistic aspect .While all verbs have their own lexical aspect --a protoypical semantic entailment , Thai speakers can select from over a dozen special aspect marking words to add further refinement to the description of the event or state .", "label": "", "metadata": {}, "score": "55.739616"}
{"text": "The Honalee algorithm produces all of the item sets for an LR(k ) grammar , starting with an initial item set containing an item representing an augmented grammar production .The resulting item sets are then converted into states for a deterministic finite state automaton ( DFA ) that implements a bottom - up shift - reduce LR(k ) parser for the grammar .", "label": "", "metadata": {}, "score": "55.971924"}
{"text": "Assignment of signatures to each constant symbol .These represent function symbols of arity n , user - defined predicate symbols of arity n , and n -ary builtin predicates , respectively .These are signatures for terms with named arguments and predicates with arguments named s1 , ... , sk , respectively .", "label": "", "metadata": {}, "score": "55.98266"}
{"text": "^ ^. ^. ^ C .Chaining infix . . . . .!eqv X .Tight and . . . . . . . .& & X .Conditional . . . . . . . ? ? ff fff R .", "label": "", "metadata": {}, "score": "55.98644"}
{"text": "They can also function predicatively .Entries in the thai - language . com dictionary are tagged as belonging to one or more categories .In the thai - language . com system of categories , the term category root refers to a list of all the categories which do not belong to any other category .", "label": "", "metadata": {}, "score": "56.045425"}
{"text": "Rule r5 above illustrates that the LHS symbol can occur as the left - most symbol in the RHS of a rule , which is known as a left - recursive production rule .Similarly , rule r4 illustrates that the LHS symbol can occur as the right - most symbol in a rule , which is known as a right - recursive production .", "label": "", "metadata": {}, "score": "56.128517"}
{"text": "\\H. . . . .Match anything but horizontal whitespace .\\L [ ... ] .Everything within the brackets is lowercase .\\Q [ ... ] .All metacharacters within the brackets match as literal characters .\\r . . . . .", "label": "", "metadata": {}, "score": "56.14257"}
{"text": "r11 .These rules define the nonterminal symbol List as being composed of either nothing or of a ' / ' symbol followed by an Items symbol .Rule r10 is an empty production since it has no symbols in its right - hand side .", "label": "", "metadata": {}, "score": "56.15597"}
{"text": "Here is the above inside out expansion of the invertible counter alambda use case : .From this , we notice that alambda can use the labels special form to make all of its bindings available to all of the bodies of its functions .", "label": "", "metadata": {}, "score": "56.199295"}
{"text": "After a brief interlude into anaphora introduced by read macros , the remainder of this chapter describes a modest , specific application of anaphora related to one of the central themes of this book : the lexical closure- let over lambda .", "label": "", "metadata": {}, "score": "56.21176"}
{"text": "Marpa can handle grammars with useless symbols .Recursion and cycles .If any symbol in the grammar non - trivially produces a symbol string containing itself , the grammar is said to be recursive .If any symbol non - trivially produces a symbol string with itself on the left , the grammar is said to be left - recursive .", "label": "", "metadata": {}, "score": "56.362698"}
{"text": "Attributes .In this section , the name of attributes ( sometimes called features ) and their associated value set .At most 32 different values may be declared for an attribute .Examples : Gender : feminine masculine neuter Number : singular plural Person : 1st 2nd 3rd Transitive : yes no Inflection : base intermediate final .", "label": "", "metadata": {}, "score": "56.41252"}
{"text": "Example 8A - Another Transition Generating Item Set . i4 .+ ' num , ' + ' ] ( ' + ' , i9 ) .+ ' num , ' ) ' ] ( ' + ' , i9 ) .", "label": "", "metadata": {}, "score": "56.46186"}
{"text": "reverses the order of the operands Xop . . .combinator .Filetest Ops . : r . . .file is readable by effective uid / gid .: w . . .file is writeable by effective uid / gid .", "label": "", "metadata": {}, "score": "56.467503"}
{"text": "They allow you to open up closures whenever needed and represent a beautiful confluence of a variety of C OMMON L ISP language features : anaphoric macros , generalised variables , and symbol macros .But what good are they , really ?", "label": "", "metadata": {}, "score": "56.55663"}
{"text": "Two item sets can be merged if they have the same item cores .Note that if two item sets have identical kernel items ( not just the same kernel item cores ) , then they are identical sets and thus one of them is completely redundant , i.e. , a duplicate of the other .", "label": "", "metadata": {}, "score": "56.568993"}
{"text": "A number of extensions are planned to support built - ins , additional primitive XML data types , the notion of RIF compliance , and so on .Tool support for RIF - BLD is forthcoming .RIF dialects that extend RIF - BLD in accordance with the RIF Framework for Logic Dialects will be specified in other documents by this working group .", "label": "", "metadata": {}, "score": "56.57499"}
{"text": "// Attempt to merge the new item set with an existing set .mergeLoop : . for each gSet in doneList , [ Note I ] .if set and gSet can be merged , [ Note C ] .( set and gSet have identical kernel item cores and .", "label": "", "metadata": {}, "score": "56.582504"}
{"text": "But the most interesting possibilities for indirection chains pop up when we add them dynamically .Because we can create new closures at run - time and because we can access the internals of a closure through an anaphor , we can re - write how functions work at run - time .", "label": "", "metadata": {}, "score": "56.60091"}
{"text": "Constant symbols have the form : LITERAL^^SYMSPACE , where SYMSPACE is an IRI string that identifies the symbol space of the constant and LITERAL is a Unicode string from the lexical space of that symbol space .Equality , membership , and subclass terms are self - explanatory .", "label": "", "metadata": {}, "score": "56.71691"}
{"text": "This section defines the precise relationship between the semantics of RIF - BLD and the semantic framework of RIF - FLD .The remaining sections describe the semantics of RIF - BLD without referring to the general framework -- except for Primitive Data Types whose definition is not duplicated here .", "label": "", "metadata": {}, "score": "56.741882"}
{"text": "For example , consider the nonterminal symbol Factor from the grammar in example 1 above .Examining the grammar rules makes it fairly obvious that the first terminal symbols that any derivation of Factor can possibly start with are the following terminals : . num from r3 . '", "label": "", "metadata": {}, "score": "56.77277"}
{"text": "goto('+ ' ) from i2 .num , ' + ' ] .num , ' ) ' ] .Item 1 from set i2 above ( item i2.1 ) generates the new item 1 in the new set i6 ( item i6.1 ) , and similarly , item i2.2 generates the new item i6.2 .", "label": "", "metadata": {}, "score": "56.81018"}
{"text": "A grammar is a set of rules , associated with a set of symbols , one of which is distinguished as the start symbol .A symbol string , or simply string where the meaning is clear , is an ordered series of symbols .", "label": "", "metadata": {}, "score": "56.812244"}
{"text": "Personally I have made my mind up and I am in the pro - hygiene camp now .I should admit that for a long time I have been in the opposite camp , preferring the simplicity of define - macro over the complexity of syntax - case .", "label": "", "metadata": {}, "score": "56.860928"}
{"text": "Adjectives in Thai can grammatically function in two different ways .In the predicative role , they act as the predicate of a sentence , and characterize the state or characteristics of the subject of the sentence .One tool at the disposal of languages for accomplishing linguistic function is to mark speech with rhythm , stress , or intonation ( pitch - change ) .", "label": "", "metadata": {}, "score": "56.86793"}
{"text": "It is supposed to be a common part of a number of RIF dialects , including RIF PRD .The EBNF grammar for a superset of the RIF - BLD condition language is as follows .VARNAME .The production rule for the non - terminal CONDITION represents RIF condition formulas ( defined earlier ) .", "label": "", "metadata": {}, "score": "56.877064"}
{"text": "Example 1 - A Simple Grammar .Terminal Symbols t1 .num t2 . '( ' t3 . ' ) ' t4 . '+ ' Rules r1 .Expr : Factor r2 .Expr : ' ( ' Expr ' ) ' r3 .", "label": "", "metadata": {}, "score": "56.90206"}
{"text": "( def - syntax ( define - a x ) # ' ( define a x ) ) .( define - a x ) apparently expand to ( define a x ) , so you may find the following surprising : .", "label": "", "metadata": {}, "score": "56.927338"}
{"text": "With alambda we capture the name self so that we can use it to refer to the very anonymous function we are building .In other words , recursing is as simple as a call to self .For example , the following function returns a list 2 If the condition is false , an absent tertiary clause on an if form returns nil , which is a list . of the numbers from n down to 1 : .", "label": "", "metadata": {}, "score": "57.057766"}
{"text": "Factor ' + ' num , ' ( ' ] .No closure items can be generated from items 5 or 6 .At this point , the next closure item is generated from item 7 , but it is already present in the item set , so it is not added again : .", "label": "", "metadata": {}, "score": "57.155563"}
{"text": "Fortunately , shift / reduce conflicts like this are solved fairly easily .Note that the parser should , in fact , prefer to shift the ELSE symbol instead of reducing by rule 24 .This is the most general solution to shift / reduce conflicts , to prefer shifting over reducing .", "label": "", "metadata": {}, "score": "57.193794"}
{"text": "Example 2B - Simple Grammar Nonterminal Symbols . n1 .Expr n2 .Factor .Programmers never see or use these nonterminal symbols directly , but they are used internally by the parser .For example , whenever an Expr is recognized by the parser , the Expr nonterminal symbol is used to represent that recognition internally within the parser 's state tables .", "label": "", "metadata": {}, "score": "57.20676"}
{"text": "Rules having no semantic actions are assigned a default action that assigns $ 1 to $ $ , provided that there is at least one RHS symbol in the rule .This is usually the most reasonable action to take for single productions .", "label": "", "metadata": {}, "score": "57.358757"}
{"text": "file is an ASCII text file ( heuristic guess ) .: B . . .file is a binary data file ( opposite of : T ) .: M . . .Script start time minus file modification time , in days .", "label": "", "metadata": {}, "score": "57.38473"}
{"text": "Factor ' + ' num , ' ) ' ]( Factor , . x8 i2 ) .Factor ' + ' num , ' + ' ]( Factor , . x8 i2 ) . i4 .goto(num ) from i0,i3,i5 . , ' ) ' ] ( ' ) ' , r3 ) M : x10 . i5 .", "label": "", "metadata": {}, "score": "57.503296"}
{"text": "For example , a rule is unproductive unless every symbol on its RHS either is a terminal or is the LHS of some other rule .A rule which is inaccessible or unproductive is called a useless rule .Marpa can handle grammars with useless rules .", "label": "", "metadata": {}, "score": "57.577026"}
{"text": "In particular , we can add functionality , or methods , for closures to use without having to re - instantiate instances of already created objects .Make - stats - counter is a lambda over let over plambda we have created to create counters , except that it maintains three pieces of information .", "label": "", "metadata": {}, "score": "57.69969"}
{"text": "The main loop repeats as long as there are transition item sets in the to - do list or there are incomplete sets in the done list .done list : i0 c i1 i2 i3 i4 i5 .Phase 2 of the algorithm picks up the next incomplete item set from the done list , which is i1 : . i1 .", "label": "", "metadata": {}, "score": "57.71628"}
{"text": "These two definitions are equivalent for entailment of RIF - BLD conditions by RIF - BLD rulesets , since all rules in RIF - BLD are Horn -- it is a classical result of Van Emden and Kowalski [ vEK76 ] .", "label": "", "metadata": {}, "score": "57.784992"}
{"text": "Semantics .In real life , the structure of a parse is usually a means to an end .Grammars usually have a semantics associated with them , and what the user actually wants is the value of the parse according to the semantics .", "label": "", "metadata": {}, "score": "57.80319"}
{"text": "PACKAGE ) CORE . . . . .Outermost lexical scope , definition of standard Perl GLOBAL . . .Interpreter - wide package symbols , really CORE::GLOBAL PROCESS .Process - related globals ( superglobals ) , CORE::PROCESS COMPILING .Lexical symbols in the scope being compiled CALLER . . . .", "label": "", "metadata": {}, "score": "57.832954"}
{"text": "Unordered collection of values that allows duplicates Junction .Single value that could be one of several alternatives Pair . . . . .A single key - to - value association Mapping .Set of Pairs with no duplicate keys Signature .", "label": "", "metadata": {}, "score": "57.86542"}
{"text": "This configuration shows that states s0 and s2 have been visited and shifted onto the stack , along with their corresponding symbols ' ( ' , num , and ' + ' , respectively .The current state is the right - most element of the parser stack , which in this example is state s7 .", "label": "", "metadata": {}, "score": "57.87352"}
{"text": "Consonant sound which can \" carry a tune : \" ng , n , m , y r , l , w. All sonorants are low - class consonants - memorize this important fact .Some linguists may use the term \" resonant \" to refer to such consonants .", "label": "", "metadata": {}, "score": "57.889416"}
{"text": "In Thai , each common noun has one or more particular classifier words , one of which is used to indicate the number of items being discussed .A classifier word often describes the shape or other physical characteristics of the group of common nouns that it classifies .", "label": "", "metadata": {}, "score": "57.91625"}
{"text": "There are many ways we can take advantage of the this anaphor provided by alet .Since the environment is accessed through a dummy closure that forwards all invocations to the real closure pointed to by this , we can pass the dummy closure reference around , copying it as often as needed .", "label": "", "metadata": {}, "score": "57.917908"}
{"text": "+ INCOMPLETE .Example XX ? -Redundant Items .Factor , ' + ' ]( Factor , - ) R .Factor , ' ( ' ]( Factor , - ) R .num , num ] ( num , - ) .", "label": "", "metadata": {}, "score": "57.918976"}
{"text": "This is because the rules in which a particular symbol appears in the LHS define that symbol as a nonterminal symbol .Terminal symbols , in constrast , never appear as LHS symbols .As the rules for Expr and Factor above ( rules r2 , r4 , and r5 ) illustrate , a given LHS symbol can appear as a RHS symbol in one or more of its own definitions .", "label": "", "metadata": {}, "score": "57.988163"}
{"text": "Together they would travel on a boat with shifting stacks Jackie kept a look - ahead for Puff 's reduction acts .Noble scripts and programs would bow when ' ere they ran And semantic acts would set their flags when Puff derived his scan .", "label": "", "metadata": {}, "score": "58.062534"}
{"text": "This read macro abstracts out a common macro pattern .For example , if we have a list of variables and would like to make a list of let bindings that bind each variable to a symbol , say , empty , we can use mapcar like so : .", "label": "", "metadata": {}, "score": "58.09674"}
{"text": "Since the different attribute / value pairs are supposed to be understood as conjunctions , the following is required : .Quantification : TVal I ( Exists ?v 1 ... ?v 1 ... ?v 1 , ... , ?", "label": "", "metadata": {}, "score": "58.10301"}
{"text": "Symbols in the current package ( aka $ ?PACKAGE ) CORE . . . . .Outermost lexical scope , definition of standard Perl GLOBAL . . .Interpreter - wide package symbols , really CORE::GLOBAL PROCESS .Process - related globals ( superglobals ) , CORE::PROCESS COMPILING .", "label": "", "metadata": {}, "score": "58.10337"}
{"text": "file has size greater than 0 ( returns size in bytes ) .: f . . .file is a plain file .: d . . .file is a directory .: l . . .file is a symbolic link .", "label": "", "metadata": {}, "score": "58.107067"}
{"text": "If we had used lambda instead of plambda in the definition of make - stats - counter , most of this information would be inaccessible to us .We would be locked out because these variables would be closed to us .", "label": "", "metadata": {}, "score": "58.171593"}
{"text": "The done list is currently empty , so there are no other items sets that could be merged with the current one .The final step of phase 1 is to move the current item set to the end of the done list .", "label": "", "metadata": {}, "score": "58.172646"}
{"text": "The result of the derivation step is another symbol string , one in which every occurence of the LHS symbol from the production is replaced by the RHS of the production .For example , if A , B , C , D , and X are symbols , and . is a production , then . is a derivation step , with \" A X D \" as its beginning and \" A B C D \" as its end or result .", "label": "", "metadata": {}, "score": "58.251266"}
{"text": "That is , like a good number of macros in this book , they invisibly introduce lexical bindings and thus can not be created with macro systems that strictly enforce hygiene .Even the vast majority of Scheme systems , the platform that has experimented the most with hygiene , provide unhygienic defmacro - style macros - presumably because not even Scheme implementors take hygiene very seriously .", "label": "", "metadata": {}, "score": "58.28276"}
{"text": "Shift / reduce conflicts are the most commonly encountered type of grammatical ambiguity , and are generally easily solved .For example , the common if - then - else programming construct is , in fact , a classic example of a shift / reduce conflict : .", "label": "", "metadata": {}, "score": "58.285347"}
{"text": "Match anything but a word character .\\x [ ... ] .Match a character given in hexadecimal ( brackets optional ) .\\X [ ... ] .Match anything but the character given in hexadecimal ( brackets optional ) .Regex Modifier .", "label": "", "metadata": {}, "score": "58.314705"}
{"text": "Traditionally , and in Marpa as well , every node is either a inner node or a leaf node .In Marpa , leaf nodes are of two kinds : .Nodes for nulled symbols .A node for a nulled symbol is called a nulled node .", "label": "", "metadata": {}, "score": "58.337894"}
{"text": "A lexical analyzer is often called a lexer or a scanner , and lexical analysis is often called lexing or scanning .The series of symbols represented by the series of tokens becomes the symbol string input seen by the recognizer .", "label": "", "metadata": {}, "score": "58.35244"}
{"text": "Factor ' + ' num , ' + ' ] .These closure items are identical to items 7 , 8 , and 9 , which are already present in the set , so they are not added to the set .", "label": "", "metadata": {}, "score": "58.408314"}
{"text": "The conceptual set of all inflected forms of a word .In Thai , since there is little inflectional morphology , this set generally has only one word in it , and that word is the lemma , or citation form .", "label": "", "metadata": {}, "score": "58.410995"}
{"text": "In most cases it is the last form in the body since the results from that form will be returned from the let statement itself 7 Because let provides an implicit progn .We 've seen that when we return a lambda expression that references these bindings created by let , the result is a lexical closure - an object frequently stored and used to later access the variables in the let statement .", "label": "", "metadata": {}, "score": "58.44499"}
{"text": "It is possible to specify a set of values for an attribute by listing . set ( with respect to all possible values of that attribute ) indicated .with \u00e2\u20ac\u02dc !Example : Assuming the declaration of Gender as above , the following . @", "label": "", "metadata": {}, "score": "58.45958"}
{"text": "S . . .file is a socket .: b . . .file is a block special file .: c . . .file is a character special file .: t . . .filehandle is opened to a tty .", "label": "", "metadata": {}, "score": "58.525135"}
{"text": "These two rules result in an item set with the following two items : . i37 .This item set in then converted into a parser state : .ELSE Stmt ELSE shift 38 ELSE reduce 24 ... shift(s38)/reduce(r24 ) conflict on ELSE .", "label": "", "metadata": {}, "score": "58.56111"}
{"text": "RHS length table Contains the number of symbols in the RHS of each rule ; indexed by rule number .Action look - up table Contains an action , either a shift / goto state , or a reduction rule ; indexed by state number and look - ahead symbol .", "label": "", "metadata": {}, "score": "58.638042"}
{"text": "generate all closure items for set ; . mark all reduce actions in set ; . if set can be merged with existing gSet in doneList , . merge set into gSet ; . change all goto(T , set ) transitions in comeFrom . to goto(T , gSet ) ; . else . append ( still incomplete ) set to incList ; . end phase1 ; .", "label": "", "metadata": {}, "score": "58.73498"}
{"text": "But this closure is slightly different than a regular closure .While both this closure and regular closures are pointers to a single environment , one that can have any number of references to it , this closure uses indirection to change which piece of code gets run when it is invoked .", "label": "", "metadata": {}, "score": "58.739983"}
{"text": "file is a binary data file ( opposite of : T ) .: M . . .Script start time minus file modification time , in days .:A . . .Same for access time .: C . . .", "label": "", "metadata": {}, "score": "58.780285"}
{"text": "S C , t ] ; .// Create new transition items for all items shifting S .for each shItem in set , .S J , u ] , . add k to newSet ; . end if ; . end for ; .", "label": "", "metadata": {}, "score": "58.838337"}
{"text": "Note F. .After merging a new transition item set with an existing set , the shift ( goto ) actions that transitioned from the previously completed set must be changed to transition instead to the merged set .Once this is done , the new transition item set can be discarded , and the merged set is used in its place .", "label": "", "metadata": {}, "score": "58.867577"}
{"text": "Using auxiliary functions to help with defining macros is a good habit to pick up .Not only can it make your definitions more readable , but also can help when testing components of the macro and can prove useful in future macros .", "label": "", "metadata": {}, "score": "58.88437"}
{"text": "Initially , the stack is empty when the DFA starts in its initial state .As the parser consumes input symbols ( tokens ) and makes transitions from state to state , it pushes and pops symbols onto its stack .At any point during the parsing operation , the contents of the stack reflect the input symbols that have been consumed and recognized so far .", "label": "", "metadata": {}, "score": "58.92054"}
{"text": "Contextual symbols in the immediate caller 's lexical scope CONTEXT .Contextual symbols in my or any caller 's lexical scope .The following relative names are also reserved but may be used anywhere in a name : .OUTER . . .", "label": "", "metadata": {}, "score": "59.018158"}
{"text": "Had we not restricted the import , the lexical context of # ' here would have been the entire rnrs set of identifiers .We can use dummy - ctxt to expand a macro into a minimal context .Here is an example of a trivial macro expanding into such minimal context : .", "label": "", "metadata": {}, "score": "59.031536"}
{"text": "For example , if the string containing only the symbol X derives a string Y , we will usually say simply that \" X derives Y \" .Wherever symbol or string X derives Y , we may also say X produces Y .", "label": "", "metadata": {}, "score": "59.05196"}
{"text": "Compare draw a picture to like ice cream ; ignoring tense , which describes when these might have occurred , we can still see that the former naturally has a beginning , middle , and end , whereas the latter does not .", "label": "", "metadata": {}, "score": "59.119423"}
{"text": "Note that COMPOUND terms are treated as rules with an empty condition part -- they are usually called facts .Note that , by a definition in Section Formulas , atomic formulas that correspond to builtin predicates ( i.e. , formulas with signature bi_atomic ) are not allowed in the conclusion part of a rule .", "label": "", "metadata": {}, "score": "59.127842"}
{"text": "If any derivation from the start symbol uses a rule , that rule is called reachable or accessible .A rule that is not accessible is called unreachable or inaccessible .If any derivation which results in a sentence uses a rule , that rule is said to be productive .", "label": "", "metadata": {}, "score": "59.132717"}
{"text": "The non - kernel closure items of this set can be ignored for the purposes of examining the kernel item core of the set , which is simply : .Impossible Item Set Merges .There are situations in which two item sets have identical kernel item cores but still can not be merged , because merging items from both sets would produce reduce / reduce conflicts .", "label": "", "metadata": {}, "score": "59.16295"}
{"text": "A very simple language .In order to focus on very basic issues , I will use as an example , a very simple language with a very simple semantics .The language consists of decimal digits and ASCII spaces .The semantics will treat it as a series of integers to be added .", "label": "", "metadata": {}, "score": "59.211266"}
{"text": "A unary rule consist of a left hand . side and a right hand side .Prefix and suffix composite rules have the same shape as binary rules .except that one part of the right hand side is an affix ( i.e. has an . associated string ) . @", "label": "", "metadata": {}, "score": "59.21724"}
{"text": "Once something is perfectly understood , style becomes irrelevant .Free variable injection is not yet perfectly understood . , but macro programming is , of course , not about style .It is about power .Sometimes free variable injection can create a symbiosis between two macros - one that can better programmatically construct expansions than can two isolated expansions .", "label": "", "metadata": {}, "score": "59.241844"}
{"text": "Remember that a lambda expression 9 Dlambda expands into lambda forms . is a constant value and is thus perfectly suitable for use in alet% .As with many macro enhancements , because of the many degrees of freedom available , improvements to this macro are counterintuitive .", "label": "", "metadata": {}, "score": "59.314716"}
{"text": "Similarly , the first symbol set for nonterminal Expr contains the symbol ' ( ' ( from rule r2 ) and all of the first symbols for nonterminal Factor as well ( from rule r1 ) .This gives the following set of terminal symbols : . '", "label": "", "metadata": {}, "score": "59.37493"}
{"text": "Marpa::R2::Vocabulary - Standard parsing terms as used within Marpa .Description .The definitions in this document are of standard parsing terms as they are used in the Marpa context .I put defining uses of terms in boldface , for easy skimming .", "label": "", "metadata": {}, "score": "59.42427"}
{"text": "Finally , I spend some word on non - hygienic macro systems versus hygienic systems .Breaking hygiene .In the previous episode I said that hygienic macros are good , since they solve the variable capture problem .However , purely hygienic macros introduce a problem of their own , since they make it impossible to introduce variables at all .", "label": "", "metadata": {}, "score": "59.514786"}
{"text": "Yes , there are many interesting things we can do with deliberate variable capture .There are a lot more phors .This book and Graham 's On Lisp describe a only a tiny fraction of the potential inherent to this technique .", "label": "", "metadata": {}, "score": "59.569534"}
{"text": "A standard way of describing rules is Backus - Naur Form , or BNF .A rule of a grammar is also often called a production .In one common way of writing BNF , a production looks like this : .", "label": "", "metadata": {}, "score": "59.57199"}
{"text": "Thus an LR(1 ) parser uses one symbol of look - ahead , which means that the parser keeps track of , or looks ahead at , one token read by the lexer at any point during a parse .An LR(2 ) parser uses two look - ahead symbols , and so forth for all useful values of k .", "label": "", "metadata": {}, "score": "59.57743"}
{"text": "Symbols .A grammar is composed of one or more symbols , which define the various words and punctuation allowed by the grammar .The symbols of a grammar come in two flavors : terminal symbols and nonterminal symbols .Terminal symbols are the primitive words and punctuation defined by the grammar .", "label": "", "metadata": {}, "score": "59.58281"}
{"text": "This section , although very lengthy , has still only scratched the surface of what is possible with pandoric macros and their many possible variations .I am looking forward to the many interesting future developments that will come out of them .", "label": "", "metadata": {}, "score": "59.604267"}
{"text": "A better way of thinking about pandoric variables are that they are simply an extension of the original lexical scope .As a simple example use of plambda , here is a pandoric counter that exports variables from two potentially different lexical environments : .", "label": "", "metadata": {}, "score": "59.667503"}
{"text": "Likewise , no closure items can be generated from items 8 , 9 , 11 , or 12 .Items 10 and 13 generate the following closure items , but they too are already present in the item set : .Factor , ' + ' ] .", "label": "", "metadata": {}, "score": "59.79505"}
{"text": "( m ) expand to 43 since in the lexical context where the macro is invoked x is bound to 43 .However , this behavior is quite surprising , and most likely not what it is wanted .This is actually another example of the free - symbol capture problem .", "label": "", "metadata": {}, "score": "59.84707"}
{"text": "only kernel and reduce items from set need to be . merged into gSet ; . else .all non - duplicate items from set need to be . merged into gSet ; .( optional ) set any shift / goto actions on symbol s . to the same gotos existing in gSet items ; .", "label": "", "metadata": {}, "score": "59.854164"}
{"text": "References to a sub - lexically scoped variable are only valid if the symbols representing them occur in the raw lists that were passed to lisp before macro - expansion .Because defmacro ! pre - processes the code it was given and creates the list of all the G - bang symbols before the code gets expanded , the G - bang symbols are sub - lexically bound .", "label": "", "metadata": {}, "score": "59.864395"}
{"text": "This was unavoidable because when we wrote those macros , closures were closed to us .With alet - hotpatch and let - hotpatch , we had to compile special purpose code into each closure that was capable of setting the this anaphoric lexical binding to its new value .", "label": "", "metadata": {}, "score": "59.87217"}
{"text": "The following is a closure whose construction shows a simple example use of alet% that avoids duplicating its reset and initialisation code : .Note that alet% changes the evaluation order of the forms in the let body .If you look at the expansion you will notice that the last form in the body is actually evaluated first , and its results are then bound to the lexical binding this before the preceding forms are evaluated .", "label": "", "metadata": {}, "score": "59.879448"}
{"text": "Reduction items are shown with their rule number : .+ ' num .The items that shift the same symbol are combined into a single parser table entry .Items 3 , 4 , and 5 all shift the same symbol ' + ' , thus producing the following parser action : . '", "label": "", "metadata": {}, "score": "59.910202"}
{"text": "\\R. . . . .Match anything but a return .\\s . . . . .Match any whitespace character .\\S. . . . .Match anything but whitespace .\\t . . . . .Match a tab .", "label": "", "metadata": {}, "score": "59.939304"}
{"text": "Scopes .The following pseudo - package names are reserved at the front of a name : . MY . . . . . .Symbols in the current lexical scope ( aka $ ?SCOPE ) OUR . . . . . .", "label": "", "metadata": {}, "score": "59.943336"}
{"text": "Each 16-bit Unicode code point represents a single grapheme or glyph .These are also called plains or plain consonants , and all are mid - class consonants .As in all languages , Thai vowels are spoken sounds ( or the graphemes that represent them ) which are characterized by an open configuration of the vocal apparatus .", "label": "", "metadata": {}, "score": "59.958687"}
{"text": "This is actually not true- defmacro ! provides these bindings under a slightly different type of scope called sub - lexical scope .Remember that scope means where references to a variable are valid and lexical scope means that the name is applicable to code in the textual body of a binding construct such as let .", "label": "", "metadata": {}, "score": "59.984856"}
{"text": "If no errors are found , all terms and atomic formulas are guaranteed to be well - formed .As a consequence , signatures are not part of the RIF - BLD language and term , atomic , and bi_atomic are not reserved keywords in RIF - BLD .", "label": "", "metadata": {}, "score": "59.998024"}
{"text": "This allows the pronunciation of Thai words to be written in an unambiguous way .Since the Thai spelling reflects pronunciation in a fairly regular way , often the phonemic Thai transcription will be similar to , or equivalent to , the correct Thai spelling of the word .", "label": "", "metadata": {}, "score": "60.051586"}
{"text": "The fields of an object - let 's say the fields of an instance of Point -are handled by read and write functions like Point - x or set - Point - y !It would be simpler to handle them directly by the name of their fields , x or y , for example , in the context of defining a method .", "label": "", "metadata": {}, "score": "60.12146"}
{"text": "Everything within the brackets is uppercase . \\v . . . .Match vertical whitespace .\\V . . . .Match anything but vertical whitespace .\\w . . . .Match a word character ( Unicode alphanumeric plus \" _ \") .", "label": "", "metadata": {}, "score": "60.12221"}
{"text": "Marpa can handle all recursive grammars , including grammars which are left - recursive , grammars which are right - recursive , and grammars which contain both left- and right - recursion .A cycle is a non - trivial derivation of a string of symbols from itself .", "label": "", "metadata": {}, "score": "60.12272"}
{"text": "X( book^^rif : local ( ?I ? X ( ?I ? X ( ?X ?X ?I ?X ?S ( ?X ?A Ruleset is a set of RIF rules .Rules are generated by the Implies production , with optional Forall -quantification .", "label": "", "metadata": {}, "score": "60.21113"}
{"text": "Picking up the action in phase 2 of the loop that pops i3 from the done list , this item set looks like this : . i3 .A new transition item set is generated from items 2 , 8 , and 9 : .", "label": "", "metadata": {}, "score": "60.215263"}
{"text": "( Factor , i8 ) .The new transition set i8 looks like this : . i8 .This new transition set gets put on the to - do list , and eventually is popped off the list in phase 1 of a subsequent iteration of the main loop .", "label": "", "metadata": {}, "score": "60.233246"}
{"text": "If the symbols in a symbol string are all terminals , that symbol string is also called a sentence .Derivations .A step of a derivation , or derivation step , is a change made to a symbol string by applying one of the productions from the grammar .", "label": "", "metadata": {}, "score": "60.26357"}
{"text": "Converting Reduction Actions .States with reduce actions are converted into states in a slightly different manner .Consider item set i2 that was generated above , which contains reduce actions : . i2 .When displaying this as a state , only the item cores are shown .", "label": "", "metadata": {}, "score": "60.39098"}
{"text": "The EBNF syntax is not a concrete syntax : it does not address the details of how constants and variables are represented , and it is not sufficiently precise about the delimiters and escape symbols .Instead , white space is informally used as a delimiter , and white space is implied in productions that use Kleene star .", "label": "", "metadata": {}, "score": "60.49704"}
{"text": "Expr ' + ' Factor .Factor num ( 42 ) .num ( 69 ) .Since a YACC - like parser employs a single stack for symbols , this implies that terminal symbols ( tokens ) and nonterminal ( LHS ) symbols must be represented by the same object type .", "label": "", "metadata": {}, "score": "60.514774"}
{"text": "Factor ' + ' num , ' ) ' ] ( - , - ) merged .Factor ' + ' num , ' + ' ] ( - , - ) .i8 .x12 .goto(Factor ) from i5 .", "label": "", "metadata": {}, "score": "60.558792"}
{"text": "Match anything but a form feed .\\n . . . .Match a ( logical ) newline .\\N . . . .Match anything but a ( logical ) newline .\\h . . . .Match horizontal whitespace .", "label": "", "metadata": {}, "score": "60.573936"}
{"text": "Because the only real reason for using alet - hotpatch is to create this sort of hotpatchable closure , we might forget that it also introduces the anaphor this into the scope of the forms provided .When we forget about anaphora we 've created , we risk unwanted variable capture problems .", "label": "", "metadata": {}, "score": "60.603237"}
{"text": "// Do a Goto transition on the nonterminal LHS symbol .end if ; . else .// No action was found for unexpected look - ahead symbol . invoke parser error handler ; .// Begin error recovery .push error symbol onto valueStack ; . look for a transition on ' error ' in the current state ; .", "label": "", "metadata": {}, "score": "60.6197"}
{"text": "Spelling .In this section are declared the two level spelling rules .A spelling rule consist of a kind indicator followed by a left context a focus and a right context .The contexts may be empty .The focus is surrounded by two \u00e2\u20ac\u02dc - \u00e2\u20ac \u2122 .", "label": "", "metadata": {}, "score": "60.626907"}
{"text": "The items shifting nonterminal symbols are shown next , since these comprise the goto transitions for the state .The resulting actions are therefore displayed as : . '( ' shift 3 num shift 4 ' + ' shift 5 Expr goto 1 Factor goto 2 .", "label": "", "metadata": {}, "score": "60.717014"}
{"text": "Luckily , modern lisp compilers are very good at optimising closures .If your application can stand a few pointer dereferences - and often it can - indirection chains might just be the best way to structure it .See section 7.4 , Pointer Scope for another interesting way to think about indirection chains .", "label": "", "metadata": {}, "score": "60.74813"}
{"text": "Marpa 's use of terminals is non - traditional , and its terminology is different accordingly .As in the traditional approach , Marpa 's non - terminals can never be used as terminals .But Marpa terminals can be used anywhere , even in places where the traditional approach requires a a non - terminal symbol .", "label": "", "metadata": {}, "score": "60.91594"}
{"text": "Junctive and . . . . .& also X .Named unary . . . . .sleep abs sin temp let N .^ ^. ^. ^ C .Chaining infix . . . . .!eqv X .", "label": "", "metadata": {}, "score": "60.940292"}
{"text": "This is applied to the example grammar rule shown above by adding a semantic action : .These operands are translated into method calls to retrieve values from the terminal and nonterminal parser stacks .The method returns a nonterminal value representing the result of the semantic action , which is assigned to $ $ .", "label": "", "metadata": {}, "score": "61.076492"}
{"text": "TV denotes the set of truth values that the semantic structure uses and DTS is the set of primitive data types used in I ( please refer to Section Primitive Data Types of RIF - FLD for the semantics of data types ) .", "label": "", "metadata": {}, "score": "61.235283"}
{"text": "label of current block $ ?LINE . . . . . . .Scopes .The following pseudo - package names are reserved at the front of a name : . MY . . . . . .Symbols in the current lexical scope ( aka $ ?", "label": "", "metadata": {}, "score": "61.239853"}
{"text": "Pop nonterminal X from the head of the queue ; .Step 3 .// Compute a partial first(X ) set for X .For rules with X as a LHS symbol , ' X : epsilon ' .( i.e. , rules for X with no RHS terminal symbols ) , . add epsilon to first(X ) ; .", "label": "", "metadata": {}, "score": "61.266186"}
{"text": "Symbol - macrolet , like its name implies , allows us to expand symbols into general lisp forms .Since it is intuitive and more flexible to use forms that look like function calls to represent macro transformations 20 Symbol macros take no arguments so a symbol macro definition always expands the same .", "label": "", "metadata": {}, "score": "61.286865"}
{"text": "When you turn a macro inside out you pick a typical form that uses a macro similar to the macro you would like to create , and expand it .You then use that expansion as a template for your desired macro .", "label": "", "metadata": {}, "score": "61.34353"}
{"text": "So plambda creates another anaphor- self .While the anaphor this refers to the actual closure that is to be invoked , self refers to the indirection environment that calls this closure .Although it sounds a bit peculiar , code inside our plambda can use self to pandorically access its own lexical environment instead of directly accessing it .", "label": "", "metadata": {}, "score": "61.352818"}
{"text": "For that reason , a grammar which contains a cycle is also called infinitely ambiguous .Marpa can parse with grammars which are not cycle - free , and will even parse inputs that cause cycles .When a parse is infinitely ambiguous , Marpa limits cycles to a single loop , so that only a finite number of parses is returned .", "label": "", "metadata": {}, "score": "61.366222"}
{"text": "t##s is a subclass term if t and s are arbitrary terms .Frame terms .Membership , subclass , and frame terms are used to describe objects in object - based logics like F - logic [ KLW95 ] .These terms can be readily mixed both with positional terms and terms with named arguments : p ( ?", "label": "", "metadata": {}, "score": "61.407936"}
{"text": "Alet% can be made to not return the last form in its body - which we anticipate to be a lambda form - but instead a function that looks up another function inside the let form 's lexical scope , then calls that function instead .", "label": "", "metadata": {}, "score": "61.424118"}
{"text": "// Process the next incomplete item set in the done list . if incList not empty , .// Generate new transition sets for all shift items in set .transitionLoop : . for each item in set , . if item.action not null , . skip item , continue transitionLoop ; .", "label": "", "metadata": {}, "score": "61.559414"}
{"text": "Package symbols declared in inherited classes .Object Types .Any scalar variable ( arrays and hashes are just collections of scalars ) can hold any type of data .Nevertheless Perl knows for many data types specific classes ( known as data types ) that can handle them .", "label": "", "metadata": {}, "score": "61.67991"}
{"text": "num t2 . '( ' t3 . ' ) ' t4 . 'This is a very simple example - real programming languages typically have a few dozen terminal symbols , including punctuation symbols and reserved keyword symbols .The Java language , for instance , has about twenty or so keywords , such as ' if ' , ' public ' , ' boolean ' , ' this ' , and so forth .", "label": "", "metadata": {}, "score": "61.712242"}
{"text": "First Sets .In order to construct item sets for a grammar , it is necessary to generate all of the closure items for a given set ( see below ) .The procedure for doing this requires knowing the first symbols for all of the nonterminal symbols in the grammar .", "label": "", "metadata": {}, "score": "61.752407"}
{"text": "A language where the pitch characteristic of each syllable provides a functional contrast .About one - half of the world 's languages are tonal .Tone in a language can be used either lexically or gramatically .Thai is a lexical tone language , which means that each word must be spoken with the proper tone for the word to be properly understood .", "label": "", "metadata": {}, "score": "61.799408"}
{"text": "If a symbol is not reachable , it is unreachable or inaccessible .A symbol is productive if it appears on the LHS of a productive rule , or if it is a nullable symbol .If a symbol is not productive , it is unproductive .", "label": "", "metadata": {}, "score": "61.805103"}
{"text": "Match anything but horizontal whitespace .\\L [ ... ] .Everything within the brackets is lowercase .\\Q [ ... ] .All metacharacters within the brackets match as literal characters .\\r . . . .Match a return .", "label": "", "metadata": {}, "score": "61.83147"}
{"text": "However , allowing the reduce to occur is allowable behavior because the symbols recognized by the parser up this point do in fact result in a valid reduction by the default rule .In the example , the current parser stack contains a Factor symbol ( because state 2 is entered by shifting a Factor symbol ) , which does indeed match LHS symbol Expr by rule 1 .", "label": "", "metadata": {}, "score": "61.934372"}
{"text": ": e . . .file exists : z . . .file has size equal to 0 ( an empty file ) .: s . . .file has size greater than 0 ( returns size in bytes ) .", "label": "", "metadata": {}, "score": "61.95043"}
{"text": "However , it should be kept in mind that RIF is designed to enable interoperability among rule languages in general , and its uses are not limited to the Web .RIF - BLD is defined in two different ways .First , it is defined as a specialization of RIF - FLD , the RIF Framework for Logic - based Dialects ; it is a very short description , but it requires familiarity with RIF - FLD .", "label": "", "metadata": {}, "score": "61.9809"}
{"text": "Lexical symbols in the unit 's DSL ( usually CORE ) PARENT . . .Symbols in this package 's parent package ( or lexical scope ) .The following is reserved at the beginning of method names in method calls : .", "label": "", "metadata": {}, "score": "61.996098"}
{"text": "\\F. . . . .Match anything but a form feed .\\n . . . . .Match a ( logical ) newline .\\N. . . . .Match anything but a ( logical ) newline .\\h . . . . .", "label": "", "metadata": {}, "score": "62.037804"}
{"text": "Constants and variables .Positional terms .Terms with named arguments .The term t here represents a predicate or a function ; s 1 , ... , s n represent argument names ; and v 1 , ... , v n represent argument values .", "label": "", "metadata": {}, "score": "62.04152"}
{"text": "Programmers provide their own implementation class for lexer token objects which implement this interface , or they can use the TokenAdapter class that is also provided with the YACC / M runtime library ( which provides basic functionality for implementing simple lexical token objects ) .", "label": "", "metadata": {}, "score": "62.101967"}
{"text": "Phase 2 now begins , which examines the first incomplete item set in the done list , which is the initial item set i0 that was just put into the list .Transition item sets are now generated for all of the shift items in the set .", "label": "", "metadata": {}, "score": "62.138264"}
{"text": "However , p ( ) can be an atomic formula .Signatures permit only constant symbols to occur in the context of function or predicate names .Therefore , if t is a ( non-Const ) term then t ( ... ) is not a well - formed term .", "label": "", "metadata": {}, "score": "62.168915"}
{"text": "When we ca n't factor common code in an expression the usual way , sometimes we can gain this brevity advantage by using syntactic duals in other ways .The definition of sublet uses the self - referential read macros described in section 4.5 , Cyclic Expressions .", "label": "", "metadata": {}, "score": "62.480007"}
{"text": "& who : eval 3 .& message : \" unbound variable \" 4 .& irritants : ( a ) .Why is the variable a not bound to 1 ?The problem is that hygienic macros never introduce identifiers implicitly .", "label": "", "metadata": {}, "score": "62.63129"}
{"text": "Section [ : FLD / Semantics#sec - rif - dialect - semantics : Semantics of a RIF Dialect as a Specialization of RIF - FLD ] in that document lists the parameters of the semantic framework , which we need to specialize for RIF - BLD .", "label": "", "metadata": {}, "score": "62.66553"}
{"text": "This means that in practice only the core of item 1 is actually displayed : .Expr .The items that shift the same symbol are combined into a single parser table entry .Item 1 shifts symbol Expr , items 2 , 8 , and 9 shift Factor , item 3 shifts ' ( ' , items 4 and 5 shift num , and items 6 and 7 shift ' + ' .", "label": "", "metadata": {}, "score": "62.73458"}
{"text": "Another way to think about sharp - backquote is that it is to list interpolation as the format function is to string interpolation .Just as format lets us use a template with slots that are to be filled with the values of separate arguments , sharp - backquote lets us separate the structure of the list interpolation from the values we want to splice in .", "label": "", "metadata": {}, "score": "62.85018"}
{"text": "Item 1 shifts symbol Expr , so a new transition item set i1 is created .All of the items in set i0 that shift symbol Expr are marked , which in this case is just item 1 .New kernel items are generated in the new transition set : . i1 .", "label": "", "metadata": {}, "score": "62.885994"}
{"text": "That is , a type of consonant cluster where /a/ is pronounced between the two consonants .This inserted vowel is called an anaptyxix or svarabhakti .The process of insertion is called epenthesis , and because the insertion occurs within the cluster , the cluster itself is called en epenthetic .", "label": "", "metadata": {}, "score": "62.913948"}
{"text": "Of course if we wanted to refer to this for some reason other than hotpatching , we should have left the anaphor open .This technique of opening and closing anaphora becomes second nature after you have written enough of such macros .", "label": "", "metadata": {}, "score": "62.95752"}
{"text": "This is why this situation is called a shift / reduce conflict - because either action is possible , thus causing a conflict .Without any way of resolving the conflict , the parser can not decide whether to shift the ELSE symbol and proceed to state 38 , or to reduce by rule 24 when it sees the ELSE look - ahead symbol .", "label": "", "metadata": {}, "score": "62.997135"}
{"text": ": t . . .filehandle is opened to a tty .: u . . .file has setuid bit set .: g . . .file has setgid bit set .: k . . .file has sticky bit set .", "label": "", "metadata": {}, "score": "63.103783"}
{"text": "Items marked with an R are redundant , and can be removed from the item set without affecting subsequent merge operations .The resulting set after redundant item elimination look like this : .Example XX ? -Redundant Items Eliminated .", "label": "", "metadata": {}, "score": "63.172764"}
{"text": "right : .ANY ?COLON : .CONTEXTBOUNDARY - .DOLLAR $ .LBRA ] .MORPHEMEBOUNDARY + .NOTEQUAL !RBRA [ .SLASH / .ALPHABETS @Alphabets .ATTRIBUTES @Attributes .CLASSES @Classes .GRAMMAR @Grammar .LEXICON @Lexicon .", "label": "", "metadata": {}, "score": "63.180367"}
{"text": "Universals : If \u03c6 is a rule and ?V 1 , ... , ?V n are variables then Forall ?V 1 ... ?V n ( \u03c6 ) is a formula , called an explicitly quantified rule .So far , the syntax of RIF - BLD was specified in Mathematical English .", "label": "", "metadata": {}, "score": "63.258102"}
{"text": "Nevertheless , there are attested rules of this sort , such as the first of two reduplicated verbs receiving the high tone ( Setthapun 1992 ) .Dialect and ideolect account for further variation from canonical tone pronunciation .In the thai - language . com enhanced phonemic transcription scheme used by this website , the tone with which a Thai word must be spoken is indicated by a superscripted capital letter which appears after the phonemic portion of each transcribed syllable .", "label": "", "metadata": {}, "score": "63.393288"}
{"text": "& & X .Conditional . . . . . . . ? ? ff fff R .Loose unary . . . . . .true not X .List infix . . . . . . . . .List prefix . . . . . . . .", "label": "", "metadata": {}, "score": "63.40097"}
{"text": "Positional information is optionally exploited only for the arg role elements .For example , role elements ( declare and formula ) are explicit within the Exists element .Following the examples of Java and RDF , we use capitalized names for class elements and names that start with lowercase for role elements .", "label": "", "metadata": {}, "score": "63.43864"}
{"text": "When we close an anaphor , we do n't need to change the way our anaphoric macros function , just restrict them in the ways they can be combined .Because we have turned the alet expansion inside out , we can lexically see the creation of the this anaphor in the definition of alet - hotpatch .", "label": "", "metadata": {}, "score": "63.47004"}
{"text": "// based on the current state and look - ahead symbol .if action is SHIFT , .// Shift the current look - ahead terminal symbol .push laSym onto parser termStack ; . push state 0 onto stateStack ; .", "label": "", "metadata": {}, "score": "63.487595"}
{"text": "Alet - hotpatch is a version of alet - hotpatch% that takes advantage of dlambda .Sometimes without even realising it , by using macros we wrote previously in the definition of new macros , we are performing macro combination .With well designed macros the expansion can be fully understood and , although it might violate lexical transparency in many ways , no combination problems emerge because all components fit together meaningfully .", "label": "", "metadata": {}, "score": "63.566322"}
{"text": "YACC / M also allows the programmer to specify a class type for the nonterminal stack , which is implemented as an array of objects of the type specified by the % stacktype directive .If this directive is not given , the default type is simply Object .", "label": "", "metadata": {}, "score": "63.571243"}
{"text": "With pandoric functions , it is everything .Furthermore , with pandoric functions the order of the arguments does n't matter and you can elect to use as few or as many of the exported lexical variables as you please .Defpan also provides an anaphor called self that allows us to perform a useful technique called anaphor chaining .", "label": "", "metadata": {}, "score": "63.667545"}
{"text": "low level data types .This is more low level than the last table .These types are more meant to give the compiler optimizing hints .Operators .Table of precedence .A .Level . . . . . . . . . . . .", "label": "", "metadata": {}, "score": "63.703022"}
{"text": "A minimal set is used to demonstrate that the phonological element under consideration is phonemic -that is , that it has contrastive function in determining meaning .A written syllable .The name of the Thai orthographic symbol , a dot , which is placed underneath a consonant which has no associated vowel sound .", "label": "", "metadata": {}, "score": "63.760136"}
{"text": "Alet - fsm gives us a convenient syntax for expressing multiple possible states for our closure to exist in .As an example , here is a cleaner version of our invertible counter : .Alet - fsm is an instance of a technique we have n't seen before : anaphor injection .", "label": "", "metadata": {}, "score": "63.77014"}
{"text": "Remember when we wrote pandoriclet and decided to move the creation of case statements for the getter code to the function pandoriclet - get and the setter code to pandoriclet - get ?Plambda makes use of these same functions .Even though these macros splice the results from these functions into fairly different lexical contexts , since both macros have been written to use the same variable naming convention and inter - closure protocol , the code is re - usable .", "label": "", "metadata": {}, "score": "63.840263"}
{"text": "The hygiene problem is more serious in Lisp-1 dialects like the newborns Arc and Clojure .Arc macros behave just like define - macro and are fully unhygienic , whereas Clojure macros are rather special , being nearly hygienic .In particular Clojure macros are not affected by the free - symbol capture problem : .", "label": "", "metadata": {}, "score": "63.91375"}
{"text": "// Move the new ( still incomplete ) set to the incomplete list . if set not null ( was not merged or a duplicate ) , . append set to end of doneList ; [ Note I ] . if incList is empty , . end if ; . end phase1 ; .", "label": "", "metadata": {}, "score": "63.948387"}
{"text": "Deterministic Finite Automata ( DFA ) Parsers .It was mentioned above that a parser for a grammar can be implemented as a deterministic finite automaton ( DFA ) .An automaton is simply a machine embodying a set of states and which reads input symbols and acts on them .", "label": "", "metadata": {}, "score": "64.03592"}
{"text": "// Phase 1 .// Process item sets on the to - do list , merging them with existing .// sets or moving them to the incomplete list . phase1 : . while toDoList not empty , .generate all closure items for set ; [ Note A ] .", "label": "", "metadata": {}, "score": "64.070625"}
{"text": "The parse proceeds as follows , showing each step in the parsing process : .( Note that $ end is a special symbol denoting the end of the input stream . )These parsing steps and production rules trace out the following derivation tree ( also called a parse tree ): .", "label": "", "metadata": {}, "score": "64.1104"}
{"text": "Match anything but a tab .\\U [ ... ] .Everything within the brackets is uppercase . \\v . . . . .Match vertical whitespace .\\V. . . . .Match anything but vertical whitespace .\\w . . . . .", "label": "", "metadata": {}, "score": "64.24527"}
{"text": "Noun .LEXICALSTRING . is a string of lexical symbols .SURFACESTRING . is a string of surface symbols .SYMBOLSTRING . is a string of just just one character ( used only in alphabet . declaration ) .A string consist of zero or more characters within double quotes ( \u00e2\u20ac\u02dc \" \u00e2\u20ac \u2122 ) .", "label": "", "metadata": {}, "score": "64.25464"}
{"text": ": R . . .file is readable by real uid / gid .: W . . .file is writeable by real uid / gid .:X . . .file is executable by real uid / gid . :O . . .", "label": "", "metadata": {}, "score": "64.25786"}
{"text": "Lazy Perl list ( composed of immutables and iterators ) Seq . . . . .Completely evaluated ( hence immutable ) sequence Range . . . .A pair of Ordered endpoints ; generates immutables when iterated Set . . . . .", "label": "", "metadata": {}, "score": "64.26624"}
{"text": "first(X ) is complete .( and nonterminal X is no longer in the queue ) ; . end loop ; . end .Note that this algorithm works even with nonterminals having mutually recursive first symbol sets .Factor ' + ' num , ' + ' ] .", "label": "", "metadata": {}, "score": "64.301186"}
{"text": "Graham 's anaphora and associated code are worth careful study .Especially see the defanaph macro [ ON - LISP - P223 ] which enables some interesting types of automatic anaphor programming .After some period of use , alambda has been found to be the most useful of the anaphoric macros in On Lisp .", "label": "", "metadata": {}, "score": "64.34341"}
{"text": "Style aside , free variable injection is sometimes just what we need when we want two related macros to communicate back and forth .Injection is really the same operation as that performed by anaphora , just in the opposite direction .", "label": "", "metadata": {}, "score": "64.34392"}
{"text": "RIF - BLD supports all the symbol spaces defined in Section Symbol Spaces of the syntactic framework : .Variables are written as Unicode strings preceded with the symbol \" ? \" The syntax for constant symbols is given in Section Symbol Spaces of RIF - FLD .", "label": "", "metadata": {}, "score": "64.397316"}
{"text": "( Factor , i8 )M : x11 .Factor ' + ' num , ' + ' ]( Factor , i8 ) .i6 .goto('+ ' ) , from i2,i8 . i7 .goto(Expr ) , from i3 . x8 .", "label": "", "metadata": {}, "score": "64.428116"}
{"text": "Another common task is checking for the validity of closure data after an invocation of the closure .Ichain - intercept% is another macro designed to be used inside an alet form .The idea is that we would like to be able to intercept invocations of the closure and verify that the actions they performed did n't cause some sort of inconsistent state in the closure .", "label": "", "metadata": {}, "score": "64.452774"}
{"text": "So this closure we 've created with pandoriclet is actually no longer closed .The environment used by this closure - even when all lexical variable symbols have been removed by the compiler - is still accessible through our anonymous function returned from pandoriclet .", "label": "", "metadata": {}, "score": "64.511635"}
{"text": "Although we provide arguments to defpan using the same syntax as in lambda forms - a list of symbols - the arguments to defpan mean something different .Instead of creating a new lexical environment , these pandoric functions extend the lexical environment of the pandoric closures they are applied to .", "label": "", "metadata": {}, "score": "64.53743"}
{"text": "Assume , for example , that the parser enters state 2 above with a look - ahead symbol of ' ( ' .The parser will not find a shift action for symbol ' ( ' , so it selects the default action , which is to reduce by rule 1 .", "label": "", "metadata": {}, "score": "64.54886"}
{"text": "Closure items are generated for a given set initially from the kernel items , and then from any newly generated closure items themselves , repeatedly until no more ( non - duplicate ) closure items can be added to the item set .", "label": "", "metadata": {}, "score": "64.5573"}
{"text": "hyper . . . . . .reverses the order of the operands Xop . . .combinator .Contextualizers .Infix operator that forcing a context .$ . . .scalar context @. . .array context ( flat array ) @@ . slice c. , array that may contain arrayref % . . .", "label": "", "metadata": {}, "score": "64.57003"}
{"text": "That is , can you use pandoric - eval to evaluate a form that evaluates pandoric - eval ?Why or why not ?Exercise : Although the implementation of pandoric macros here is fairly efficient , it could be improved .", "label": "", "metadata": {}, "score": "64.57292"}
{"text": "Indirection is a concept ubiquitous throughout programming languages for good reason .It lets us change things at run - time that , without indirection , are fixed at compile - time .Lisp lets us use indirection in a more succinct and efficient manner than many other programming languages .", "label": "", "metadata": {}, "score": "64.60129"}
{"text": "Bottom - Up Parsing .The theory behind bottom - up LR(k ) parsers , also called shift - reduce parsers , was invented in 1965 by Donald Knuth ( author of the famed The Art of Programming books ) .He devised the formal symbolic mathematics behind the operation of a deterministic finite automaton , or DFA , operating as a parsing machine that reads lexical symbols from a source sentence provided as its input , and proceeds to recognize productions comprising a particular grammar .", "label": "", "metadata": {}, "score": "64.73942"}
{"text": "For instance , along with this , the macro ichain - before also injects symbols like let , setq , and lambda to be spliced into wherever the macro is expanded .The difference between symbols like this and pre - defined symbols like setq is that while lambda always refers to a single well - understood ANSI macro , symbols like this can refer to different things depending on the environments in which they are expanded .", "label": "", "metadata": {}, "score": "64.85974"}
{"text": "This macro is designed to create sub - lexical bindings for code using a syntax similar to the usual let form syntax .The discussion of sublet , as with many lisp macros , begins with a utility .Sublet also uses the tree - leaves utility we defined in section 5.3 , Implicit Contexts .", "label": "", "metadata": {}, "score": "64.92047"}
{"text": "The symbol on the left - hand side of a rule ( to the left of the ' : ' mark ) is called the left - hand side or LHS symbol .Similarly , the symbols that appear on the right - hand side of the rule ( to the right of the ' : ' mark ) are called the right - hand or RHS symbols .", "label": "", "metadata": {}, "score": "64.9355"}
{"text": "+ MOVE Note that multiple rules having the same LHS symbol can be combined into a single definition , but this is not required .The first two production rules could just have easily been defined like this : . which is equivalent to defining two separate rules : .", "label": "", "metadata": {}, "score": "65.05101"}
{"text": "So , remembering the lexical context , we write pandoriclet - get and pandoriclet - set .For pandoriclet - get , we remember that dlambda has bound a variable sym around where our list will be spliced in .We use sym in a case form that compares it to the symbols that were passed to pandoriclet 19 Recall that case with symbols compiles to a single pointer comparison per case .", "label": "", "metadata": {}, "score": "65.10976"}
{"text": "x10 i4 ) .num , ' + ' ] ( num , .x10 i4 ) .+ ' Factor , ' ) ' ] ( ' + ' , .x11 i5 ) .+ ' Factor , ' + ' ] ( ' + ' , .", "label": "", "metadata": {}, "score": "65.11164"}
{"text": "i0 .Factor ' + ' num , ' + ' ]( Factor , i2 ) i1 .Factor , ' ) ' ]( Factor , . x8 i2 ) .( ' Expr ' ) ' , ' ) ' ] ( ' ( ' , . x9 i3 ) .", "label": "", "metadata": {}, "score": "65.23939"}
{"text": "Although most anaphora are introduced by regular macros , read macros also have the potential to introduce code that invisibly creates bindings for us .When read macros do so , they are called read anaphora .This section presents one such read macro that , while itself very modest , surprised even myself by turning out to be one of the most consistently useful throughout this book .", "label": "", "metadata": {}, "score": "65.323746"}
{"text": "Like let - hotpatch does , this technique can use defmacro ! to move the anaphor 's scope from the macro expansion to the macro definition .Instead of lexically introducing an anaphor , we introduced another type of anaphor - one that does n't take effect in the full lexical scope of the expansion but only in another , more limited scope .", "label": "", "metadata": {}, "score": "65.527725"}
{"text": "object of meta class : \" Higher Order Workings \" WHEN . . .( reserved for events ? )WHY . . . .( reserved for documentation ? )WHENCE . autovivification of closures .Operators .Table of precedence .", "label": "", "metadata": {}, "score": "65.560326"}
{"text": "Such a rule is called degenerate , and is considered erroneous .It is also possible for rules to be specified that have no RHS symbols at all .These are called empty ( or epsilon ) productions .For example : . r10 .", "label": "", "metadata": {}, "score": "65.65224"}
{"text": "Symbols in the outermost lexical scope of compilation unit SETTING .Lexical symbols in the unit 's DSL ( usually CORE ) PARENT .Symbols in this package 's parent package ( or lexical scope ) .The following is reserved at the beginning of method names in method calls : .", "label": "", "metadata": {}, "score": "65.78119"}
{"text": "+ ' num , ' + ' ] ( ' + ' , . i9 i6 ) .+ ' num , ' ) ' ] ( ' + ' , . i9 i6 ) .num , ' + ' ] .", "label": "", "metadata": {}, "score": "65.781395"}
{"text": "Queinnec remarks that when defining a method for a MEROONET class it would be nice to be able to directly refer to the fields of the object being defined instead of using accessors .In Queinnec 's ( translated ) words [ SMALL - PIECES - P340 - 341 ] : .", "label": "", "metadata": {}, "score": "65.85014"}
{"text": "The idea behind pandoriclet is to open closures , allowing their otherwise closed - over lexical variables to be accessed externally .As with some of our previous macros like alet - hotpatch , pandoriclet compiles an indirection environment that chooses different run - time behaviours depending on the arguments passed .", "label": "", "metadata": {}, "score": "65.88521"}
{"text": "It is used to define truth valuation of formulas .We also define the following mapping I : .I ( ?v ) , if ?v is a variable in Var .The effect of data types .The data types in DTS impose the following restrictions .", "label": "", "metadata": {}, "score": "65.94313"}
{"text": "Package symbols declared in inherited classes .low level data types .This is more low level than the last table .These types are more meant to give the compiler optimizing hints .int1 .int2 .int4 .int8 .", "label": "", "metadata": {}, "score": "65.99841"}
{"text": "A comment starts with a semicolon and finishes at the next newline .( except when the semicolon occurs in a string .Inclusion of files can be specified with the usual \u00e2\u20ac\u02dc # include \u00e2\u20ac \u2122 .directive : .Example : # include \" verb.entries \" .", "label": "", "metadata": {}, "score": "66.129776"}
{"text": "The classic anaphora like those in On Lisp are named after the literal words 1 A U - language quotation .anaphor and its plural , anaphora .An anaphor is a means of capturing a free U - language word for use in subsequent U - language .", "label": "", "metadata": {}, "score": "66.18202"}
{"text": "By implementing this duality of syntax we cut in half the number of accessors / setters we need to memorise and , most importantly , enable new ways for us to use macros .The function get - pandoric is a wrapper around the inter - closure protocol getter syntax .", "label": "", "metadata": {}, "score": "66.18373"}
{"text": "Symbols that have a name longer than one . character are represented using a SGML entity like notation : . \u00e2\u20ac\u02dc & symbolname ; \u00e2\u20ac \u2122 .The maximum number of symbols in a string is 127 .Tokens can be separated by one or many blanks or comments .", "label": "", "metadata": {}, "score": "66.25158"}
{"text": "Since in such lexical context the built - in car is not defined , the expansion fails : .& undefined 2 .& who : eval 3 .& message : \" unbound variable \" 4 .& irritants : ( car ) .", "label": "", "metadata": {}, "score": "66.261665"}
{"text": "num , ' ( ' ] ( num , - ) R .+ ' Factor , num ] ( ' + ' , - ) .+ ' Factor , ' + ' ] ( ' + ' , - ) R .", "label": "", "metadata": {}, "score": "66.316055"}
{"text": "A consonant sound which is accompanied by a burst of air , so it \" can blow out a match .\"In the Thai tone rules , all high - class consonants are either aspirates or fricatives .Adjectives in Thai can grammatically function in two different ways .", "label": "", "metadata": {}, "score": "66.32734"}
{"text": "Closure Traits .Every block can contain special named blocks ( some are only for loops ) that are started at certain times .They are traits ( compile time property ) of a block object and can modify behaviour of that block .", "label": "", "metadata": {}, "score": "66.439316"}
{"text": "In phase 1 of the main loop , the first item set is popped off the front of the to - do list , which is the initial item set i0 just created .Closure items are then generated for the set .", "label": "", "metadata": {}, "score": "66.62259"}
{"text": "Like many programming books , Lisp in Small Pieces takes us to and leaves us at an implementation of a system for object - oriented programming .Usually these implementations serve to outline a subset of CLOS , the C OMMON L ISP Object System .", "label": "", "metadata": {}, "score": "66.66215"}
{"text": "Each positional predicate and function symbol has precisely one arity , which is a non - negative integer that tells how many arguments the symbol can take .Each predicate or function symbol with named arguments has precisely one arity ( for terms with named arguments ) .", "label": "", "metadata": {}, "score": "66.81713"}
{"text": "Tone is orthographically marked in Thai ( it is possible to determine the tone of a syllable from its Thai orthography ) .[ Compare to grammatical tone . ]A word from a foreign language which is borrowed into the native language , for example , English words which are adopted into Thai , with their own approximate Thai spellings .", "label": "", "metadata": {}, "score": "66.842575"}
{"text": "To .overcome this restriction , in a future version this section will be .split into two : declaration of value sets and declaration of . attributes . @Types .In this section , the different types of feature structures are declared .", "label": "", "metadata": {}, "score": "66.91319"}
{"text": "( first(P ) may still be incomplete at this point . )Step 6 .For all rules with X as LHS symbol , of the form ' X : P B ... ' , . if first(P ) contains epsilon , . repeat steps ( 3 ) through ( 6 ) with nonterminal B .", "label": "", "metadata": {}, "score": "66.924416"}
{"text": "In the example , Expression is the left hand side , and Term and Factor are right hand side symbols .Left hand side and right hand side are often abbreviated as RHS and LHS .If the RHS of a production has no symbols , the production is called an empty production or an empty rule .", "label": "", "metadata": {}, "score": "66.95982"}
{"text": "The document RIF Use Cases and Requirements includes a use case \" Negotiating eBusiness Contracts Across Rule Platforms \" , which discusses a business rule slightly modified here : .The prefix op is used for a yet - to - be - determined IRI , which will be used for RIF builtin predicates .", "label": "", "metadata": {}, "score": "66.99893"}
{"text": "One of the classes of consonants in Thai ( along with low- and high- ) , used in the tone rules to determine the lexical tone of a syllable .Syllables that begin with a mid - class consonant are pronounced with a middle tone in live syllables with no tone marker .", "label": "", "metadata": {}, "score": "67.03245"}
{"text": "Expr : Factor r2 .Expr : ' ( ' Expr ' ) ' r3 .Factor : num r4 .Factor : ' + ' Factor r5 .Factor :Factor ' + ' num .These rules specify , for instance , the sequence of symbols that constitute an Expr , which is either a Factor or another Expr enclosed within ' ( ' and ' ) ' symbols .", "label": "", "metadata": {}, "score": "67.06155"}
{"text": "By default , Marpa uses the token stream model of input .Marpa also allows alternative input models .These are new to Marpa , so that their terminology is of necessity non - standard .The terminology needed for alternative input models is explained in the document that introduces them .", "label": "", "metadata": {}, "score": "67.16853"}
{"text": "routine that is executed at BEGIN ( ASAP , compile time ) and returns an AST .Routine Modifier .Routine Traits . rw . . . . . .read / write ro . . . . . . .readonly copy . . . .", "label": "", "metadata": {}, "score": "67.41374"}
{"text": "A derivation is a sequence of derivation steps .The length of a derivation is its length in steps .We say that a first symbol string directly derives a second symbol string if and only if there is a derivation of length 1 from the first symbol string to the second symbol string .", "label": "", "metadata": {}, "score": "67.43688"}
{"text": "[] .^ .: N .Autoincrement . . . .+ + -- R .Symbolic unary . . . . !^ ^ L .& div mod L .^ L .Replication . . . . . . .", "label": "", "metadata": {}, "score": "67.47426"}
{"text": "The ichain - after macro is similar to the ichain - before macro except it adds the closures to the other end of the execution chain : after the main closure has been invoked .Ichain - after uses prog1 , which executes its provided forms consecutively and then returns the result of evaluating the first form .", "label": "", "metadata": {}, "score": "67.52993"}
{"text": "With pandoric macros , additional code is compiled in to provide a way to access the closure from outside .But the power of pandoric macros ca n't be seen by looking at this low - level view of what is happening .", "label": "", "metadata": {}, "score": "67.54088"}
{"text": "These characters comprise the following Java lexical tokens : . if reserved keyword .( punctuation operator .ch identifier . a ' character constant . ) punctuation operator .return reserved keyword .- - - punctuation operator .1 integer constant .", "label": "", "metadata": {}, "score": "67.56369"}
{"text": "We have now looked at most of the pieces that make up pandoric macros .First , a macro for creating closures : pandoriclet , which captures an anaphor , this , referring to the actual function used when invoking the closure .", "label": "", "metadata": {}, "score": "67.64275"}
{"text": "begin // Initialize .// Main parsing loop .mainLoop : . while stateStack not empty , .// Insure that there is a look - ahead symbol .if laSym is null , .( which is $ end on end of input ) ; .", "label": "", "metadata": {}, "score": "67.66011"}
{"text": "One of the classes of consonants in Thai ( along with mid- and high- ) , used in the tone rules to determine the lexical tone of a syllable .Syllables that begin with a low - class consonant are pronounced with a middle tone in live syllables with no tone marker .", "label": "", "metadata": {}, "score": "67.770676"}
{"text": "( There also exist non - deterministic automatons ( NFAs ) , which are different in that they may have transitions from one state to another without regard to the current input symbol , called epsilon transitions .These kinds of state machines are not discussed here . )", "label": "", "metadata": {}, "score": "67.911476"}
{"text": "+ ' Factor , ' ) ' ] ( ' + ' , .x14 i5 )M : x11 .+ ' Factor , ' + ' ] ( ' + ' , .x14 i5 ) .Factor ' + ' num , $ end ] ( Factor , i8 ) .", "label": "", "metadata": {}, "score": "67.912994"}
{"text": "For all rules with X as LHS symbol , of the form ' X : P B ... ' .with nonterminal symbol P as the leftmost RHS symbol , . and where P is not X , . add to first(X ) all terminal symbols other than epsilon .", "label": "", "metadata": {}, "score": "68.123215"}
{"text": "file has setuid bit set .: g . . .file has setgid bit set .: k . . .file has sticky bit set .: T . . .file is an ASCII text file ( heuristic guess ) .", "label": "", "metadata": {}, "score": "68.297455"}
{"text": "+ MOVE THIS PARA .When a reduce occurs , a reduction action can be performed for the rule as well .Such an action is usually a small block of code executed by the parser just before the RHS symbols are replaced by the LHS symbol .", "label": "", "metadata": {}, "score": "68.52323"}
{"text": "For example , here is how the Perl docs describe one of the forms that Perl 's use statement takes : . use Module VERSION LIST . and in Perl 's source code ( perly.y ) something similar drives the parser .", "label": "", "metadata": {}, "score": "68.563934"}
{"text": "x11 .num , ' ) ' ] ( - , - ) merged .num , ' + ' ] ( - , - ) .+ ' Factor , ' ) ' ] ( - , - ) merged .", "label": "", "metadata": {}, "score": "68.57632"}
{"text": "Simple terms ( constants and variables ) are not formulas .Not all atomic formulas are well - formed -- see Section Well - formedness .A well - formed atomic formula is an atomic formula that is also a well - formed term .", "label": "", "metadata": {}, "score": "68.605545"}
{"text": "Consider sitting in a house full of fragile glass .You can safely throw objects to people outside the house , even if they do n't bother catching them , but you had better make sure you catch any objects thrown back at you .", "label": "", "metadata": {}, "score": "68.66677"}
{"text": "The following pseudo - code is the Honalee Algorithm for constructing item sets for an LR(k ) grammar .// The Honalee Algorithm - LR(k ) Item Set Construction ( summarized ) .create initial item set i0 ; . append i0 to end of toDoList ; .", "label": "", "metadata": {}, "score": "68.69101"}
{"text": "Changing a sharp quoted lambda form to an alambda form also requires deleting two characters .Because of alambda 's transparent specification for the self binding - and the fact that the only reason to ever use alambda is to make use of this binding - unwanted variable capture is never a problem .", "label": "", "metadata": {}, "score": "68.7455"}
{"text": "Note that a term like f ( ) is both positional and with named arguments .Equality terms .Class membership terms ( or just membership terms ) .t#s is a membership term if t and s are arbitrary terms .", "label": "", "metadata": {}, "score": "68.85819"}
{"text": "Ichain - before is intended to be expanded in an alet form .It adds a new body of code to be executed before invoking the main closure .Going back to our counter example , ichain - before lets us add a new closure that prints out the previous value of the closed - over acc variable before it goes ahead and increments it : .", "label": "", "metadata": {}, "score": "68.93542"}
{"text": "For example , consider the following rule : .Expr : Expr ' + ' Factor .When reduced by the parser , the semantic action associated with this rule can create a parse tree to embody the expression , such as : .", "label": "", "metadata": {}, "score": "68.9588"}
{"text": "b. Universal - existential form : Forall ? item ( reject^^rif : local(ppl#John^^rif : iri ? item ) : - Exists ? deliverydate ? scheduledate ? diffduration ? diffdays ( And(perishable^^rif : local ( ? item ) delivered^^rif : local ( ? item ? deliverydate ppl : John^^rif : iri ) scheduled^^rif : local ( ? item ? scheduledate ) fn : subtract - dateTimes - yielding - dayTimeDuration ( ? deliverydate ? scheduledate ? diffduration ) fn : get - days - from - dayTimeDuration ( ? diffduration ? diffdays ) op : numeric - greater - than ( ? diffdays 10 ) ) ) ) .", "label": "", "metadata": {}, "score": "68.9784"}
{"text": "ROUTINE . . . .current subs or methods & ?BLOCK . . . . . .reference to current block $ ?LABEL . . . . . . .label of current block $ ?LINE . . . . . . . .", "label": "", "metadata": {}, "score": "68.98767"}
{"text": "They may be ( non - kernel ) closure items generated from the kernel items in the set if they are epsilon productions , i.e. , if they have no RHS symbols .( A closure item has its marker positioned to the left of all of its RHS symbols , and if it has no RHS symbols , it will therefore be a reduction item . )", "label": "", "metadata": {}, "score": "69.08937"}
{"text": "( aka num on most architectures ) num128 .complex32 .complex64 .( aka complex on most architectures ) complex128 .Str . . . .Object Types .Any scalar variable ( arrays and hashes are just collections of scalars ) can hold any type of data .", "label": "", "metadata": {}, "score": "69.20389"}
{"text": "Hotpatching Closures .There are three purposes for this important section .First , another interesting use of the this anaphor from alet is described .Second , the pattern alet over dlambda is discussed .Finally , a useful macro technique called anaphor closing is introduced .", "label": "", "metadata": {}, "score": "69.235825"}
{"text": "Making a closure pandoric is as easy as adding a p character before the lambda and adding a list of variables to export after the lambda arguments .We can the open this closure - and any pandoric closure that exports the symbols a and b -by using with - pandoric like so : .", "label": "", "metadata": {}, "score": "69.26561"}
{"text": "For a given grammar , an augmented grammar is created from the goal symbol , which is made by adding a single new rule to the grammar : .$ accept : Goal .This rule defines a special nonterminal symbol $ accept to represent the entire grammar .", "label": "", "metadata": {}, "score": "69.35158"}
{"text": "Bit . . . . . .Perl single bit ( allows traits , aliasing , undef , etc . )Int . . . . . .Perl integer ( allows Inf / NaN , arbitrary precision , etc . )", "label": "", "metadata": {}, "score": "69.394516"}
{"text": "For all rules with X as LHS symbols , of the form ' X : t B ... ' , .with terminal symbol t as the leftmost RHS symbol .( where t is not epsilon ) , . add symbol t to first(X ) ; .", "label": "", "metadata": {}, "score": "69.49489"}
{"text": "We can even use pandoric - hotpatch on a pandoric closure we created before we knew we wanted it to be hotpatchable .Remember the counter closure we have been playing with throughout this section ?It should still be bound to the symbol - function of the symbol pantest .", "label": "", "metadata": {}, "score": "69.65282"}
{"text": "All four tone marks may appear , and they indicate the low , falling , high , or rising tones .One of five lexical tones used in Thai ( along with low , high , rising , and falling ) .", "label": "", "metadata": {}, "score": "69.6815"}
{"text": "Match anything but a return .\\s . . . .Match any whitespace character .\\S . . . .Match anything but whitespace .\\t . . . .Match a tab .\\T . . . .Match anything but a tab .", "label": "", "metadata": {}, "score": "69.687096"}
{"text": "How do we normally avoid introducing unwanted bindings ?We name the bindings using gensyms of course .( defmacro !Let - hotpatch is an example of closing the this anaphor into a more contained version - a safer version for when hotpatching is all that is required .", "label": "", "metadata": {}, "score": "69.69453"}
{"text": "A . . .Same for access time .: C . . .Same for inode change time ( Unix , may differ for other platforms ) .Regex primitives .\\0 [ ... ] .Match a character given in octal ( brackets optional ) .", "label": "", "metadata": {}, "score": "69.727615"}
{"text": "An vowel which is invoked in a syllable with no written vowel grapheme ( symbol ) .In Thai , inherent /-o-/ is invoked between a syllable 's initial consonant and final consonant when there is no written vowel .Sub - syllable inherent /-a/ is invoked within a enepenthetic initial consonant cluster .", "label": "", "metadata": {}, "score": "69.771545"}
{"text": "( ' Expr ' ) ' , $ end ] .Item 2 generates the following closure items : .Factor ' + ' num , $ end ] .Item 6 generates the following closure items : .Factor ' + ' num , ' + ' ] .", "label": "", "metadata": {}, "score": "69.80138"}
{"text": "Understanding non - hygienic macros is important if you intend to work in the larger Lisp world .In the scheme community everybody thinks that hygiene is an essential feature and all major Scheme implementations provide hygienic macros ; nevertheless , in the rest of the world things are different .", "label": "", "metadata": {}, "score": "69.81349"}
{"text": "jump to a named label redo . . . .repeat this loop turn next . . . .skip to the next loop turn last . . . . .leave this loop now break . . . .leave this when clause leave . . . .", "label": "", "metadata": {}, "score": "69.82294"}
{"text": "I C maps Const to elements of D .This mapping interprets constant symbols .I V maps Var to elements of D ind .This mapping interprets variable symbols .This mapping interprets positional terms .I SF interprets terms with named arguments .", "label": "", "metadata": {}, "score": "69.9984"}
{"text": "Step 7 .If any terminals were added to first(X ) in steps ( 3 ) through ( 6 ) .that were not already members of first(X ) , . or if first(X ) is still empty , . append nonterminal X to the tail of the queue .", "label": "", "metadata": {}, "score": "70.00493"}
{"text": "We now define what it means for a set of RIF - BLD rules to entail a RIF - BLD condition .Let R be a set of RIF - BLD rules and \u03c6 an existentially closed RIF - BLD condition formula .", "label": "", "metadata": {}, "score": "70.01745"}
{"text": "Each reduction item produces a parser table entry , reducing a particular rule on a particular look - ahead symbol .Items 1 and 2 produce the following parser actions : .$ end reduce 1 ' ) ' reduce 1 .", "label": "", "metadata": {}, "score": "70.03919"}
{"text": "Nulling .The zero length symbol string is called the empty string .The empty string can be considered to be a sentence , in which case it is the empty sentence .A string of one or more symbols is non - empty .", "label": "", "metadata": {}, "score": "70.05707"}
{"text": "( These integer values correspond to the % token definitions in the grammar specification , which define the terminal symbols of the grammar . )The special $ end symbol is usually returned as a zero or negative value , indicating that no more input tokens remain in the input stream .", "label": "", "metadata": {}, "score": "70.0652"}
{"text": "( This may have added meaning to those familiar with the Red Dragon book , or its older edition , the Green Dragon book .Okay , so it 's not great poetry - the author admits that his expertise lies in the area of programming and not in the more sublime area of poetastry . )", "label": "", "metadata": {}, "score": "70.29798"}
{"text": "If a symbol is not nullable , it is non - nullable .If a symbol is not nulling , it is non - nulling .In any instance where a symbol produces the empty string , it is said to be nulled , or to be a null symbol .", "label": "", "metadata": {}, "score": "70.344345"}
{"text": "In mid tone , the voice speaks at an even , normal pitch .The mid tone is sometimes referred to as common tone or even tone .A set of distinct words in a language which differ in only one or a limited number of phonological elements .", "label": "", "metadata": {}, "score": "70.60976"}
{"text": "\\D . . . .Match a nondigit .\\e . . . .Match an escape character .\\E . . . .Match anything but an escape character .\\f . . . .Match the form feed character .", "label": "", "metadata": {}, "score": "70.61746"}
{"text": "We can simply access the variables using with - pandoric as we have demonstrated above , or , since this is lisp , design a more specific interface .Defpan is a combination of the defun and with - pandoric macros .", "label": "", "metadata": {}, "score": "70.72754"}
{"text": "Defsetf is an interesting C OMMON L ISP macro not entirely unlike our defmacro ! extension to defmacro in that it implicitly binds gensyms around provided forms .Defsetf works great for defining the setter side of a generalised variable duality as long as the getter can be expressed as a function or macro that evaluates all of its arguments exactly once .", "label": "", "metadata": {}, "score": "70.75691"}
{"text": "// Initialize .// Create the initial item set ( i0 ) .add item to set ; . append set i0 to end of toDoList ; .// Main loop .// Generate all item sets for the grammar from the initial set .", "label": "", "metadata": {}, "score": "71.14931"}
{"text": "a , b , c ) , but may also .consist of longer names ( beta , schwa ) .Symbol names consisting of one . special character ( \u00e2\u20ac\u02dc : \u00e2\u20ac \u2122 or \u00e2\u20ac\u02dc ( \u00e2\u20ac \u2122 ) may be specified by enclosing them in . double quotes ( \u00e2\u20ac\u02dc : \u00e2\u20ac \u2122 or \u00e2\u20ac\u02dc ( \u00e2\u20ac \u2122 ) .", "label": "", "metadata": {}, "score": "71.187614"}
{"text": "$ any reduce 1 .For item sets having reduction items that reduce more than one rule , the rule that is reduced in the most number of items can be chosen as the default reduction action .If more than one rule are reduced an equal number of times , one of them is chosen arbitrarily ( a good choice is the rule with the highest precedence ) .", "label": "", "metadata": {}, "score": "71.457"}
{"text": "transitionLoop : . for each item in set , . if item.action is not set , .S C , t ] ; .for each shItem in set , .S J , u ] , . add k to newSet ; . end for ; . append newSet to toDoList ; . end if ; . end for ; . append ( completed ) set to doneList ; . end if ; . end mainLoop ; .", "label": "", "metadata": {}, "score": "71.492676"}
{"text": "Stats - counter - variance computes the variance of these values by following a link in the chain and stats - counter - stddev follows yet another to compute the standard deviation .Notice that each link in the chain only needs to pass on the anaphor self to refer to the full lexical context of the closure .", "label": "", "metadata": {}, "score": "71.6671"}
{"text": "If not , an error is thrown .Pandoriclet - set is nearly identical , except that dlambda bound one extra symbol for it to use : val .Pandoriclet - set uses setq to change the binding referred to by sym to val .", "label": "", "metadata": {}, "score": "71.68327"}
{"text": "Factor , ' ) ' ] ( - , - ) .( ' Expr ' ) ' , ' ) ' ] ( - , - ) .num , ' ) ' ] ( - , - ) .num , ' + ' ] ( - , - ) .", "label": "", "metadata": {}, "score": "71.70546"}
{"text": "According to our semantics , the three strings contain respectively , one , two and seven integers .The values of the three strings are , according to our semantics , the sum of these integers : respectively , 8675311 , 6178 , and 31 .", "label": "", "metadata": {}, "score": "71.73183"}
{"text": "The automaton starts in a specific state ( the initial state ) and makes transitions from one state to another , depending on its current state and the next few input symbols .Which state it transitions to depends on the rules embodied by the machine , which are derived from the grammar rules and symbols .", "label": "", "metadata": {}, "score": "71.7697"}
{"text": "true not X .List infix . . . . . . . . .List prefix . . . . . . . .Loose and . . . . . . .and andthen X .Loose or . . . . . . . .", "label": "", "metadata": {}, "score": "71.784515"}
{"text": "The macro pandoric - recode takes a slightly different approach to hotpatching .It conserves the original lexical environment of the code while still managing to change the function to be executed when the closure is invoked to something coded and compiled externally .", "label": "", "metadata": {}, "score": "71.92689"}
{"text": "Please Comment By @@TBD . @@TBD .No Endorsement .Publication as a Working Draft does not imply endorsement by the W3C Membership .This is a draft document and may be updated , replaced or obsoleted by other documents at any time .", "label": "", "metadata": {}, "score": "71.984566"}
{"text": "The first and second tone markers indicate the falling and high tones , respectively ; the third and fourth tone markers are never used .One of five lexical tones used in Thai ( along with mid , high , rising , and falling ) .", "label": "", "metadata": {}, "score": "71.98512"}
{"text": "file is executable by effective uid / gid . :o . . .file is owned by effective uid .: R . . .file is readable by real uid / gid .: W . . .file is writeable by real uid / gid .", "label": "", "metadata": {}, "score": "71.99451"}
{"text": "Exists introduces existentially quantified variables .Here Var+ stands for the list of variables that are free in CONDITION .RIF - BLD conditions permit only existential variables , but RIF - FLD syntax allows arbitrary quantification , which can be used in some dialects .", "label": "", "metadata": {}, "score": "72.04402"}
{"text": "A formula is a statement that can have one of the following forms : .Atomic : If \u03c6 is a well - formed atomic formula then it is also a formula .As a special case , And ( ) is allowed and is treated as a tautology , i.e. , a formula that is always true .", "label": "", "metadata": {}, "score": "72.288376"}
{"text": "Filetest Ops . : r . . .file is readable by effective uid / gid . :w. .file is writeable by effective uid / gid .:x . . .file is executable by effective uid / gid . :o . . .", "label": "", "metadata": {}, "score": "72.35896"}
{"text": "In low tone , the voice begins below normal speaking pitch , dropping slightly down from there .Languages have at their disposal various different tools for achieving their primary function of enabling communication .For example , prosody , gesture , vocalization , volume , and more .", "label": "", "metadata": {}, "score": "72.36818"}
{"text": "Match a digit .\\D. . . . .Match a nondigit .\\e . . . . .Match an escape character .\\E. . . . .Match anything but an escape character .\\f . . . . .", "label": "", "metadata": {}, "score": "72.45242"}
{"text": "Macros are not for inlining , compilers are for inlining .So going back to our pandoric counter stored in the symbol - function of pantest , we can use this new getter function to retrieve the current value of pantest 's acc binding : .", "label": "", "metadata": {}, "score": "72.55526"}
{"text": "Pandoric - eval uses a special variable that we have named pandoric - eval - tunnel to make a pandoric closure available to the eval function through the dynamic environment .We choose exactly which lexical variables to tunnel through the dynamic environment by providing a list of all their symbols as the first argument to pandoric - eval .", "label": "", "metadata": {}, "score": "72.55996"}
{"text": "In dead syllables without a tone marker , the low tone is indicated .The first and second tone markers indicate the low and falling tones , respectively ; the third and fourth tone marks are never used .Phonetically , all high - class consonants are either aspirates or fricatives .", "label": "", "metadata": {}, "score": "72.61583"}
{"text": "alias to named capture , see Twigils above $ 0 . alias to positional capture ( like in P5 ) @( ) . . . . . . . .array that holds $ 0 .KERNEL . . . . .", "label": "", "metadata": {}, "score": "72.652664"}
{"text": "The start symbol is the root of the tree .The node at the root of the tree is called the start node .Traditionally , grammars divide all symbols sharply into terminals and non - terminals .A terminal symbol must ALWAYS be used as a terminal .", "label": "", "metadata": {}, "score": "72.746796"}
{"text": "Thai is a lexical tone language , not a grammatical tone language .One of the classes of consonants in Thai ( along with low- and mid- ) , used in the tone rules to determine the lexical tone of a syllable .", "label": "", "metadata": {}, "score": "72.81967"}
{"text": "A derivation from the start symbol which produces the empty string is a null parse .If in a particular grammar , a symbol has a null derivation , it is a nullable symbol .If , in a particular grammar , the only sentence produced by a symbol is the empty sentence , it is a nulling symbol .", "label": "", "metadata": {}, "score": "73.3995"}
{"text": "Control Chars .They are also usable in regexes and thatswhy also included in the next list .\\a . . . . . . . .BELL \\b . . . . . . . .BACKSPACE \\e . . . . . . . .", "label": "", "metadata": {}, "score": "73.44844"}
{"text": "Misuse of eval can result in slower programs because eval can be a very expensive operation - mostly because it needs to expand macros present in the form passed to it .Should you suddenly find a need for eval when programming , ask yourself why you did n't do whatever it is you want to do a lot earlier .", "label": "", "metadata": {}, "score": "73.46271"}
{"text": "+ ' Factor , ' + ' ] ( - , - ) .Factor ' + ' num , ' ) ' ] ( - , - ) .Factor ' + ' num , ' + ' ] ( - , - ) .", "label": "", "metadata": {}, "score": "73.47471"}
{"text": "Factor ' + ' num , num ] ( Factor , - ) R .Factor ' + ' num , ' + ' ]( Factor , - ) R .Factor ' + ' num , ' ( ' ]", "label": "", "metadata": {}, "score": "73.520676"}
{"text": "loop with positive exit condition(exit when true ) , evals expression into boolean context for . . . . .iterates over an array from first to last value , evals expression into lazy list context .Routine Types . sub . . . . . . . .", "label": "", "metadata": {}, "score": "73.65747"}
{"text": "Twigil is short for secondary sigil .They follow after a primary sigil and mark special namespaces or variables with special meanings and properties .$ foo . . .ordinary scoping ( no twigil ) $ . foo . . .", "label": "", "metadata": {}, "score": "73.74106"}
{"text": "Perl string ( finite sequence of Unicode characters ) Num . . . . .Perl floating point number Complex .Perl complex number Bool . . . . .Perl boolean Exception .Perl exception Code . . . .Base class for all executable objects Block . . . .", "label": "", "metadata": {}, "score": "73.765594"}
{"text": "this directive occurs .The \u00e2\u20ac\u02dc # \u00e2\u20ac \u2122 should be the first character on the line .Tabs or spaces may . separate \u00e2\u20ac\u02dc # \u00e2\u20ac \u2122 and \u00e2\u20ac\u02dc include \u00e2\u20ac \u2122 .The file name must be quoted .Only tabs .", "label": "", "metadata": {}, "score": "73.88757"}
{"text": "If the $ N operand designates a terminal RHS symbol , its value will reference an object of type Token .Similarly , if the operand designates a nonterminal RHS symbol , its value will reference an object of the type specified by the % stacktype directive .", "label": "", "metadata": {}, "score": "74.17616"}
{"text": "Inclusion can be nested .up to 10 levels .SEE ALSO .mmorph ( 1 ) .G. Russell and D. Petitpierre , MMORPH - The Multext Morphology Program , .Version 2.3 , October 1995 , MULTEXT deliverable report for task .", "label": "", "metadata": {}, "score": "74.37371"}
{"text": "In C OMMON L ISP it could n't be any other way : eval is a function .Here is the problem : .Sometimes it would apparently be desirable to extend your lexical environment to eval .But be careful .", "label": "", "metadata": {}, "score": "74.45732"}
{"text": "To use this anaphor we use return - from .The block will return this value from the closure invocation , intercepting the original value .( defmacro !Instead of capturing the block anaphor intercept , ichain - intercept creates a local macro that allows the code inside ichain - intercept to use intercept to expand into a return - from where the block is specified by a gensym .", "label": "", "metadata": {}, "score": "74.6131"}
{"text": "As an example , we relate this ability to open up closures by comparing it to the hotpatching macros from section 6.5 , Hotpatching Closures .Recall that alet - hotpatch and its closed anaphor cousin , let - hotpatch , create closures with an indirection environment so that the function that is called when the closure is invoked can be changed on the fly .", "label": "", "metadata": {}, "score": "74.65666"}
{"text": "Perl single bit ( allows traits , aliasing , undef , etc . )Int . . . . . .Perl integer ( allows Inf / NaN , arbitrary precision , etc . )Str . . . . . .", "label": "", "metadata": {}, "score": "74.67364"}
{"text": "NAME .mmorph - MULTEXT morphology tool formalism syntax .DESCRIPTION .A mmorph morphology description file is divided into declaration . sections .Each section starts by a section header ( \u00e2\u20ac\u02dc @Alphabets \u00e2\u20ac \u2122 , .\u00e2\u20ac\u02dc @ Attributes \u00e2\u20ac \u2122 , etc . ) followed by a sequence of declarations .", "label": "", "metadata": {}, "score": "74.804886"}
{"text": "Perl floating point number Complex .Perl complex number Bool . . . . .Perl boolean Exception .Perl exception Code . . . .Base class for all executable objects Block . . . .Executable objects that have lexical scopes List . . . . .", "label": "", "metadata": {}, "score": "74.86447"}
{"text": "inheritable object methods submethod . . .not inheritable methods regex . . . . . . .routine that executes a regular expression rule . . . . . . . .alias to regex : ratchet : sigspace token . . . . . . .", "label": "", "metadata": {}, "score": "74.94867"}
{"text": "file is executable by real uid / gid . :O . . .file is owned by real uid .: e . . .file exists : z . . .file has size equal to 0 ( an empty file ) .", "label": "", "metadata": {}, "score": "74.96408"}
{"text": "passing it the top - most tLen symbols on termStack .and the top - most nLen symbols on nontermStack ; .// Reduce the RHS symbols , replacing them with the LHS symbol .pop tLen symbols from termStack ; . pop nLen symbols from nontermStack ; . push rule .", "label": "", "metadata": {}, "score": "75.0414"}
{"text": "Level . . . . . . . . . . . .Terms . . . . . . . . .42 3.14 \" eek \" qq[\"foo \" ] $ x : ! verbose @$arrayL .Method postfix . . . .", "label": "", "metadata": {}, "score": "75.26506"}
{"text": "else if action is REDUCE , .// Perform the parser action for the rule .if action is ACCEPT ( r0 ) , . if laSym is $ end , .// Accept .break mainLoop ; . else .// Unexpected extraneous look - ahead symbol . invoke parser error handler ; .", "label": "", "metadata": {}, "score": "75.44971"}
{"text": "object attribute private storage $ ^foo .Special Variables .$ _ . . . . . . . . .context variable $ ! error msg - $ / . . . . . . . . .alias to named capture , see Twigils above $ 0 . alias to positional capture ( most like in P5 - $ 1 . array that holds $ 0 .", "label": "", "metadata": {}, "score": "75.52219"}
{"text": "ID is a token ( terminal symbol , all uppercase ) .; starts a comment ( not part of the definition ) .Symbols that parse but do nothing are marked with .\u00e2\u20ac\u02dc ; not operational\u00e2\u20ac \u2122 .Simple tokens of the BNF above are defined as follow : The token name on .", "label": "", "metadata": {}, "score": "75.579025"}
{"text": "Foo : Foo .Such a rule is meaningless , because it does not define any way of progressing from the start of the rule to the end , i.e. , there is no way to recognize the RHS of this production rule and proceed with the parse .", "label": "", "metadata": {}, "score": "75.59038"}
{"text": "x13 i4 ) .num , ' ) ' ] ( num , .x13 i4 )M : x11 .num , ' + ' ] ( num , .x13 i4 ) .+ ' Factor , $ end ] ( ' + ' , .", "label": "", "metadata": {}, "score": "75.65535"}
{"text": "parsed . . . .macro is parsed once , is hygienic , only parsed can be used reparsed . macro parsed twice , not hygienic , later parsed can be used .May Be Superseded .This section describes the status of this document at the time of its publication .", "label": "", "metadata": {}, "score": "75.76587"}
{"text": "MODULE . . . . .current module $ ?PACKAGE . . . .current package : : ? CLASS . . . . .current class ( as package name ) $ ?CLASS . . . . . .", "label": "", "metadata": {}, "score": "75.85964"}
{"text": "Vowel quality is characterized according to three primary dimensions , height , backness , and roundness .One of the three main classifications of vowel quality in phonology , vowel roundness is determined by the third ( and higher ) formants of a vocal acoustic signal .", "label": "", "metadata": {}, "score": "76.20511"}
{"text": "COMMENTS .The parser for the morphology description formalims above was written using yacc ( 1 ) and flex ( 1 ) .Flex was written by Vern Paxson , . project under the condition of the GNU General Public License .", "label": "", "metadata": {}, "score": "76.6432"}
{"text": "Here is an example of a lexical context which is particularly restricted : . r6rs ( library ( experimental dummy - ctxt ) ( export dummy - ctxt ) ( import ( only ( rnrs ) define syntax ) ) ( define dummy - ctxt # ' here ) ) .", "label": "", "metadata": {}, "score": "76.645386"}
{"text": "$ foo . . .ordinary scoping ( no twigil ) $ . foo . . .object attribute public accessor $ ! foo . . .object attribute private storage $ ^foo .Special Variables .$ _ . . . . . . . . .", "label": "", "metadata": {}, "score": "76.649216"}
{"text": "CLASS . . . . .current classes $ ?ROLE . . . . . . .current role ( as variable ) @ ?ROLE . . . . . .current roles & ?ROUTINE . . . .", "label": "", "metadata": {}, "score": "76.65526"}
{"text": "Sign - up to join our mail\u00ading list .You 'll receive e\u00admail notification when this site is updated .Your privacy is guaran\u00adteed ; this list is not sold , shared , or used for any other purpose .Click here for more infor\u00admation .", "label": "", "metadata": {}, "score": "76.679886"}
{"text": "The macro we have used so far to create pandoric closures is pandoriclet .Plambda is an inside out re - write of pandoriclet that adds a few important features .First and foremost , plambda no longer creates the let environment to be used through our pandoric accessors .", "label": "", "metadata": {}, "score": "76.76851"}
{"text": "Initial Item Set .Recall that for a given grammar , there is always one goal symbol ( also called the start symbol ) .For instance , in the grammar shown in Example 1 , the goal symbol is Expr .", "label": "", "metadata": {}, "score": "76.95161"}
{"text": "Buyer ( purchase^^rif : local ( ?Buyer ?Seller book^^rif : local ( ?Author bks : LeRif^^rif : iri ) curr : USD^^rif : iri ( 49^^xsd : integer ) ) ?Buyer ?P ( ?Exists variable 1 . . . .", "label": "", "metadata": {}, "score": "77.027214"}
{"text": "It can also occur with mid- or high - class initial consonant if tone mark \u0e44\u0e21\u0e49\u0e42\u0e17 is present .In falling tone , the voice begins above normal speaking pitch , and decends to normal pitch from there .A consonant sound which is produced by a turbulent stream of air being forced through the narrow space between speech articulators .", "label": "", "metadata": {}, "score": "77.08175"}
{"text": "Note G ] .// Add the new transition set to the to - do list .append newSet to end of toDoList ; . end transitionLoop ; .// Add the ( completed ) set to the done list .compress set ; [ Note H ] .", "label": "", "metadata": {}, "score": "77.17868"}
{"text": "file is a plain file .: d . . .file is a directory .: l . . .file is a symbolic link .:p . . .file is a named pipe ( FIFO ) , or filehandle is a pipe .", "label": "", "metadata": {}, "score": "77.397255"}
{"text": "In Lisp in Small Pieces there is a short but interesting discussion on macros .Much of it relates to describing the different macro system variations possible thanks to the ambiguity of the Scheme macro specification 18 Thanks , but no thanks . , but there are also a few interesting notes on why we might want to use macros and how to go about using them .", "label": "", "metadata": {}, "score": "77.4823"}
{"text": "+ ' num ' + ' shift 6 $ any reduce 1 .Default Reduction Actions .Combining multiple reduce actions into a single default action has the benefit of reducing the size of the parser tables , allowing the parser to select the default reduction action if no shift actions are found that match the current look - ahead symbol .", "label": "", "metadata": {}, "score": "77.66664"}
{"text": "This is represented by the special $ any symbol , indicating that any look - ahead symbol matches the action by default .The default reduce action is selected by the parser if no other entry matching the current look - ahead symbol is found in the state .", "label": "", "metadata": {}, "score": "77.70555"}
{"text": "Make - noisy - stats - counter is identical to make - stats - counter except that it uses the self anaphor to invoke our defpan functions stats - counter - mean , stats - counter - variance , and stats - counter - stddev .", "label": "", "metadata": {}, "score": "77.714615"}
{"text": "This utility function is necessary to pandoriclet for the same reason that it was necessary for sublet : these macros code - walk the bindings provided to let where our previous macros blindly spliced the bindings into another let .We have put in two calls to list - creating utility functions yet to be defined : pandoriclet - get and pandoriclet - set , each of which accept a list of let bindings .", "label": "", "metadata": {}, "score": "77.77184"}
{"text": "Pandoriclet is similar to other macros we 've seen .As with all of our anaphoric let variants , we assume the final form in the pandoriclet body will be a lambda form .Like alet - hotpatch , pandoriclet uses the dlambda macro to dispatch between different possible pieces of code to execute when the closure returned from pandoriclet is invoked .", "label": "", "metadata": {}, "score": "78.02323"}
{"text": "IF flag2 THEN // statement 2 . statementA .ELSE .statementB ELSE // ELSE appearing after a Stmt .statementC .Upon reading the second ELSE above , the parser enters state 37 with a look - ahead symbol of ELSE .", "label": "", "metadata": {}, "score": "78.12422"}
{"text": "To set it , you can use ( setf x 5 ) .Similarly , to access the car slot of a cons called , say , x , you use ( car x ) .To set it , you can use the form ( setf ( car x ) 5 ) .", "label": "", "metadata": {}, "score": "78.26302"}
{"text": "[ 1 ] Compilers : Principles , Techniques , and Tools .( a.k.a .the Red Dragon Book ) Aho , Sethi , and Ullman Addison - Wesley , 1986 , ISBN 0 - 201 - 10088 - 6 .Revision History .", "label": "", "metadata": {}, "score": "78.31128"}
{"text": "SPELLING @Spelling .TYPES @Types .In the section header tokens above , spaces may separate the \u00e2\u20ac\u02dc @ \u00e2\u20ac \u2122 from .the reserved word .Complex tokens .NAME . is any sequence of letter , digit , underline ( \u00e2\u20ac\u02dc _ \u00e2\u20ac \u2122 ) , period ( \u00e2\u20ac\u02dc .", "label": "", "metadata": {}, "score": "78.652405"}
{"text": "current filename of source file $ ?MODULE . . . .current module $ ?PACKAGE . . . .current package $ ?CLASS . . . . .current class & ?BLOCK . . . . .reference to current block $ ?", "label": "", "metadata": {}, "score": "78.750145"}
{"text": "at run time , ALAP , only ever runs once .at every block entry time , repeats on loop blocks .at every unsuccessful block exit , part of LEAVE queue .at loop termination time , after any LEAVE . assert postcondition at every block exit , after LEAVE . catch control exceptions , before LEAVE .", "label": "", "metadata": {}, "score": "78.75644"}
{"text": "A type of consonant phoneme in which the vocal cords are constricted to stop the flow of air , as in the English interjection , \" uh - oh . \" More common in Thai , it is nominally represented by the consonant \u0e2d .", "label": "", "metadata": {}, "score": "78.98548"}
{"text": "Alet - hotpatch% is an expansion of alet with a special lambda form provided .This lambda form checks the first argument 13 With a pointer comparison . to see if it is the keyword symbol : hotpatch and , if so , replaces the indirected closure with another provided argument .", "label": "", "metadata": {}, "score": "78.996414"}
{"text": "Sixth Intl .Conference on Database Theory , Prague , Czech Republic , January 1995 , Lecture Notes in Computer Science 893 , Springer Verlag , pp .252 - -265 .", "label": "", "metadata": {}, "score": "79.00423"}
{"text": "The unround vowels in Thai are /i i\u02d0 \u026f \u026f\u02d0 e e\u02d0 \u0264 \u0264\u02d0 \u025b \u025b\u02d0 a a\u02d0/ .In Thai , each of the basic vowel monophthongs has a long- and short - duration variant .Since there are nine of these basic geminate pairs , there are eighteen vowel phonemes in Thai .", "label": "", "metadata": {}, "score": "79.21712"}
{"text": "leave this routine with a return value .Loops . loop . . . .general ( endless ) loop , unless used as an C - style - loop , evals following expression into void context repeat . initial command for while or until loops that have their condtion at the end while . . .", "label": "", "metadata": {}, "score": "79.29541"}
{"text": "The complete syllable thus follows the pattern : Initial consonant + vowel + final consonant .The syllable is classified as live or dead based on the type of final consonant : live consonant ending or dead consonant ending .Thai consonants are divided into three classes , called low , mid , and high , for the purposes of applying the tone rules .", "label": "", "metadata": {}, "score": "79.327415"}
{"text": "One of five lexical tones used in Thai ( along with low , mid , high , and falling ) .The rising tone occurs in live syllables with high - class initial consonant or when tone mark \u0e44\u0e21\u0e49\u0e08\u0e31\u0e15\u0e27\u0e32 appears with mid - class initial consonant .", "label": "", "metadata": {}, "score": "80.10976"}
{"text": "Already , several macros shown should have used it .Sharp - backquote is a read macro that reads in as a lambda form .By default , this lambda form will take exactly one argument : a1 .The read macro then recursively invokes the read function with the supplied stream .", "label": "", "metadata": {}, "score": "80.11105"}
{"text": "file is a named pipe ( FIFO ) , or filehandle is a pipe .:S . . .file is a socket .: b . . .file is a block special file .: c . . .", "label": "", "metadata": {}, "score": "80.302765"}
{"text": "42 3.14 \" eek \" qq[\"foo \" ] $ x : ! verbose @$arrayL .Method postfix . . . .meth .[] .^ .: N .Autoincrement . . . .+ + -- R .", "label": "", "metadata": {}, "score": "80.34107"}
{"text": "for which operating System was this program compiled ?DISTRO . . . . .Which OS distribution am I compiling under ?ARCH . . . . . . .SoftwarePackage # Host architecture $ ?XARCH . . . . . .", "label": "", "metadata": {}, "score": "80.65714"}
{"text": "In the definition of define - macro I gave in episode 28 I used the name of the defined macro as lexical context .The consequence of this choice is that define - macro style macros are expanded within the lexical context of the code where the macro is invoked .", "label": "", "metadata": {}, "score": "81.10788"}
{"text": "Just as learning C pointers breeds dubious stylistic advice , so does free variable injection .The most plausible hypothesis for the source of difficulty in understanding free variable injection is its fail - safe behaviour 12 Safe in the sense that , contrary to the real world , failing as quickly and as loudly as possible is safest .", "label": "", "metadata": {}, "score": "81.44078"}
{"text": "It also allows the contents of the token to be stored in a variable , yylval .By default , this token variable is just an integer ( of type int ) , but YACC allows the type to be any user - defined type , which is specified using the % union directive .", "label": "", "metadata": {}, "score": "82.075516"}
{"text": "The value of a parse is the value of its start symbol .Copyright and License .Copyright 2013 Jeffrey Kegler This file is part of Marpa::R2 .Marpa::R2 is free software : you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation , either version 3 of the License , or ( at your option ) any later version .", "label": "", "metadata": {}, "score": "82.31069"}
{"text": "DISTRO . . . . .Which OS distribution am I compiling under ?VM . . . . . . . .Which virtual machine am I compiling under $ ? XVM . . . . . . .Which virtual machine am I cross - compiling for $ ?", "label": "", "metadata": {}, "score": "82.93771"}
{"text": "A zero length derivation is a trivial derivation .A derivation which is not trivial ( that is , a derivation which has one or more steps ) is a non - trivial derivation .A non - trivial derivation of a symbol string from itself is called a cycle .", "label": "", "metadata": {}, "score": "83.04622"}
{"text": "Although C OMMON L ISP still allows a large number of legal ways to implement macro systems , it is designed to provide general meta - programming tools that come together in standard and portable ways .The two advanced C OMMON L ISP macro features that allow us to implement things like CLOS 's with - slots are generalised variables and symbol macros .", "label": "", "metadata": {}, "score": "83.98682"}
{"text": "There are nine basic vowel sounds in Thai : /i \u026f u e \u0264 o \u025b \u0254 a/ .In Thai , each of these has duration as a contrasting feature , which gives a total of eighteen basic vowel phonemes in Thai .", "label": "", "metadata": {}, "score": "84.28962"}
{"text": "In Thai , every syllable carries one of five contrasting pitch characteristics- low , mid ( also called common ) , high , rising , or falling .The syllable must be pronounced with the correct tone if it is to be properly understood .", "label": "", "metadata": {}, "score": "84.54178"}
{"text": "FORM FEED \\n . . . . . . . .LINE FEED \\r . . . . . . . .CARRIAGE RETURN \\t . . . . . . . .TAB .Escape Sequences .\\0 [ ... ] .", "label": "", "metadata": {}, "score": "85.028435"}
{"text": "Thai is a lexical tone language , which means that every syllable has a pitch characteristic which must be spoken correctly for the meaning of the word to be properly understood .There are five lexical tones in Thai , to wit : low , middle ( or common ) , high , rising , and falling .", "label": "", "metadata": {}, "score": "85.048065"}
{"text": "VM . . . . . . . .Which virtual machine am I compiling under $ ? XVM . . . . . . .Which virtual machine am I cross - compiling for $ ?PERL . . . . . . .", "label": "", "metadata": {}, "score": "85.21454"}
{"text": "V 1 , ... , ?V n are variables then Exists ?V 1 ... ?V n ( \u03c6 ) is a formula .Formulas constructed using the above definitions are called RIF - BLD conditions .RIF - BLD rules are defined as follows : .", "label": "", "metadata": {}, "score": "85.98488"}
{"text": "Open the box .First we take a slight detour through another famous lisp book : Lisp in Small Pieces [ SMALL - PIECES ] by Christian Queinnec .Queinnec is a widely respected lisp expert and has contributed much to our lisp knowledge .", "label": "", "metadata": {}, "score": "86.414795"}
{"text": "This is an example of C OMMON L ISP doing what it was designed to do : allowing abstractions based on a refined , standardised macro system .While most languages are designed to be easy to implement , C OMMON L ISP is designed to be powerful to program .", "label": "", "metadata": {}, "score": "88.04892"}
{"text": "John A. $ + + + !Paul S. $ 100 !Mike A. $ 100 !Eric B. $ 100 !John Karl L. $ 100 !Don S. $ 100 !John S. $ 100 !Peter B. $ 100 !", "label": "", "metadata": {}, "score": "88.494705"}
{"text": "( aka int on 32-bit machines ) int64 .( aka int on 64-bit machines ) uint1 .( aka bit ) uint2 . uint4 . uint8 .( aka byte ) uint16 .uint32 .uint64 .", "label": "", "metadata": {}, "score": "90.72174"}
{"text": "Variables can be used to indicate that some attributes have the same . value .A variable is a name starting with a dollar ( \u00e2\u20ac\u02dc $ \u00e2\u20ac \u2122 ) .If needed , both a variable and a value specification can be given for . an attribute ( only once per attribute ) : .", "label": "", "metadata": {}, "score": "93.053024"}
{"text": "Oh , and one last thing , concerning the name of the algorithm ( with apologies to Peter Yarrow and Leonard Tipton ) : .Puff , The Merging Dragon .Puff , the merging dragon lived by the sea And frolicked in the item mist in a land called Honalee .", "label": "", "metadata": {}, "score": "93.28064"}
{"text": "See the GNU Lesser General Public License for more details .You should have received a copy of the GNU Lesser General Public License along with Marpa::R2 .Module Install Instructions .To install Marpa::R2::Scanless , simply copy and paste either of the commands in to your terminal Marpa - R2 - 2.065_002 .", "label": "", "metadata": {}, "score": "93.409225"}
{"text": "The high ( or \" close \" in IPA terminology ) vowel phonemes of Thai are /i i\u02d0 \u026f \u026f\u02d0 u u\u02d0/ .The mid vowel phonemes of Thai are /e e\u02d0 \u0264 \u0264\u02d0 o o\u02d0 \u025b \u025b\u02d0 \u0254 \u0254\u02d0/ .The low ( or \" open \" in IPA terminology ) vowel phonemes of Thai are /a a\u02d0/ .", "label": "", "metadata": {}, "score": "95.51703"}
{"text": "See the GNU Lesser General Public License for more details .You should have received a copy of the GNU Lesser General Public License along with Marpa::R2 .Module Install Instructions .To install Marpa::R2::Vocabulary , simply copy and paste either of the commands in to your terminal Let Over Lambda-50 Years of Lisp . by Doug Hoyte .", "label": "", "metadata": {}, "score": "96.55137"}
{"text": "Investigate your favourite CLOS implementation , imitate how dispatching is done there , re - benchmark .All material is ( C ) Doug Hoyte unless otherwise noted or implied .All rights reserved .Variables .Twigils . , or secondary sigils .", "label": "", "metadata": {}, "score": "97.0864"}
{"text": "The front vowel phonemes of Thai are /i i\u02d0 e e\u02d0 \u025b \u025b\u02d0/ .The central vowel phonemes of Thai are /\u026f \u026f\u02d0 u u\u02d0 a a\u02d0/ .The back vowel phonemes of Thai are /u u\u02d0 o o\u02d0 \u0254 \u0254\u02d0/ .", "label": "", "metadata": {}, "score": "98.12131"}
{"text": "Copyright 2014 Jeffrey Kegler This file is part of Marpa::R2 .Marpa::R2 is free software : you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation , either version 3 of the License , or ( at your option ) any later version .", "label": "", "metadata": {}, "score": "98.17682"}
{"text": "Marpa::R2::Scanless - Scanless interface .Synopsis .About this document .This document is an introduction and overview to Marpa 's Scanless interface ( SLIF ) .Marpa::R2 's top - level page has an SLIF tutorial in Marpa 's top - level page .", "label": "", "metadata": {}, "score": "98.23802"}
{"text": "In C OMMON L ISP , any non - nil value is a true boolean value so C OMMON L ISP programmers typically embed interesting information in truth values .Languages that have reserved true and false values - notably Scheme - employ explicit booleans , which sometimes force you to throw out extra information to satisfy redundant type constraints .", "label": "", "metadata": {}, "score": "100.39807"}
{"text": "Portions of this document may be used or quoted without permission from the author provided that appropriate credit is given to the author .This document may be printed and distributed without permission from the author on the condition that the authorship and copyright notices remain visible and unaltered .", "label": "", "metadata": {}, "score": "101.07702"}
{"text": "Practical LR(k ) Parser Construction .By David R. Tribble Revision 1.0 , 2004 - 12 - 12 .First , it is slightly cheaper , and secondly it has the words DON'T PANIC written in large friendly letters on the cover .", "label": "", "metadata": {}, "score": "105.361984"}
{"text": "Pandora 's box is a Greek myth about the world 's first woman : Pandora .Pandora , the U - language symbol , translates from Greek into all - gifted .Pandora , the woman , was tempted by curiosity to open a small box which irreparably unleashed all of humanity 's evil and sins upon the world .", "label": "", "metadata": {}, "score": "107.75349"}
