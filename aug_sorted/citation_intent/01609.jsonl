{"text": "I describe a head - driven parsing algorithm , based on the head - driven parser by Martin Kay [ 46 ] .The parser is generalized in order to be applicable to any grammar that employs linear and non - erasing operations on strings .", "label": "", "metadata": {}, "score": "36.73224"}
{"text": "Another goal of the present invention is to provide a chart parser that correctly computes hypothesis probabilities in an efficient manner for CFGs and stochastic unification grammars , by interleaving the search for explanations of symbols from both the top down and from the bottom up .", "label": "", "metadata": {}, "score": "40.5142"}
{"text": "94 - 102 ) is one of the most efficient parsing algorithms for written sentence input and can operate in linear time for regular grammars .It was one of the first parsing methods that used a central data structure , known as a chart , for storing all intermediate results during the parsing process of a sentence .", "label": "", "metadata": {}, "score": "40.7735"}
{"text": "Here 's just a short note to list the papers I 've found describing code generation via parsing techniques .These techniques have the advantages of being relatively self documenting , usually are linear time schemes , and help in building easily retargeted code generators .", "label": "", "metadata": {}, "score": "41.10855"}
{"text": "Xin Li , Dan Roth in Proceedings of the 2001 workshop on Computational Natural Language Learning - ConLL ' 01 ( 2001 ) .Significant amount of work has been devoted recently to develop learning techniques that can be used to generate partial ( shallow ) analysis of natural language sentences rather than a full parse .", "label": "", "metadata": {}, "score": "41.29158"}
{"text": "This would result in increased efficiency throughout the system .Below , such an extension is described .It is essentially a simplified version of the grammars formulated and characterized as Local Grammars in Ross ( 1981 ) and Saenz ( 1982 ) .", "label": "", "metadata": {}, "score": "41.7229"}
{"text": "The ability to predict the set of possible nth words of a sentence , given the first n-1 words of the sentence is the final modification necessary to enable this parser to be used for menu - based natural language understanding .", "label": "", "metadata": {}, "score": "42.594986"}
{"text": "Craig Thompson abstacted out a core grammar and lexicon as described above which took advantage of most of the findings of that report .At the present time , however , the important finding involving the ability to return attributes from more than one relation has not been fully implemented , though an implementation is in progress .", "label": "", "metadata": {}, "score": "42.650322"}
{"text": "This sort of modification has been demonstrated in a prototype system that CSL is building for the DSG product .Taken together , the advantages listed above pave the way for low cost , maintainable interfaces to relational database systems .All of the advantages are novel when considered with respect to prior art .", "label": "", "metadata": {}, "score": "43.189964"}
{"text": "Petrick ( 1973 ) adopts this mechanism , using somewhat different notation .The work of these researchers have been built upon in the design of the feature percolation mechanism described here .The mechanism is a constrained version of Knuth 's .", "label": "", "metadata": {}, "score": "43.79312"}
{"text": "Except for very small grammars , this first solution would require a prohibitive amount of storage for the reachability matrix .A second solution is to do the same the calculation at the point where the reachability information is required rather than prestoring the answer in the reachability matrix .", "label": "", "metadata": {}, "score": "44.227943"}
{"text": "This point is significant since it widens the scope of the usefulness of that patent .It happens though that many advantages ( noted above ) accrue from using natural language grammars and lexicons with that NLMENU interface driver .The above sections indicate that in the past , it has been expensive to build and maintain natural language interfaces to databases .", "label": "", "metadata": {}, "score": "44.31528"}
{"text": "The paper proposes a novel method to determine sentence similarities .First two compared sentences are parsed by shallow - parsing and all noun phrases , verb phrases and preposition phrases of each sentence are extracted .Then the similarity between ... .", "label": "", "metadata": {}, "score": "45.050743"}
{"text": "A third choice , and the one seen as most promising , is to calculate the reachability matrix for the context - free version of the rules and then to associate an equation or set of equations with each item in the matrix .", "label": "", "metadata": {}, "score": "45.500847"}
{"text": "This paper describes an experiment in extending these techniques as far as possible .Described here are the parsing methods used by ... .We present a unified technique to solve different shallow parsing tasks as a tagging problem using a Hidden Markov Model - based approach ( HMM ) .", "label": "", "metadata": {}, "score": "45.611183"}
{"text": "This paper reports the results of experiments using memory - based learning to guide a de- terministic dependency parser for unrestricted natural language text .Using data from a small treebank of Swedish , memory - based classifiers for predicting the ... .", "label": "", "metadata": {}, "score": "46.136185"}
{"text": "Two papers by Kurt Konolige ( Konolige 1979 ) and ( Konolige , 1980 ) are related to this work .The 1979 paper ( a tech report ) describes a framework for a portable natural language interface to a database .", "label": "", "metadata": {}, "score": "46.14178"}
{"text": "( iv )An nlmenu - driven user interface for building specs .Work in progress at CSL involves prototyping an interface that allows a user to specify or modify or otherwise operate on a portable spec or interface .( v ) Proofs of correctness .", "label": "", "metadata": {}, "score": "46.182217"}
{"text": "In section 4.5 I show how the head - driven parser can be put to use for another instantiation of constraint - based grammars in which string operations are restricted to be linear and non - erasing : constraint - based and lexical versions of Tree Adjoining Grammars .", "label": "", "metadata": {}, "score": "46.529552"}
{"text": "Because of this efficiency , the algorithm applies to multiple grammar levels of a spoken language system .In accordance with the invention , a method is disclosed for combining unification grammars with rule and observation probabilities to enable a processor to recognize a speech signal input for several levels of a language model .", "label": "", "metadata": {}, "score": "46.5785"}
{"text": "However , in the presently preferred embodiment , the full reachability matrix is not compiled , but instead a list is compiled , for each node in the grammar , listing the other leftmost daughter nodes which can be dominated by that node .", "label": "", "metadata": {}, "score": "46.640144"}
{"text": "The main application of ... .Zhi Qun Chen , Qi Li Zhou , Rong Bo Wang in Proceedings - 2010 International Conference on Web Information Systems and Mining , WISM 2010 ( 2010 ) .To improve the retrieval performance , shallow parsing technique for text was introduced for Chinese Web information retrieval .", "label": "", "metadata": {}, "score": "47.04129"}
{"text": "Dougherty ( 1970 , 1971 ) enriches the mechanism which Chomsky ( 1965 ) utilizes to assign features and thereby is able to assign features to some nonterminal nodes .The grammar used by the TQA ( Transformational Question Answering ) described in Plath ( 1973 ) assignes features to non - terminal nodes by transformation .", "label": "", "metadata": {}, "score": "47.279118"}
{"text": "It is implemented using Robinson 's DIAGRAM grammar and the acquisition dialogue has been extended to include domain - specific verbs .It is intended for use by a database expert who is not necessarily a natural language expert .In her section on future research in ( Grosz , 1982b ) , Grosz states : . \"", "label": "", "metadata": {}, "score": "47.530174"}
{"text": "None of the previous work in the field claims the advantages of portability that the present system offers : . an end user can construct his own natural language using an interactive system .he can finetune the interface by specidying which tables will be covered , the access rights to those tables , the attributes to be covered and the joins that the natural language system will support .", "label": "", "metadata": {}, "score": "47.84356"}
{"text": "Such as facility is used by the NLMenu System .It is straightforward to add a well - formed state table to a Parser modified in the way just described .Before beginning a parse with new input and a set of beta - gamma pairs , the beta - gammas can be compared and those with common subgoals can be merged .", "label": "", "metadata": {}, "score": "47.997833"}
{"text": "All of the original pruning techniques have natural counterparts in the robust algorithm .When used together with memoization [ sic ] , these techniques enable the algorithm to run efficiently with cubic worst - case complexity .We have implemented these ideas and tested them by parsing the Switchboard corpus of conversational English .", "label": "", "metadata": {}, "score": "48.12067"}
{"text": "The present invention provides three major innovations which make such a natural language menu system more useful to users .First , a \" build - interface \" function is used , which creates a portable specification , i.e. a compact statement of the parameters which are sufficient to define the desired natural language interface to a relational database , according to the inputs received from a particular user expert .", "label": "", "metadata": {}, "score": "48.236958"}
{"text": "This chapter is organized as follows .Firstly I discuss the proposals for more powerful string operations , as presented by [ 67 ] , [ 38 ] , [ 72 ] , [ 106 ] and [ 1 ] .Then I define two restrictions on possible string combinations for constraint - based grammars , based on [ 107 ] .", "label": "", "metadata": {}, "score": "48.27906"}
{"text": "Accordingly , it is intended that the invention be limited only in terms of the appended claims .Trehan , R. et al . , A paralle chart parser for the committed choice non deterministic logic languages , IEEE Proceedings of the Fifth International Conference and Symposium : Logic Programming , Seattle , WA , Aug. 1988 , 212 232 , vol .", "label": "", "metadata": {}, "score": "48.310738"}
{"text": "( I have n't read this one yet , but it seems closely related to the previous paper ) .\" Retargetable Compiler Code Generation \" , Mahadevan Ganapathi , Charles N. N. Fischer and John L. Hennessy , ACM Computing Surveys 14 , December 1982 .", "label": "", "metadata": {}, "score": "48.407505"}
{"text": "A formalism for grammar representation with a built - in parser has been developed based on NCL .It offers distributed knowledge representation and processing , and a data - driven spreading activation control scheme .Grammars , described in the formalism , are mapped into network models and can be directly executed ( parsed ) as network programs in a distributed data - driven manner .", "label": "", "metadata": {}, "score": "48.522476"}
{"text": "( See the next section on experiments ) .This has been demonstrated already in the prototype where an automatically generated interface requested by the EG of TI was manually altered to provide a way to specify picture drawing functionality to an NLMENU interface .", "label": "", "metadata": {}, "score": "48.653564"}
{"text": "# # STR84 # # .To do predictive parsing with a grammar like the one described above , in addition to calculating the reachability matrix for the context - free portions of the grammar rules , the percolation and blocking rules must be taken into account .", "label": "", "metadata": {}, "score": "48.659943"}
{"text": "SPECIFIC EXTENSIONS AND TESTS .( i ) Extensions to the core grammar .The specific embodment of the MAKE - PORTABLE - INTERFACE function described above covers only a part of the retrieval functionality of one specific formal relational database interface language .", "label": "", "metadata": {}, "score": "49.185127"}
{"text": "- 9.5 Parsing sentences in a text . - 9.6 Concluding remarks . -10 A Probabilistic Parsing Method for Sentence Disambiguation .- 10.1 Introduction .- 10.2 Probabilistic context - free grammar .- 10.3 Experiments .- 10.4 Concluding remarks .", "label": "", "metadata": {}, "score": "49.457596"}
{"text": "Third , the present invention also provides a well - formedness test , which tests a grammar - lexicon pair to ensure that they are well - formed .This automatic debugging for an automatically generated natural - language expert system is novel and provides major advantages .", "label": "", "metadata": {}, "score": "49.503"}
{"text": "-15.10 Concluding remarks .- 16 Parsing with Connectionist Networks .- 16.1 Introduction .- 16.2 Incremental parsing . - 16.3 Connectionist network formalism .- 16.4 Parsing network architecture . - 16.5 Parsing network performance .- 16.6 Extensions . -", "label": "", "metadata": {}, "score": "49.542717"}
{"text": "The WELL - FORMEDNESS - TEST was used in the development of the GUIDED SQL interface as well as in debugging the various core grammar / lexicon pairs , specifically the ones with translations to SQL and the lisp machine relational dbms .", "label": "", "metadata": {}, "score": "49.563793"}
{"text": "This code is appropriate since it records the current core grammar ( as of 11 - 23 - 82 ) in use in the prototype at CSL .TABLE 3__________________________________________________________________________(loop for ( rel .TABLE 4__________________________________________________________________________(loop for ( rel .FUNCTION MAKE - SEMANTIC - LEXICON .", "label": "", "metadata": {}, "score": "49.588497"}
{"text": "The present invention provides an automatic interactive system whereby such an interface is constructed .A method for generating a context - free grammar comprising the steps of : .( a ) generating a domain - independent core grammar ; .", "label": "", "metadata": {}, "score": "49.635887"}
{"text": "8.6 A hypothesis . - 8.7 Conclusion .- 9 A Dependency - Based Parser for Topic and Focus . - 9.1 Introduction .- 9.2 Dependency - based output structures . - 9.3 The semantic impact of topic - focus articulation . -", "label": "", "metadata": {}, "score": "49.650543"}
{"text": "Furthermore , the interface that results is not portable to new domains , not robust with respect to changes in the target system , not easy to debug , and may not cover the target system ( a proof that it does so may be extremely difficult ) .", "label": "", "metadata": {}, "score": "49.822784"}
{"text": "A method for generating a grammar for use as a predictive grammar and parser in a natural language menu system , comprising the steps of : .( a ) generating a domain - independent core grammar ; .( c ) generating a domain specification directed to a predetermined natural language menu application ; and .", "label": "", "metadata": {}, "score": "49.830574"}
{"text": "The remainder of this section describes in detail how a portable specification data structure ( already computed at this point ) is used to generate a semantic grammar and lexicon from a core grammar and lexicon .First , the function MAKE - PORTABLE - INTERFACE is described .", "label": "", "metadata": {}, "score": "49.924637"}
{"text": "It has been used ( in experimental settings ) by people who are not experts in natural language processing to create natural language interfaces to databases .Grosz offers no documentation to support a claim that usable , portable natural language interfaces result from TEAM .", "label": "", "metadata": {}, "score": "49.966564"}
{"text": "Abstract : .Abstract : \" In this paper we present a robust parsing algorithm based on the link grammar formalism for parsing natural languages .Our algorithm is a natural extension of the original dynamic programming recognition algorithm which recursively counts the number of linkages between two words in the input sentence .", "label": "", "metadata": {}, "score": "49.96792"}
{"text": "Thus , after a portable specification has been constructed in this manner , it can be stored .As noted , whenever this interface is called up thereafter , the portable specification will be used to regenerate a grammar and lexicon , the well - formedness test will be applied , and the natural language menu interace will then be up and running .", "label": "", "metadata": {}, "score": "49.970863"}
{"text": "S ) .Note that the # is not required in the Lisp implementation , since an empty list is easily tested for .As noted , the parser set forth above must be modified for use in the present invention .", "label": "", "metadata": {}, "score": "50.13634"}
{"text": "It works -- several automatically generated interfaces have been successfully tried .In this section , I will be describing other 's work in building transportable natural language interfaces to databases .That work is often not described precisely enough for another researcher to know exactly what techniques were used or how successful those techniques were .", "label": "", "metadata": {}, "score": "50.15727"}
{"text": "- 12.4 Extracting the disjunctive residue . -12.5 Producing the models .- 12.6 Comparison with other techniques .-12.7 Concluding remarks . - 13 Polynomial Parsing of Extensions of Context - Free Grammars .- 13.1 Introduction .- 13.2 Linear indexed grammars .", "label": "", "metadata": {}, "score": "50.16982"}
{"text": "Each gives him a user - view of a semantically related set of data .This notion of a view is like the notion of a database schema found in network and hierarchical but not relational systems .In relational systems , there is no convenient way for loosely grouping tables together that are semantically related .", "label": "", "metadata": {}, "score": "50.230415"}
{"text": "We placed a version of the robust parser on the Word [ sic ] Wide Web for experimentation .In this version there are some limitations such as the maximum length of a sentence in words and the maximum amount of memory the parser can use . \"", "label": "", "metadata": {}, "score": "50.234215"}
{"text": "A module that corrects typing errors and performs domain - specifc morphological analysis has been developed .A parser for typed unification grammars is designed and implemented in C++ ; for description of the lexicon and the grammer a specialised specification language has been developed .", "label": "", "metadata": {}, "score": "50.49083"}
{"text": "This invention is dependent on a grammar - driven , menu - based system , but not vica - versa .The specific prototype described in dependent on the NLMENU system described in the companion patent .The principles behind the invention are : a domain - independent core natural language grammar and a corresponding core lexicon have been designed for use with an nlmenu driver .", "label": "", "metadata": {}, "score": "50.52619"}
{"text": "( d ) inserting the domain specification into the domain - independent core grammar and lexicon to define a domain dependent context - free grammar .The method of claim 1 , wherein the domain dependent context - free grammar is suitable for use as a predictive grammar and parser in a natural language menu system .", "label": "", "metadata": {}, "score": "50.59062"}
{"text": "The ability to parse a word at a time is essential for the NLMenu System .However , it is also beneficial for more traditional natural language interfaces .It can increase the perceived speed of any parser since work can proceed as the user is typing and composing his input .", "label": "", "metadata": {}, "score": "50.785545"}
{"text": "Hendrix 's approach offers a competing way to do the same sort of thing my approach does , but it differs in the ways noted above .In ( Grosz et al , 1982a ) and ( Grosz , 1982b ) , Grosz reports on a software component called TEAM .", "label": "", "metadata": {}, "score": "50.809605"}
{"text": "It employs the algorithm described above and uses the Lisp Machine 's software for creating the menus required and manipulating them as described above .The prototype implementation is a natural language database query system which accesses the parts - suppliers database described in Date ( 1975 ) , p. 79 .", "label": "", "metadata": {}, "score": "50.8596"}
{"text": "( Note that they use a parsing technique called Early 's Algorithm , which I am not familiar with but am told is order(N^3 ) ! ) \" Description - Driven Code Generation Using Attribute Grammars \" , Mahadevan Ganapathi and Charles N. Fischer , ACM SIGPLAN Notices , June 1982 . \"", "label": "", "metadata": {}, "score": "50.94177"}
{"text": "Due to the variability and ambiguity of a spoken input signal , modified algorithms were created to improve on Earley 's algorithm and to adapt it to spoken language recognition .An example of such a modified algorithm is shown in A. Paeseler , ' Modification of Earley 's Algorithm for Speech Recognition ' , Proc . of NATO ASI , Bad Windsheim , 1987 .", "label": "", "metadata": {}, "score": "51.049763"}
{"text": "Tennant performed the first and only extensive evaluation of a natural language interface .In his evaluation of the PLANES system , he found that only simple queries of 6 or 7 words were input to the system and 1/3 of the queries were not understood by the system .", "label": "", "metadata": {}, "score": "51.209625"}
{"text": "These models provide good recognition results when perplexity can be minimized , but preclude any direct support for spoken language systems by eliminating the semantic level .Language models have traditionally proven valuable in natural language systems , but only during the past decade have computationally - oriented , declarative grammar formalisms become widely available .", "label": "", "metadata": {}, "score": "51.251102"}
{"text": "( ii ) Extensions to the core lexicon .A facility for editing menu - items has been added .Automatically generated help has been added as a fifth component to the lexicon .( This help will be present with each lexical item and will be available to the user of an interface who wants an explanation of particular phrases . )", "label": "", "metadata": {}, "score": "51.254654"}
{"text": "Treating shallow parsing as part - of - speech tagging yields results comparable with other , more elaborate approaches .Using the CoNLL 2000 training and testing material , our best model had an accuracy of 94.88 % , with an overall FB1 score of 91.94 % ....", "label": "", "metadata": {}, "score": "51.39557"}
{"text": "The system for parsing of claim 20 , wherein said language model incorporates context - free grammars .A method for parsing a spoken sentence having a plurality of words , comprising the steps of : .( a ) inputting a desired spoken input composed of a plurality of grammar levels ; .", "label": "", "metadata": {}, "score": "51.457966"}
{"text": "- 7.7 Practical applications .- 7.8 Alternatives to collocation for recognition applications .- 7.9 Concluding remarks . - 8 Parsing Spoken Language Using Combinatory Grammars .- 8.1 Introduction . -8.2 Structure and intonation .- 8.3 Combinatory grammars .", "label": "", "metadata": {}, "score": "51.74622"}
{"text": "Tom De Smedt , Vincent Van Asch , Walter Daelemans in Wall Street Journal ( 2010 ) .MBSP is a text analysis system based on the TiMBL and MBT memory based learning applications developed at CLiPS and ILK .It provides tools for Tokenization and Sentence Splitting , Part of Speech Tagging , Chunking , Lemmatization , Relation Finding and ... .", "label": "", "metadata": {}, "score": "51.79595"}
{"text": "Thus , using the make - portable - interface function , a large number of portable specifications can be stored , and each portable specification can be rapidly constructed into the required grammar and lexicon when that particular natural language interface is called upon .", "label": "", "metadata": {}, "score": "51.974483"}
{"text": "One possibility is to construct a much larger reachability matrix which contains feature information .This can be done by having one entry in the reachability matrix for every possible set of attributes and values that can be associated with each of the symbols .", "label": "", "metadata": {}, "score": "51.99511"}
{"text": "S Jerrold Kaplan ( Kaplan , 1979 ) describes a portable interface which includes an augmented transition network .He restricts his grammar to handle only questions beginning with WH - words , like \" who \" , \" what \" , . . .", "label": "", "metadata": {}, "score": "52.020065"}
{"text": "Now , if this is done for all of the beta - gamma pairs that resulted after parsing the first n-1 and the union of the sets that result is taken , the resulting set is a list of all of the lexical categories that could come next .", "label": "", "metadata": {}, "score": "52.250797"}
{"text": "The companion patent by Tennant , Ross , and Saenz describes an invention that overcomes the difficulties involving \" ease of use \" of natural language interfaces ( and also formal language interfaces -- see next subsection ) .The second reason why natural language interfaces to databases are not in common use today is the large amount of time it has traditionally taken to construct a natural language interface .", "label": "", "metadata": {}, "score": "52.295586"}
{"text": "This has substantial advantages in the present invention , as described below .An example of the operation of this simplified version of a parsing procedure will now be given .Suppose , for example , that the grammar to be applied is as follows : .", "label": "", "metadata": {}, "score": "52.667755"}
{"text": "Although only a small fraction of the sentences in this corpus are ' grammatical ' by standard criteria , the robust link grammar parser is able to extract relevant structure for a large portion of the sentences .We present the results of our experiments using this system , including the analyses of selected and random sentences from the corpus .", "label": "", "metadata": {}, "score": "52.695778"}
{"text": "The 1980 paper briefly describes a method of applying metal rules to context - free rules to generate other context - free rules .The method is not described with respect to a grammar for databases and there is no mention of semantic grammars .", "label": "", "metadata": {}, "score": "53.254837"}
{"text": "His system interfaces to heirarchically structured collections of files .In his system , all domain - specific information is stored in the lexicon .He describes an experience of porting his natural language interface to a new domain database in 5 hours , which is quite good by the standards of the other systems mentioned above , but the process still involves an expert .", "label": "", "metadata": {}, "score": "53.5969"}
{"text": "A more general facility for allowing users to specify arbitrary joins in planned .Phrasing the find - parts - whose part # is - equal to - the part # of - shipment would allow such joins .At present , the system does allow natural language update to the database .", "label": "", "metadata": {}, "score": "53.60546"}
{"text": "( s ) parsing said start symbols according to the spoken input and grammars to produce observations of said symbols ; and .( t ) explaining the input based on the results of said step of parsing .The method for recognizing spoken sentences of claim 3 , further comprising the steps of : .", "label": "", "metadata": {}, "score": "53.617252"}
{"text": "Graham Wilcock in PACLING 2009 - Conference of the Pacific Association for Computational Linguistics ( 2009 ) .Apache UIMA ( Unstructured Information Management Architecture ) is a framework for linguistic annotation and text analytics .Its support for standards , interoperability and scalability makes UIMA attractive for NLP researchers .", "label": "", "metadata": {}, "score": "53.63849"}
{"text": "Unification grammars have allowed the close integration of syntax , semantics , and pragmatics .These grammars are especially significant for spoken language systems because syntactic , semantic , and pragmatic constraints must be applied simultaneously during processing .Discourse and domain contraints can then limit the number of hypotheses to consider at lower levels , thereby greatly improving performance .", "label": "", "metadata": {}, "score": "53.71553"}
{"text": "This continues until all of the input has advanced up to sentence grammar level 0 and advanced S over several time frames to cover all of the input data .At this point , the processor has completed its parse and outputs its hypothesis of the spoken input .", "label": "", "metadata": {}, "score": "53.750965"}
{"text": "Using the present invention , people who have never seen a lisp machine before can formulate interesting queries using automatically generated natural language interfaces , as often happens in our demos .None of the other researchers have reported that their automatically generated natural language unterfaces are usable ( with the exception of Larry Harris and he has not carefully documented his claims in the literature ) .", "label": "", "metadata": {}, "score": "53.759743"}
{"text": "That patent application solves many of the problems having to do with \" ease - of - use \" of natural language interfaces .The present invention solves the second problem , of making natural language interfaces easy to build and maintain , in the very important special case of relational databases and in the context of a grammar - driven , menu - based interface drive .", "label": "", "metadata": {}, "score": "53.950714"}
{"text": "However , it is possible that there may be more than one valid parse tree .The user then selects between the alternative parses displayed , so that the end product is a single unambiguous parse of an input sentence .The process by which such an unambiguous parse is translated into an executable machine command ( or an output according to some constrained system , for other applications ) will now be described .", "label": "", "metadata": {}, "score": "53.956787"}
{"text": "He can decide to make an interface that covers only a semantically related subset of his tables .He can choose to include some attributes and hide other attributes so that they can not be mentioned .He can choose to support various kinds of joins with natural language phrases .", "label": "", "metadata": {}, "score": "54.004776"}
{"text": "APPLICATION AREAS OTHER THAN RELATIONAL DATABASES .Generating interfaces to hierarchical or network or other databases or to a single file databases : .There is every reason to believe that translations written for a relational system would be replaced by equivalent translations for a newtwork or hierarchical or other dbms .", "label": "", "metadata": {}, "score": "54.16365"}
{"text": "Table of Contents . 1 Why Parsing Technologies ? - 1.1 The gap between theory and application . - 1.2 About this book . - 2 The Computational Implementation of Principle - Based Parsers . - 2.1 Introduction . - 2.2 The principle ordering problem . - 2.3 Examples of parsing using the Po - Parser .", "label": "", "metadata": {}, "score": "54.249348"}
{"text": "( In fact , we now also have translations to SQL for our core grammar / lexicon . )The prototype assumes a fixed set of parameters for substitution , though even now extensions are being made to the parameter list .", "label": "", "metadata": {}, "score": "54.2757"}
{"text": "5 is a graph showing the effect of chart parsing on pruning as employed by the present invention .DETAILED DESCRIPTION OF A PREFERRED EMBODIMENT .The present invention discloses a method which makes use of an algorithm ( discussed below ) which includes a parsing subalgorithm to affect the central data structure of a spoken language processor .", "label": "", "metadata": {}, "score": "54.278473"}
{"text": "Specifically , this invention addresses the following problems : Existing natural language interfaces to databases are seldom portable ; almost all are application - specific .They take from man - weeks to man - years for a specialist to build .", "label": "", "metadata": {}, "score": "54.58215"}
{"text": "Unfortunately it always takes N 3 time , rather than linear time , even when processing a regular grammar .Additionally , the CYK algorithm is exhaustive ; it systematically expands everything whether it will be needed or not .Such an algorithm uses a great deal of processing time and memory space .", "label": "", "metadata": {}, "score": "54.61341"}
{"text": "Automatically generated help can be added as a fifth component to each entry .What follows is a pseudo - coded version of the actual Lisp code describing MAKE - SEMANTIC - LEXICON .In the NLMENU system as implemented , experts are segments of code that are exeuctred as the query is being specified by the user .", "label": "", "metadata": {}, "score": "54.62491"}
{"text": "BACKGROUND OF THE INVENTION .Field of the Invention .This invention relates to spoken language interfaces , and more particularly to a spoken language processor containing a chart parser that incorporates rule and observation 10 probabilities with stochastic unification grammars .", "label": "", "metadata": {}, "score": "54.64347"}
{"text": "The user can control precisely what tables to include , etc and so can control the coverage of the natural language interface .The interface is easy to change if the user changes table descriptions or adds or deletes tables .Finally , a given core grammar can be constructed to probably cover any subportion of a target relational database interface language .", "label": "", "metadata": {}, "score": "54.73024"}
{"text": "More information usually implies a reduction of the search space , hence it is sensible to parse bottom - up , in order to obtain useful information as soon as possible .Furthermore , in many linguistic theories , a ' head ' of a construction plays an important role .", "label": "", "metadata": {}, "score": "54.80247"}
{"text": "The implementation of these experts , once their function has been defined , is quite simple .The critical part which should be noted is that , in translation from a partial parse to a list of displayed items , the lexicon must be modified to generate non - word items at this point .", "label": "", "metadata": {}, "score": "54.986378"}
{"text": "It saves time and memory space by expanding symbols only once .The present invention extends Earley 's basic CFG parsing algorithm to combine rule and observation probabilities with the use of unification grammars .This retains the Earley algorithm complexity while extending the results to spoken input recognition : linear for regular grammars , quadratic for unambiguous CFGs , and cubic for general CFGs .", "label": "", "metadata": {}, "score": "55.16501"}
{"text": "DESCRIPTION OF THE DRAWINGS .FIG .1 is a block diagram showing a speech recognition processor which employs the present invention ; .FIG .2 is a stack diagram demonstrating a possible grammar level structure and positioning as used by the present invention ; .", "label": "", "metadata": {}, "score": "55.244953"}
{"text": "END - USERS can build natural language interfaces to their own data ; the interfaces are robust with respect to database changes ; they can be customized to cover user - specified subsets of data and functionality in a precise manner ; and they are provably correct .", "label": "", "metadata": {}, "score": "55.27378"}
{"text": "- 14.6 Concluding remarks .- 15 Chart Parsing for Loosely Coupled Parallel Systems .- 15.1 Introduction .- 15.2 Parsing for loosely coupled systems .- 15.3 Parallelism and the chart .- 15.4 Distributing the chart . - 15.7 Termination and Synchronization .", "label": "", "metadata": {}, "score": "55.48211"}
{"text": "# # STR79 # # .Any arbitrary context - free grammar is permitted as input to the parser except for those grammars containing two classes of rules .The problem with the first class of rules is that they make it very difficult for the predictive version of the aglorithm to determine all and only those words that can come next in a sentence .", "label": "", "metadata": {}, "score": "55.612633"}
{"text": "( b ) Complete .In implementing the above algorithm , the processor reads a vector of grammars representing any number of grammar levels .Looking for the moment at FIG .2 , an example of grammar levels is shown .", "label": "", "metadata": {}, "score": "55.689285"}
{"text": "With traditional parsers where the entire sentence must be input before any parsing is done , no parsing can be done while the user formulates and inputs his query .However , if processing begins as soon as the first word or phrase is input , then the time it takes for a user to input his sentence can be put to productive use .", "label": "", "metadata": {}, "score": "55.689987"}
{"text": "But in order to expand those subsequent symbols , according to Paeseler 's algorithm , the best probability must be known , otherwise if a better probability appears , the parsing must be redone .This means potentially an exponential amount of work , which is highly undesirable .", "label": "", "metadata": {}, "score": "55.704174"}
{"text": "Larris Harris is responsible for the first important commercial venture that is based on AI technology .He developed the ROBOT system , now called INTELLECT and marketed on ON - LINE ENGLISH by Cullinaine .A database administrator is needed to create and build a lexicon for a fixed grammar and the system interfaces to a single file .", "label": "", "metadata": {}, "score": "55.812607"}
{"text": "These rules are not to be interpreted as assigning feature values .They are , instead , well - formedness conditions which indicate whether a subtree is valid , according to the grammar .As an example of the feature mechanism in action , consider a hypothetical language with the following properties .", "label": "", "metadata": {}, "score": "55.84339"}
{"text": "Before considering the algorithm of the present invention , two definitions are needed .First , one defines a stochastic unification grammar which is based on the definition of stochastic context - free grammar and is described by the generalization that the symbols are not restricted to atomic symbols but can be feature - value pairs or feature sets .", "label": "", "metadata": {}, "score": "56.05577"}
{"text": "So they can not be used with an old - style natural language system .But of course , they were designed to be used with a menu - based , grammar - driven interface so this is not really much of a sacrifice .", "label": "", "metadata": {}, "score": "56.13568"}
{"text": "Thus , the prohibition of such rules merely requires that these alternative grammatical treatments be used .A sample grammar and lexicon is provided below , as Appendix C. .Simpler and smaller grammars would result if the class of grammars allowed was extended to allow augmentations to be associated with the context - free rules .", "label": "", "metadata": {}, "score": "56.21688"}
{"text": "The \" universal projection \" problem involves a solution to the problem of a natural way to allow users to specify precisely what attributes they want returned when specifying a query .A general solution plus several particular solutions are being prototyped at CSL .", "label": "", "metadata": {}, "score": "56.250694"}
{"text": "To ... .Bartosz Zaborowski in Proceedings - 2014 22nd Annual Pacific Voice Conference - Voice Technology : Software , Hardware Applications , Bioengineering , Health and Performance , PVC 2014 ( 2014 ) .The article presents preliminary results of a project which aims at developing a new algorithm for shallow parsing of a natural language .", "label": "", "metadata": {}, "score": "56.44078"}
{"text": "-13.4 Tree Adjoining Grammars .- 13.5 Importance of linearity . - 13.6 Concluding remarks .-14 Overview of Parallel Parsing Strategies . -14.1 Introduction .- 14.2 From one to many traditional serial parsers .- 14.3 Translating grammar rules into process configurations . - 14.4 From sentence words to processes .", "label": "", "metadata": {}, "score": "56.88128"}
{"text": "A system for recognizing a spoken sentence representing a plurality of words , comprising : . a processing means ; . a grammar coupled to said processing means for defining sentences in terms of elements of a language model ; . a lexicon for defining elements of the grammar in terms of symbols ; . a parser coupled to said grammar for combining words into partial sentences , for generating sets of states and for determining completed states ; . a predictor coupled to said grammar and said processing means for predicting the symbols of valid next elements generated by said parser ; . a completer for explaining the results from the parser ; and .", "label": "", "metadata": {}, "score": "56.98798"}
{"text": "The parser operates frame synchronously to provide top - down hypotheses and to incorporate observation probabilities as they become available .A chart parser is disclosed which incorporates rule and observation probabilities with stochastic unification grammars .The parser operates frame synchronously to provide top - down hypotheses and to incorporate observation probabilities as they become available .", "label": "", "metadata": {}, "score": "56.991676"}
{"text": "For a natural language system that needed to handle all paraphrases ( as traditional systems must ) , context - free grammars are unacceptable .They do not have enough power to characterize a fragment of natural language that is very large .", "label": "", "metadata": {}, "score": "56.998734"}
{"text": "As a simple example , consider the following set of rules : .Given the lexicon shown earlier , the above grammar will determine whether sentences containing words in the lexicon are grammatical or ungrammatical , once a nonterminal symbol is assigned as the designated symbol for the grammar .", "label": "", "metadata": {}, "score": "57.076233"}
{"text": "In this version there are some limitations such as the maximum length of a sentence in words and the maximum amount of memory the parser can use . \"", "label": "", "metadata": {}, "score": "57.085506"}
{"text": "A static test of the well - formedness of generated grammars and lexicons in included in Appendix A ( the function call WELL - FORMEDNESS - TEST ) .With it , we can show that generated interfaces are statically correct .", "label": "", "metadata": {}, "score": "57.08568"}
{"text": "Below , I will briefly outline an interface being built for eliciting the information contained in a portable spec from a user and from the data dictionary of a dbms .As for maintaining such an interface when new columns are added to tables or new tables are added or deleted , etc , one need only modify the portable spec to reflect the changes and regenerate the interface .", "label": "", "metadata": {}, "score": "57.1166"}
{"text": "This is because the augmentations need to be taken into account when predicting the items that can come next .The present invention can be applied to augmented grammars as discussed above , but the capability is not included in the presently - preferred embodiment .", "label": "", "metadata": {}, "score": "57.455566"}
{"text": "The translations in the lexical entries in the prototype function that follows are translations to CSL 's relational dbms at present .Whenever interfacing to a new target database system , only this portion need be re - written .The lexicon is extensible .", "label": "", "metadata": {}, "score": "57.474854"}
{"text": "The portable spec will be extended to capture more semantic situations .The portable spec is extensible , but changes to it affect both the core grammar and lexicon and the Build Interface mentioned in the next subsection .Some of the planned extensions include : .", "label": "", "metadata": {}, "score": "57.609375"}
{"text": "The method of claim 4 , wherein step ( d ) is done independently from and prior to execution of the natural language menu system .A system for generating a context - free grammar suitable for use as an input to a natural language menu system , comprising : . an input file containing a definition for a domain - independent context - free grammar ; . an input file containing a definition for a domain - independent lexicon ; . a file containing a domain specification which is specific to a preselected application to be run under the natural language menu system ; . a processor coupled to the grammar and lexicon input files and to the domain specification file , wherein the domain specification file is merged with the grammar and lexicon input files to create a domain dependent context free grammar .", "label": "", "metadata": {}, "score": "57.71036"}
{"text": "Core grammar translations to SQL has been prototyped by CSL for DSG .Extensions to handle other aggregate operators like TOTAL , and format specifying operations like ORDERing rows are being added .Subject to prototyping , the grammar of conjunction may change .", "label": "", "metadata": {}, "score": "57.76419"}
{"text": "The most important feature of this procedure is that it can predict the set of possible terminal symbols that could be the nth input item , if it has completed parsing up to the ( n-1)th input item .It is this facility that enables the proper menus and proper items in those menus to be displayed so that the next input item can be chosen from a menu .", "label": "", "metadata": {}, "score": "57.79311"}
{"text": "The grammars and lexicons produced by the MAKE - PORTABLE - INTERFACE function are for use with such a system and would be very inadequate in traditional systems .The principal reason is that they are purposely engineered to be simple , to be expressive , and to provide only a limited set of grammatical and lexical ways of expressing a statement .", "label": "", "metadata": {}, "score": "57.828026"}
{"text": "Some sort of method is needed to construct the grammar .Some sort of database query language must be the target .A big difference between the present invention and what others have done is that the MAKE - PORTABLE - INTERFACE function generates small grammars which are designed for use with a grammar - driven , menu - based system .", "label": "", "metadata": {}, "score": "58.109497"}
{"text": "The process by which an unskilled user constructs a portable specification for a natural language menu interface will now be described with reference to the example shown in FIGS . 1 - 11 .The relevant database must initially be loaded into the system .", "label": "", "metadata": {}, "score": "58.179817"}
{"text": "A system for interactively generating a natural - language input interface , without any computer - skill programming work being required .A system for interactively generating a natural - language input interface , without any computer - skill programming work being required .", "label": "", "metadata": {}, "score": "58.482075"}
{"text": "One could imagine experts used in other ways as well : a large grammar could be partitioned and experts which were executed for effect could be used to swap from one partition to another .The function .WELL - FORMEDNESS - TEST ( nlmenu - grammar , nlmenu - lexicon ) . invokes a static collection of tests to find bugs in either an automatically generated nlmenu grammar and lexicon pair of a manually - generated one .", "label": "", "metadata": {}, "score": "58.56417"}
{"text": "MENU - BASED , GRAMMAR DRIVEN NATURAL LANGUAGE INTERFACES .The companion application ( simultaneously - filed U.S. patent application Ser .This guarantees grammatical coverage .A \" semantic grammar \" ( a context - free grammar that encodes the semantics of the domain ) ( Burton , 1976 ) is used to guarantee semantic coverge .", "label": "", "metadata": {}, "score": "58.6164"}
{"text": "Descripci\u00f3n .Included is a microfiche appendix of 4 microfiche and 385 frames .BACKGROUND AND SUMMARY OF THE INVENTION .The present invention relates to a system for user - customizing a natural language menu command system .In general , the task of writing a natural language interface to some target computer system involves writing a natural language grammar and a corresponding lexicon and a set of semantic translations to the target system .", "label": "", "metadata": {}, "score": "58.74782"}
{"text": "\" Experience with a Graham - Glanville Style Code Generator \" , Philippe Aigrain , Susan L. Graham , Robert R. Henry , Marshall Kirk McKusick and Eduardo Pelegri - Llopart , ACM SIGPLAN Symposium on Compiler Construction , June 1984 . \"", "label": "", "metadata": {}, "score": "58.764942"}
{"text": "In order to do this , the parser must be able to begin parsing as soon as the first word or phrase is input .It can not , as the parsers which have generally been employed in prior art natural language understanding systems do , wait until the entire sentence is input before it begins to parse .", "label": "", "metadata": {}, "score": "58.864975"}
{"text": "Formally , a PORTABLE SPEC is described as follows : .In the appendix are included the BUILD - INTERFACE nlmenu grammar , lexicon , window descriptions , and expert definitions that precisely define the current prototype BUILD interfaces interface .The lexical entries contain help text that describes the meaning of the commands and categories like TABLE JOINS , etc .", "label": "", "metadata": {}, "score": "58.99993"}
{"text": "So , for our system , the sacrifice is not very great .Additionally , a parser that could process input using augmented context - free grammars would necessarily be slower than the parser we employ .Thus , this \" sacrifice \" actually results in our system being able to parse faster .", "label": "", "metadata": {}, "score": "59.00895"}
{"text": "Their technique has come to be known as Graham - Glanville code generation : . \"A New Method For Compiler Code Generation \" , R. Steven Glanville and Susan L. Graham , Fifth ACM Symposium on Principles of Programming Languages , 1978 . \"", "label": "", "metadata": {}, "score": "59.077484"}
{"text": "The parser now has two complete verb symbols and it extends , or looks , for states that need a verb that starts at either frame 2 or frame 3 and finds an S that corresponds to both back in state 8 and state 4 .", "label": "", "metadata": {}, "score": "59.40284"}
{"text": "Most natural language interfaces to database systems have been prototypes , built by the research community .The primary application for natural language interfaces has been to natural language database query systems .Some of these prototype systems include the LUNAR system ( Woods et al .", "label": "", "metadata": {}, "score": "59.49237"}
{"text": "So there is no intent to cover more natural language than a domain requires .The MAKE - PORTABLE - INTERFACE function described in this patent is NOT the first and only work in the area of generating interfaces of some kind from descriptions of the data , but its purposes are different , its immplementation is simpler , and it works .", "label": "", "metadata": {}, "score": "59.536537"}
{"text": "The efficiency of the parser makes it applicable to multiple levels of a spoken language system ( e.g. , sentence , word , phoneme , and phone levels ) .( n ) parsing terminal symbols from the current grammar level as start symbols for the next lower grammar level unless at the lowest grammar level ; .", "label": "", "metadata": {}, "score": "59.653267"}
{"text": "Furthermore the processor will output a score of for best sentence explanation at grammar level 0 ( FIG .2 ) , which is the sentence level grammar .After reading the vector of grammars , in the preferred embodiment , the processor will then input an ending frame indicator n. Although this is not required , it makes the algorithm more complete .", "label": "", "metadata": {}, "score": "59.683537"}
{"text": "To parse breadth first and introduce the ability to begin parsing given only one word of the input and these are put on stack alpha .If not other instructions apply and !MORE is on top of stack alpha , the parser must begin to backtrack as described earlier .", "label": "", "metadata": {}, "score": "59.693428"}
{"text": "That is , some users should be permitted to look at , but not to modify , some tables .The system of the presently preferred embodiment includes an access check off table , whereby the person creating the table can define who has access to that table , and for what purposes .", "label": "", "metadata": {}, "score": "59.777184"}
{"text": "Given any beta - gamma pair representing one of the parse paths active n-1 words of the sentence have been input , it is possible to determine the set of words that will allow that state to continue .To to this , look at the topmost symbol on stack beta of the tuple .", "label": "", "metadata": {}, "score": "59.79632"}
{"text": "- 4.5 Concluding remarks .- 5 Parsing with Categorial Grammar in Predictive Normal Form . - 5.1 Introduction . -5.2 Overview of predictive normal form . - 5.3 Source grammar ( G ) . -5.4 Predictive normal form ( G ) . -", "label": "", "metadata": {}, "score": "59.83506"}
{"text": "Score calculation includes the detection of these cycles and propagation of the best scores to the next frame .The algorithm creates no more states than a nonprobilistic chart parser , and remains linear for regular grammars and cubic in the worst case for CFGs .", "label": "", "metadata": {}, "score": "59.889946"}
{"text": "When more than one parser rule can be applied , and/or when more than one rule of the grammar can be applied through parser rule 1 , alternative parsing paths must be followed .Eventually , all of the alternative parsing paths will result in either successful or unseccessful parses .", "label": "", "metadata": {}, "score": "59.935104"}
{"text": "If a parse is found , it is one of possibly many parses for the sentence .In either case , continue on and pursue all other alternative paths by backtracking to the last choice point , picking another applicable rule , and continuing in the manner described earlier .", "label": "", "metadata": {}, "score": "59.976112"}
{"text": "5 is a graph showing the effect of chart parsing by the present invention on pruning .The graph considers time versus logarithmic probability of hypotheses .Each of the dots represent the same hypothesis symbol at times t i and t k .", "label": "", "metadata": {}, "score": "59.99776"}
{"text": "If a target system does not support some important operation like JOIN ( of two tables or files to return another ) , then the interface simply will not support joins .If semantic domains are not supported , then the portable spec can be simplified accordingly .", "label": "", "metadata": {}, "score": "60.05922"}
{"text": "Some commercial systems exist .Larry Harris of Artificial Intelligence Corp , Roger Schank of Cognitive Systems Inc , and Gary Hendrix of Symantec are all marketing natural language interfaces to software systems .Natural language systems are not in wide spread use today for two reasons : current systems are not easy to use nor are they easy to build and maintain .", "label": "", "metadata": {}, "score": "60.092136"}
{"text": "( 2 )Those based on the premise that a user should be allowed to express himself in any way that is natural to him and that the system will make sense of his input .Keyword extraction techniques suffice only in simple applications .", "label": "", "metadata": {}, "score": "60.183556"}
{"text": "The second modification is a mechanism which will allow feature names and values to be assigned to nonterminal nodes .The idea that nonterminal nodes have features associated with them has been implicit in many syntactic analyses which have been proposed .", "label": "", "metadata": {}, "score": "60.248405"}
{"text": "It has been the goal of recent research to make machine understanding of spoken language possible through a tight coupling between speech and natural language systems .The difficulty posed by this coupling lies in trying to integrate statistical speech information with natural language grammars .", "label": "", "metadata": {}, "score": "60.27002"}
{"text": "It will determine whether or not a given string can be parsed into a tree dominated by the specified root node .The following addition is required to enable the parser to produce the parse tree(s ) for the input string .", "label": "", "metadata": {}, "score": "60.322685"}
{"text": "A simplified version of the parser will first be described , and then the modifications which permit word - at - a - time parsing and prediction will be described .The preferred parser can be specified in terms of nonstandard turing machine instructions , as described by Griffiths and Petrick , which operate on the upper elements of an alpha stack and a beta stack in accordance with the current state of the upper elements of the two stacks .", "label": "", "metadata": {}, "score": "60.359528"}
{"text": "Appendix B sets forth a sample database , such as might be provided to the present invention for tranlation into a user - customized interface .This appendix also contains a sample of a portable spec in a generated grammar and lexicon , such as might be generated , by the present invention , from this database .", "label": "", "metadata": {}, "score": "60.375336"}
{"text": "( q ) parsing said start symbols according to the spoken input and grammars to produce observations of said symbols ; and .( r ) explaining the input based on the results of said step of parsing .The method for parsing of claim 25 , wherein a complete state is a state which fully explains a segment of the spoken input .", "label": "", "metadata": {}, "score": "60.476257"}
{"text": "The variable may be used elsewhere to denote the occurence of the same feature set .The preferred embodiment of the present invention is as follows : .INPUT : .A vector of grammars , G , G o , . . .", "label": "", "metadata": {}, "score": "60.607353"}
{"text": "Instead , features will be allowed to take on more than two values .This option was first discussed for syntax in Friedman ( 1973 ) and her paper provides arguments in favor of this approach within a transformational framework .Features values are constrained to be strings of a finite number of concatenated symbols .", "label": "", "metadata": {}, "score": "60.656338"}
{"text": "3A - C show an example demonstrating frame synchronous parsing using probabilities employed by the present invention ; .FIGS .4A - D show an example showing a typical left recursive rule showing rule probabilities correctly computed by the present invention ; and .", "label": "", "metadata": {}, "score": "60.766487"}
{"text": "The probability of parsing this input is the product of all the rule probabilitiesthat are given in portion C of FIG .4 .The trace seen in Portion D of FIG .4 shows the behaviour of the algorithm with these rule probabilities with respect to the input .", "label": "", "metadata": {}, "score": "60.778763"}
{"text": "It can easily be seen from this example that the formal manipulation rules as set forth above translate very simply into programmable operations .For example , the final status of stack beta , in the very last step of the preceding worked - out example , could be easily represented in Lisp by a list formatted , e.g. , as follows : .", "label": "", "metadata": {}, "score": "60.844734"}
{"text": "Even at that time , the question of portability was raised with the question \" How much can we automate the process of changing database environments ? \"( SIGMOD , 1978 ) .Work at SRI : SRI has been an important center for research into natural language interfaces to databases for several years .", "label": "", "metadata": {}, "score": "60.87002"}
{"text": "The foregoing has described the \" build - interface \" function .The \" make - portable - spec \" function will now be discussed .The invention described herein is a component of a grammar - drive , menu - based system .", "label": "", "metadata": {}, "score": "60.877144"}
{"text": "Loosely coupled systems , such as bottom - up systems or word lattice parsers , have produced nominal results , primarily due to time alignment problems .Top - down constraints from CFG 's have been integrated with speech using the Cocke - Younger - Kasami ( CYK ) algorithm , but this algorithm has bad average time complexity ( cubic ) .", "label": "", "metadata": {}, "score": "60.914757"}
{"text": "The significance of this invention is that it makes it possible , for a MUCH broader class of users and applications , to use menu - based natural language interfaces to databases .Natural language interfaces to computer systems are not in common use today for two main reasons : they are difficult to use and expensive to build and maintain .", "label": "", "metadata": {}, "score": "60.945656"}
{"text": "In contrast , for experts , the code is executed and it can do arbitrary things but it must return a pair of values : a phrase to add to the sentence being formed and a translation .Since it should be possible to rubout over experts , expert code should not have side - effects .", "label": "", "metadata": {}, "score": "61.12989"}
{"text": "Translations to languages other than CSL 's dbms are planned ; specifically , an interface to SQL has been demonstrated .Translations from languages other than English can easily be implemented .Changes in the functionality of the core grammar will be reflected by changes in the core lexicon , so this list is open - ended too .", "label": "", "metadata": {}, "score": "61.15977"}
{"text": "It should be noted that the present invention is applicable to constraining natural language inputs in accordance with any system which can be formally represented by a comparable grammar and lexicon .That is , the present invention is not applicable solely to data base query systems , but can be used to generate well - formed executable machine commands in any machine language using natural language input .", "label": "", "metadata": {}, "score": "61.21988"}
{"text": "17 A Broad - Coverage Natural Language Analysis System .- 17.1 Introduction . - 17.2 A syntactic sketch : PEG . -17.3 Semantic readjustment .- 17.4 The paragraph as a discourse unit . -17.5 Concluding remarks .- 18 Parsing 2-Dimensional Language .", "label": "", "metadata": {}, "score": "61.489323"}
{"text": "So the grammar can be small .Unhilighted menus contain all menu choices for the menu category to indicate the scope of the interface to the user at all times .This interface is really a special case of grammar - driven , menu - based interfaces . to ask for a menu - like list of next phrases .", "label": "", "metadata": {}, "score": "61.561188"}
{"text": "Efficient implementation of the algorithm depends on use of some details set out in Earley 's work .Furthermore , inherent throughout the program is a compute function .When finding probabilities for terminal symbols , it is up to the compute step to note cycles and efficiently find the probability of a given state .", "label": "", "metadata": {}, "score": "61.57243"}
{"text": "In this paper , we present TRX : a parser interpreter formally developed in the proof assistant Coq , capable of producing formally correct parsers .We are using parsing expression grammars ( PEGs ) , a formalism essentially representing recursive descent parsing , which we consider an attractive alternative to context - free grammars ( CFGs ) .", "label": "", "metadata": {}, "score": "61.65487"}
{"text": "When the user mouses one of these , he is then presented , in a little window , with a list of the names of specific suppliers , which is gathered from the database in real time .Thus , these non - word items displayed on the menu add a great deal of versatility and user convenes to this system .", "label": "", "metadata": {}, "score": "61.726112"}
{"text": "The ADVANTAGES of this invention are that an end user can construct his own interface knowing nothing about grammars and lexicons so no specialist is required .The process of specifying the parameters to the MAKE - PORTABLE - INTERFACE routine takes minutes , not weeks or months .", "label": "", "metadata": {}, "score": "61.729515"}
{"text": "Not popular terminology , but if it is used it would correspond to an N - tuple or row .Tag : Not current terminology .This section describes a manually built nlmenu interface in which a user is guided to build and maintain other nlmenu interfaces .", "label": "", "metadata": {}, "score": "61.760727"}
{"text": "In addition , the test can be used as follows : One of the values returned by WELL - FORMEDNESS - TEST ( grammar , nil ) is a list of all lexical categories that the grammar writer must write lexical entries for .", "label": "", "metadata": {}, "score": "61.844406"}
{"text": "- 3 Parsing with Lexicalized Tree Adjoining Grammar . - 3.1 Introduction . - 3.2 Lexicalization of CFGs . - 3.3 Lexicalized TAGs . - 3.4 Parsing lexicalized TAGs . - 3.5 Concluding remarks .- 4 Parsing with Discontinuous Phrase Structure Grammar . - 4.1 Introduction . - 4.2 Trees with discontinuities .", "label": "", "metadata": {}, "score": "62.040413"}
{"text": "It is also possible for experts to be executed only for effect , to set the stage for a later expert , say .In the BUILD INTERFACEs NLMENU interface , both the MODIFY and the CREATE lexical entries are experts which initialize some global variables whose values are used later in the command by other experts .", "label": "", "metadata": {}, "score": "62.263348"}
{"text": "In turn , the features of these nodes could be determined by their mother node , daughter nodes , or sister nodes .This in effect means that information from anywhere in the tree can be transmitted to the nodes which determine the features of Nom1 .", "label": "", "metadata": {}, "score": "62.460335"}
{"text": "Thus , after inputting the nth word , a complete parse up to that word has been performed .For the parser to proceed in a breadth - first manner , it is only given the first word of the input string .", "label": "", "metadata": {}, "score": "62.48166"}
{"text": "Firstly , lexical items ( terminal nodes ) will have syntactic features associated with them .This idea is not new ( see , for example , Chomsky ( 1965 ) ) .In general , the values of syntactic features have been thought to be binary .", "label": "", "metadata": {}, "score": "62.534454"}
{"text": "The Lisp code ( Lisp machine ) for the parser and for the construction and manipulation of the menus is included in the Appendices below .The grammar which characterizes the allowed queries to the database is also included .The items displayed on the menu to the user , and which can be selected by the user , need not be only words or phrases .", "label": "", "metadata": {}, "score": "62.69622"}
{"text": "The algorithm is closely related to head - driven generators as discussed in the previous chapter .The algorithm proceeds in a bottom - up , head - driven fashion , which provides for bottom - up and top - down filtering in a simple and straightforward way .", "label": "", "metadata": {}, "score": "62.796455"}
{"text": "Add support for semantic domains , fixed value ranges ( as in ( January , 111 , December ) , domain ordering predicates , domain tests , default values , .Add user titles for column headings , so descriptive headings are used instead of short fixed length names that are required for some existing databases .", "label": "", "metadata": {}, "score": "62.805096"}
{"text": "APPENDICES .The description of the invention incorporates the following appendices : .Appendix A is a listing of the actual code which is used , in the presently preferred embodiment of the present invention , on an LMI Lisp Michine .", "label": "", "metadata": {}, "score": "62.82528"}
{"text": "( The relational tables can be real or virtual , i.e. recreated ad hoc from existing tables . )First , the user is offered a selection of functions which can be performed , such as create interface , drop interface , grant access to interface , etc .", "label": "", "metadata": {}, "score": "62.93683"}
{"text": "In addition , the use of experts does not affect the final translation of the natural language input into machine commands , since each expert concludes its function and retires immediately before the next word is selected .In addition , where a very large number of items can be chosen from next , an expert can be used to display subcategories of the possible next items .", "label": "", "metadata": {}, "score": "63.174343"}
{"text": "( t ) after step ( k ) , incrementing a frame counter .The method for parsing of claim 25 , wherein said state sets are 1 rows corresponding to the number of grammar levels and N columns corresponding to the number of input frames of speech .", "label": "", "metadata": {}, "score": "63.34503"}
{"text": "According to the present invention , there is provided : .A system for generating a user customized natural language menu interface from a database supplied by the user and from inputs supplied interactively by a user , comprising : . display means for showing to a user expert a menu of options ; . input means , for moving a cursor 's apparent position on said display means by the action of said user ; . means for receiving a database ; . means for displaying on said display means a generalized relation between two or more tables in said database , with generalized indications of corresponding natural - language connecting phrases ; and .", "label": "", "metadata": {}, "score": "63.458252"}
{"text": "When the values of the features of the two nodes for which reachability matrix information is required are known , they are plugged into this equation .The result of this equation will be either true or false indicating reachability .A sacrifice has been made to achieve this 0 % failure rate , however .", "label": "", "metadata": {}, "score": "63.664192"}
{"text": "( n ) scanning observations from said next lower grammar level into waiting states of said current grammar level ; .( i ) repeating steps ( h ) through ( n ) until no new states can be completed ; .", "label": "", "metadata": {}, "score": "63.942806"}
{"text": "Returning again to FIG .2 , the processor looks at the inputted grammar and sees that there is a symbol , say S , that corresponds to a sentence .The processor proceeds to the parse function , does the prediction and completion , and finds out that it needs some words which are terminal symbols in the sentence grammar level .", "label": "", "metadata": {}, "score": "63.978584"}
{"text": "Thus , the presently preferred embodiment uses a modification of this parser , as will now be set forth .For consistency with the published literature , the formalism of the parser will now trivally be altered .A 3-stack informal turing machine formalism will now be used , which differs slightly from the previous format in that the incomplete parse trees which were formerly held below the place holding symbol \" t \" in stack beta will now be held separately in a gamma stack .", "label": "", "metadata": {}, "score": "63.985153"}
{"text": "Autore : Dennis Grinberg ; John D Lafferty ; Daniel D Sleator .Editore : Pittsburgh , Pa. : School of Computer Science , Carnegie Mellon University , [ 1995 ] . OCLC:33830907 .I termini ReCaptcha inseriti non sono corretti .", "label": "", "metadata": {}, "score": "64.03111"}
{"text": "The meaning of these commands is as follows .The quoted text that follows is the TUTORIAL text taken from the BUILD INTERFACEs interface .TUTORIAL ON CREATING , MODIFYING , SHARING , AND DROPPING NLMENU INTERFACES .Using BUILD INTERFACES , a user can do the following operations : .", "label": "", "metadata": {}, "score": "64.06911"}
{"text": "Next , I define , as an example of such a grammar , a simple grammar for Dutch , in which strings are combined by a technique quite similar to Pollard 's head wrapping .The main part of the chapter is section 4.4 , in which a parsing strategy for linear and non - erasing grammars is proposed .", "label": "", "metadata": {}, "score": "64.27013"}
{"text": "For example , a further embodiment of the present invention , which is presently under development , realizes the present invention on a Texas Instruments Professional Computer , instructed by source code which is written in \" C \" .It should also be noted that the particular parser used in the preferred embodiment is not necessary to the invention , but other parsers can be used .", "label": "", "metadata": {}, "score": "64.31197"}
{"text": "( p ) scanning observations from said next lower grammar level into waiting states of said current grammar level ; .( q ) repeating steps ( j ) through ( p ) until no new states can be completed ; .", "label": "", "metadata": {}, "score": "64.38743"}
{"text": "To determine all the words that can come next , given that goal , the set of all nodes that are reachable from that node as a left daughter must be determined .Fortunately , this information is easily obtainable from the reachability matrix discussed earlier .", "label": "", "metadata": {}, "score": "64.53752"}
{"text": "The function takes a data structure of parameters called a PORTABLE SPEC as its argument and returns a semantic grammar and a corresponding semantic lexicon .An NLMENU - driven system need not include this component .The component adds the functionality to a grammar - driven , menu - based system that makes it easy for a user to build his own natural language interfaces to databases .", "label": "", "metadata": {}, "score": "64.61058"}
{"text": "3 labeled B discloses a word lattice , which is the input to the system ( in this example ) showing the beginning and ending frames of each of the word hypotheses .The lattice contains a plurality of lines which show the logarithmic probability of seeing a particular word over a particular span of data and gives such probability as a negative number .", "label": "", "metadata": {}, "score": "64.75075"}
{"text": "The Rendezvous prototype natural language interface to a database uses much the same kind of information as the SRI and TI systems .The information about database structure is stored in data structures that describe both database structural information and linguistic information .", "label": "", "metadata": {}, "score": "64.84137"}
{"text": "The present invention then enables the chart processor to predict all start symbols and parse for all input frames .The parse function requires that the processor alternately repeat a predict function and a complete function until no new states can be added .", "label": "", "metadata": {}, "score": "64.89292"}
{"text": "DESCRIPTION OF THE PREFERRED EMBODIMENTS .The invention provides a means of generating a semantic grammar and a semantic lexicon from a condensed collection of parameters .The basic operation of the natural language menu interface system will first be described , and then the features of the present invention , which permit very rapid construction of a user - customized implementation of such a natural language interface system , will then be described .", "label": "", "metadata": {}, "score": "64.900665"}
{"text": "( s ) between steps ( d ) and ( e ) , reading an ending frame indicator ; and .( t ) after step ( n ) , incrementing a frame counter .The method for parsing of claim 25 , further comprising the steps of : .", "label": "", "metadata": {}, "score": "65.12056"}
{"text": "means for integrating said relations interactively selected by said user into a portable specification for natural - language - menu interface , and forstoring said portable specification .BRIEF DESCRIPTION OF THE DRAWINGS .The present invention will be discussed with reference to the accompanying drawings , wherein : .", "label": "", "metadata": {}, "score": "65.1599"}
{"text": "# # STR78 # # .To see why this is so , note that the meaning of the subtree VP would be the result of applying the meaning of the V to the meaning of the NP because of the rule ( 1 2 ) .", "label": "", "metadata": {}, "score": "65.17253"}
{"text": "We have not yet completed a formal proof that the software is correct , since details of the embodiment will affect such a proof and the embodiment is subject to modifications as explained below .Such a proof goes something like this : covered functionality in target language ( SQL or LMRDBAAS ) is identified and then natural language constructions are identified that translate to those identified target functions .", "label": "", "metadata": {}, "score": "65.183495"}
{"text": "In lisp : . it finds the following problems : .In lisp : .In lisp : .In lisp : . in lisp : .The significance of the WELL - FORMEDNESS - TEST is as follows : As simple as these tests are , I know of no other system that employs such static tests to see if the grammar is well - formed .", "label": "", "metadata": {}, "score": "65.25466"}
{"text": "( g ) predicting initial and final probabilities for a current frame for each start symbol of grammar ; .( h ) predicting a valid next nonterminal symbol to thereby create at least one state from its corresponding at least one rule according to said at least one grammar ; .", "label": "", "metadata": {}, "score": "65.29293"}
{"text": "The method for recognizing spoken sentences of claim 1 , wherein said state sets are 1 rows corresponding to the number of grammar levels and N columns correspondong to the number of input frames of speech .The method for recognizing spoken sentences of claim 1 , wherein said grammar is a stochastic unification grammar .", "label": "", "metadata": {}, "score": "65.39114"}
{"text": "A system for generating a user customized natural language menu interface from a database supplied by the user and from inputs supplied interactively by a user , comprising : . display means for showing to a user expert a menu of options ; . input means coupled to said display means , for moving a cursor 's apparent position on said display means by the action of said user ; . means for the system to access said data base ; . means for displaying on said displaying means a generalized relation between two or more tables in said database , with generalized indications of corresponding natural - language connecting phrases ; . means for interactively receiving from said user a plurality of said relations between tables in said database , together with natural - language connecting phrases corresponding to said relations between tables and said database ; and .", "label": "", "metadata": {}, "score": "65.41216"}
{"text": "- 6 PREMO : Parsing by conspicuous lexical consumption . - 6.1 Introduction . - 6.2 The preference machine . - 6.3 Global data . -6.4 Preference semantics .- 6.5 PREMO example . - 6.6 Comparison to other work . -", "label": "", "metadata": {}, "score": "65.45891"}
{"text": "Then we will briefly discuss menu - based grammar - driven interfaces .Then we will relate these to the invention and discuss known prior art as it concerns automatically generating interfaces to a database .INTRODUCTION .Natural language interfaces to software fall into two categories : ( 1 ) those based on pseudo - English , where a user must learn a command language that is English - like .", "label": "", "metadata": {}, "score": "65.47387"}
{"text": "The process of taking a sentence and determining whether it is grammatical , given a grammar , is called parsing .The result of parsing a sentence is one or more parse trees if the input is a valid sentence .If the input is not a sentence , parsing produces no parse trees .", "label": "", "metadata": {}, "score": "65.794754"}
{"text": "Then we describe function MAKE - SEMANTIC - GRAMMAR .Finally , we describe the function MAKE - SEMANTIC - LEXICON .It is important to note initially that there is no assumption about who specifies the parameters to the function .", "label": "", "metadata": {}, "score": "65.889175"}
{"text": "A pointing device ( or selection from a keyboard ) is used to make the selections of completing phrases from a menu or menus .So an NLMENU - driven interface answers the set of objections to natural language interfaces that involve \" ease of use \" of the interface .", "label": "", "metadata": {}, "score": "65.90062"}
{"text": "Partial inputs from the user are successfully parsed , and the parser indicates all possible legal next entries which could follow the input received so far from the user .The set of legal next words is then displayed to the user as active portions of the menu , so that the user need only select one of the legal next words from the menu .", "label": "", "metadata": {}, "score": "65.91705"}
{"text": "HMM grammars have reference vectors symbols corresponding to reference vectors as their terminal symbols .The processor then scores these reference vectors and gets probabilities for the frame and returns those as observations to the next higher level .Those observations are scanned into that next higher level .", "label": "", "metadata": {}, "score": "65.96036"}
{"text": "The modified algorithm uses the notion of a null link in order to allow a connection between any pair of adjacent words , regardless of their dictionary definitions .The algorithm proceeds by making three dynamic programming passes .In the first pass , the input is parsed using the original algorithm which enforces the constraints on links to ensure grammaticality .", "label": "", "metadata": {}, "score": "66.15471"}
{"text": "The present invention assigns probabilities to the hypotheses that it next wants to explore .It also employs a beam pruning technique , well - known in the art , and a delayed commitment in the score caluclation to determine the most probable correct response ( speech recognition ) .", "label": "", "metadata": {}, "score": "66.160385"}
{"text": "The LOGICAL VIEW of a database can consist of a set of two dimensional tables .Physically , these tables might actually be represented in a hierarchy or network structure , since those structures are often more efficient .DATA INDEPENDENCE is the property of a database system whereby the logical view of data stays the same even when the physical view is changed .", "label": "", "metadata": {}, "score": "66.214066"}
{"text": "An ending frame n. .OUTPUT : .A matrix of state sets E , 1 rows and n columns . , the best score for S of G o .METHOD : .Make E l , o empty for all l. .", "label": "", "metadata": {}, "score": "66.34001"}
{"text": "However , the presently - preferred embodiment uses a parser which will be described in great detail .As discussed above , the end result which the present invention seeks to achieve is to permit the user to input well - understood sentences in a convenient language , which is preferably a subset of a natural language ( such as English ) .", "label": "", "metadata": {}, "score": "66.36522"}
{"text": "Explanations of each of those different functions are given below .Further assume all symbols are at level 1 unless otherwise indicated .If B 1 and B 2 are atomic symbols for context - free grammars , then they are unified by default .", "label": "", "metadata": {}, "score": "66.373566"}
{"text": "Efforts taking from 10 to 30 man - years per application are not uncommon .Thus , only applications that can justify such large expenditure of manpower are candidate for possible applications .However , given the quality of the system that results , the effort has not proven to be worthwhile .", "label": "", "metadata": {}, "score": "66.4693"}
{"text": "Furthermore , heads carry the features associated with the construction as a whole ( such as case , agreement ) .Given the importance of the notion ' head ' , it is sensible to start with the head , in order to know what else you have to look for next .", "label": "", "metadata": {}, "score": "66.50906"}
{"text": "At this point the \" using \" command is used to introduce the \" ( cover table ) \" expert .This first critically important operation lets the user specify which of the tables in the available database are to be used .", "label": "", "metadata": {}, "score": "66.51892"}
{"text": "The elimination of the second class of rules causes no difficulty and does not impair a grammar writer in any way .The elimination of the first class of rules causes a small inconvenience in that it prevents grammar writers from using the existence of null nodes in parse trees to account for certain unbounded dependencies like those found in questions like \" Who do you think I saw ? \" which are said in some linguistic theories to contain a null noun phrase after the word \" saw \" .", "label": "", "metadata": {}, "score": "66.53592"}
{"text": "Language modeling has become an essential element in high performance , speaker - independent , continuous speech systems .Until recently , speech recognition systems have primarily used Finite State Automatons ( FSAs ) as the language model .These models offer efficient processing , easily accommodate observation probabilities , and permit simple training techniques to produce transition probabilities .", "label": "", "metadata": {}, "score": "66.61516"}
{"text": "This translation is a portion of the meaning of a sentence in which the word appears .In order to properly combine the translations of the words in a sentence together , there is a rule associated with each context - free rule indicating the order in which the translations of the symbols on the right side of the arrow of a context - free rule are to be combined .", "label": "", "metadata": {}, "score": "66.849266"}
{"text": "Since the processor is at a terminal symbol , it can then perform this algorithm because all states have been predicted and completed and there is no more information available to enable it to predict or complete any more states .The processor will predict at level 1 + 1 , which is the next lower level .", "label": "", "metadata": {}, "score": "66.885"}
{"text": "is put on stack gamma . \" indicates that there are no contents to the stack . ) , V2 . . .Vn t X , A Y ) ( 1 ) .Briefly , the reachability matrix excludes impossible word sequences , such as \" the the \" , among other things .", "label": "", "metadata": {}, "score": "66.88531"}
{"text": "ADVANTAGES AND SACRIFICES .Listed below are 5 advantages and one sacrifice .The first advantage is that an end user can easity build and maintain his own natural language interfaces covering his own application domain .A portable - spec is a straightforward data structure and it is no harder to build one than it is to create the set of relations in the first place ( and this is an easy process in modern relational databases ) .", "label": "", "metadata": {}, "score": "66.9547"}
{"text": "La tua lista ha raggiunto il numero massimo di documenti .Si prega di creare una nuova lista con un nuovo nome ; sposta alcuni documenti su una lista gi\u00e0 esistente o su un nuova , oppure cancella alcuni documenti .Abstract : \" In this paper we present a robust parsing algorithm based on the link grammar formalism for parsing natural languages .", "label": "", "metadata": {}, "score": "67.001785"}
{"text": "Parsing then begins again with one parser state for each beta - gamma pair .This procedure is repeated until there are no more words in the input string .This function will be described in slightly more detail .To do this , a depth - first control structure must be described first .", "label": "", "metadata": {}, "score": "67.003876"}
{"text": "This means that the feature values of the nodes of any subtree can only depend on the feature values within that subtree .This is accomplished by restricting feature percolation rules so that features will only percolate up the tree , not down .", "label": "", "metadata": {}, "score": "67.13346"}
{"text": "These check the features of nodes and filter out ill - formed structures based on the values of these features .These rules are called feature blocking rules and will be written as conditions on the values of the features of the nodes to the right of the arrow .", "label": "", "metadata": {}, "score": "67.18988"}
{"text": "18.2 The 2D - Earley parsing algorithm . -18.3 The 2D - LR parsing algorithm .- 18.4 More interesting 2D grammars .- 18.5 Formal property of 2D - CFG .- 18.6 Concluding remarks .Parsing in Dialogue Systems using Typed Feature Structures .", "label": "", "metadata": {}, "score": "67.32379"}
{"text": "Specific HELP is available on each of these operations using ( ( the HELP key ) ) .Using the BUILD INTERFACES CREATE or MODIFY commands , a user can specify all the parameters he needs to create a new natural language interface .", "label": "", "metadata": {}, "score": "67.395874"}
{"text": "METHOD : .Repeat the following two steps until no new states can be added : .( a ) Predict .( b ) Complete .Hypothesize .Scan .Repeat the following two steps until no new states can be added : .", "label": "", "metadata": {}, "score": "67.41852"}
{"text": "The actual words , also called atoms , are defined elsewhere , such as in a knowledge base .The grammar and lexicon , taken together , can be compiled without reference to a particular domain .The result is to define a spoken language reference which can be a fairly complex subset of a language .", "label": "", "metadata": {}, "score": "67.48408"}
{"text": "In ( Hendrix and Lewis , 1981 ) , the authors describe TED , a prototype system for creating new domains for natural language systems without the need for specially trained experts .Hendrix described a dialogue in which information ( like some of that found in the portable spec ) is elicited from a user .", "label": "", "metadata": {}, "score": "67.50604"}
{"text": "3 , an example of frame synchronous parsing using probabilities is demonstrated .In the portion labeled A , a simple grammar is given which consists of one rule , namely sentence rewrites to a noun and a verb .One noun \" boys \" and two verbs \" sleep \" and \" leap \" are given .", "label": "", "metadata": {}, "score": "67.56909"}
{"text": "What is significant about this interface is : . it provides an interactive means of eliciting the information needed to create a portable spec from a user .Menus are tailored to the particular user and only show him tables he owns , attributes associated with those tables , etc , so he can not err .", "label": "", "metadata": {}, "score": "67.66994"}
{"text": "- 11.2 Context - free parsing . - 11.3 Horn clauses . - 11.4 Other linguistic formalisms .-11.5 Concluding remarks .-12 A Method for Disjunctive Constraint Satisfaction . - 12.1 Introduction .- 12.2 Turning disjunctions into contexted constraints . -", "label": "", "metadata": {}, "score": "67.75418"}
{"text": "If the processor is not on the bottom level , then it will predict the terminal symbols at the next lower level and proceed to parse .The processor will scan observations from a lower grammar level into the current grammar level .", "label": "", "metadata": {}, "score": "67.87673"}
{"text": "FUNCTION MAKE - SEMANTIC GRAMMAR .Formally , .It is important to note that while a semantic grammer is produced , this description does not really suggest a specific data structure for the grammar .Possibilities include a list of grammar rules and translations , a pointer to a file where the semantic grammar that was produced now resides in some format , or a database relation GRAMMARS with components : ( OWNER , INTERFACE - NAME , RULE , TRANSLATION ) .", "label": "", "metadata": {}, "score": "67.90819"}
{"text": "The reachability matrix indicates whether X can dominate A where A is on a left branch .The reachability conditions are satisfied if X can dominate A in this configuration .The reachability matrix is a Boolean matrix , which contains a logical value for each pair of nodes ( N , M ) in the grammar to indicate whether any legal parse tree could have node N as a leftmost daughter of node M. This matrix is then multiplied by itself repeatedly , until it stabilizes , that is until further multiplication of the final matrix by the immediate reachability matrix produces no further change in the final matrix .", "label": "", "metadata": {}, "score": "68.090836"}
{"text": "( c ) inputting a lexicon having entries for defining terminal symbols of said at least one grammar in terms of linguistic , syntactic or semantic features ; .( d ) generating a matrix of state sets ; .( e ) initializing said state sets ; .", "label": "", "metadata": {}, "score": "68.21748"}
{"text": "The final pass counts the total number of parses with minimal cost .All of the original pruning techniques have natural counterparts in the robust algorithm .When used together with memoization [ sic ] , these techniques enable the algorithm to run efficiently with cubic worst - case complexity .", "label": "", "metadata": {}, "score": "68.30424"}
{"text": "Instead all of the constraints are in the experts . ) it provides a way to modify an interface ( to correct errors or add new tables ) .it provides a way for a user who owns an interface to edit the menu items by pointing to them in \" edit item mode \" and type in replacements .", "label": "", "metadata": {}, "score": "68.38965"}
{"text": "The symbol \" t \" is merely a placeholding symbol , which is used in this formalism to permit proper application of the succeeding parser rules .Where an element is associated beneath another element , this provides one step in building up the tree of associated nodes which will eventually form a complete parse .", "label": "", "metadata": {}, "score": "68.526924"}
{"text": "The algorithm proceeds by making three dynamic programming passes .In the first pass , the input is parsed using the original algorithm which enforces the constraints on links to ensure grammaticality .In the second pass , the total cost of each substring of words is computed , where cost is determined by the number of null links necessary to parse the substring .", "label": "", "metadata": {}, "score": "68.59578"}
{"text": "The processor then loops down to the bottom level , advances as many states as possible and then returns to parse .This shows a mutually recursive relationship between hypothesize and parse .rh o.+(\u03c3.sub.\u03bf -\u03c3 ) ] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ .", "label": "", "metadata": {}, "score": "68.66507"}
{"text": "These define what interfaction takes place when a user chooses ( specific tablename - attributename from the EXPERTS menu .EDITED - ITEMS -- the owner of an interface may edit the phrasing of menu items .The system keeps track of the original and new phrasing .", "label": "", "metadata": {}, "score": "68.87136"}
{"text": "Associated with each phrase structure rule , there is a set of rules which indicates how to pass the features around .These will be referred to as feature percolation rules .Once a feature value is assigned for a particular node , it does not change .", "label": "", "metadata": {}, "score": "68.98036"}
{"text": "Add support for transitive closures as in \" find all managers and their managers and so on \" .Add a define facility so one can say Define--(moun type in)--TO BE--(NP ) as in Define -- old employee -- TO BE -- employees whose age is greater than 65 .", "label": "", "metadata": {}, "score": "69.11515"}
{"text": "It should be noted , however , that the frame counter may be incremented at other times during the execution of the algorithm depending on how one wants to keep track of the frames .At this point , either the states are complete or are reported as observations to the next higher grammar level .", "label": "", "metadata": {}, "score": "69.136505"}
{"text": "This rule means that the translation of A is taken as a function and applied to the translation of B as its argument .This resulting new translation is then taken as a function and applied to the translation of 4 as its argument .", "label": "", "metadata": {}, "score": "69.22949"}
{"text": "it guarantees that the user can only construct interfaces with tables he owns or has been granted access to .it provides a means for sharing interfaces between users using GRANT or REVOKE .Both the MODE OF OPERATION of this interface ( highly interactive , window and menu oriented , nlmenu compatible so that it uses the same nlmenu driver as do the nlmenu natural langauge interfaces ) AND the FUNCTIONALITY of this interface are NOVEL .", "label": "", "metadata": {}, "score": "69.32042"}
{"text": "( Such grammars are known in the art as \" semantic grammars \" . )For convenience , we restate parser rule 1 again : .The second rule of the parser shows how the place holding symbol t is used to indicate that a perfected partial parse can be transferred from stack beta to stack alpha : .", "label": "", "metadata": {}, "score": "69.44784"}
{"text": "This section is very similar to the previous section with regard to how out and inner loops and substitution lists instantiate forms .Here each form being substituted into results in a LEXICAL ENTRY consisting of a 4-tuple with fields ( category , menu - item , menu - window , translation ) .", "label": "", "metadata": {}, "score": "69.68062"}
{"text": "In general , the translation of leftmost number applies to the translation of the number to its right as the argument .The result of this then is a function which applies to the translation of the item to its right as the argument .", "label": "", "metadata": {}, "score": "69.74624"}
{"text": "So a user might than choose from a menu of all suplier names in the database .The menu phrase is of the form \" x \" or \" x or y \" or \" x , y , . . .", "label": "", "metadata": {}, "score": "69.85386"}
{"text": "z ) .type - in experts , which get the user to type names , filenames , dates , integers , . . . .menu - based popup experts that allow the user to specify dates , units experts ( 1000 feet ) , and range experts ( male or female ) .", "label": "", "metadata": {}, "score": "70.1042"}
{"text": "A common difficulty with well - used databases is that they accumulate a huge number of unrelated data tables , and a process which in effect permits selection of a subset of related tables from the whole database provides substantial processing economies .", "label": "", "metadata": {}, "score": "70.14436"}
{"text": "The pragmatic grammar differs from a semantic grammar in that it contains slots ( variable or procedures ) that the information in the data structure fills .His stated intent is to use Jane Robinson 's large grammar DIAGRAM ( Robinson , 1982 ) for his pragmatic grammar .", "label": "", "metadata": {}, "score": "70.17035"}
{"text": "This is done by running through all rules and compiling a list .This process ( highlighted menu , user selection , parse , new highlighted menu ) is then continued , until the user indicates that he is finished with the sentence which he wishes to input .", "label": "", "metadata": {}, "score": "70.17308"}
{"text": "A PORTABLE SPEC contains all the information necessary to specify a complete user interface .Specific HELP is available on many of these categories using ( ( the HELP key ) ) .The categories are as follows : .TABLES -- the set of relations or views that the interface covers .", "label": "", "metadata": {}, "score": "70.18558"}
{"text": "- 7 Parsing , Word Associations , and Typical Predicate - Argument Relations . - 7.1 Mutual information . - 7.2 Phrasal verbs . -7.3 Preprocessing the corpus with a part of speech tagger .- 7.4 Preprocessing with a syntactic parser .", "label": "", "metadata": {}, "score": "70.48633"}
{"text": "The method for parsing of claim 25 , wherein said grammar incorporates stochastic unification grammars .The method of parsing of claim 25 , wherein said probability score for said completed state is the probability for completing states in the state set using already complete states in the state sets .", "label": "", "metadata": {}, "score": "70.656494"}
{"text": "For example , if a peripheral system accessory included electronic output from a scale , an expert item in a parts database could be indicated as \" ( specific weight read from scale # 7 ) \" .As noted , the presently preferred method of user presentation is a CRT screen , on which the various menus are displayed , together with a mouse which moves a curser on the screen .", "label": "", "metadata": {}, "score": "70.66017"}
{"text": "Once all backtracking is completed , the next word , followed by !MORE , is put on alpha and parsing begins again with a set of states , each containing the new input word on alpha an done of the saved tuples containing beta and gamma .", "label": "", "metadata": {}, "score": "70.69989"}
{"text": "Once it has a complete noun from frame 0 to frame 2 , it checks if there are any symbols that ended at zero that needed a noun that it can complete and finds there was one starting with S in the very first state .", "label": "", "metadata": {}, "score": "70.76582"}
{"text": "the interface will be error free .the interface can be treated as a database object and granted to other users who can then use the natural language to access their data .Thus , it is object of the present invention to provide a method for rapidly instructing a natural - language menu interface system which is customized according to a particular users needs .", "label": "", "metadata": {}, "score": "70.95123"}
{"text": "They are hard to debug .And there is no established way to guarantee that they cover the desired data or fit the functionality of the target computer system .So , using existing technology , natural language interfaces to databases will be built only for important database applications .", "label": "", "metadata": {}, "score": "70.98889"}
{"text": "In this case , the nodes below the S on the alpha stack provide the desired complete parse .If the root node ( i.e. the object of the parsing ) is not a sentence parse , but , for example , a noun phrase parse , then the condition indicating a successful parse would be correspondingly different , e.g. ( NP # , NP # ) .", "label": "", "metadata": {}, "score": "71.235275"}
{"text": "To do this , apply one of the rules that are applicable , get a new state , and then apply one of the applicable rules to that new state .Continue this until either no rules apply or no parse is found .", "label": "", "metadata": {}, "score": "71.30036"}
{"text": "3-way - joins -- a specification of \" relationships \" where one .2-way - joins -- specification of supported joins .The portable spec categories are not unrelated .The following integrity constraints hold : . the relations list can be deduced from the non - numeric and numeric attributes lists .", "label": "", "metadata": {}, "score": "71.3497"}
{"text": "the attributes list can be deduced from the non - numeric and numeric attribtes lists .the attributes mentioned associated with a relation should really be associated with that relation in the described database .The following routines do not verify that these integrity constraints hold though they could easily be modified to do so .", "label": "", "metadata": {}, "score": "71.3676"}
{"text": "Usually , this will include the key attributes but it may also include non - key attributes .TWO TABLE JOINS -- a specification of supported joins involving two table THREE .TABLE JOINS -- a specification of \" relationships \" where one table relates two others .", "label": "", "metadata": {}, "score": "71.553986"}
{"text": "Thus , the end result of the operation , after the user has input a complete sentence , is a parsed command which is in accordance with the predefined grammar , and therefore can be trivially translated into an executable instruction , as will be discussed below .", "label": "", "metadata": {}, "score": "71.579445"}
{"text": "The fourth advantage is that the interface will be bug free if the portable spec is well - formed syntactically and semantically .If specified relations really are tables in the database and numeric attributes really name attributes with numeric domains , etc , hen the spec refers to a real database and the grammar and lexicon resulting from the MAKE - PORTABLE - SPEC function will define a bug - free interface .", "label": "", "metadata": {}, "score": "71.60142"}
{"text": "It should be noted that even somewhat awkward locutions , when they appear in a menu for selection , will be clearer .Thus , for example , if a user has entered \" find pitchers \" and the menu of active items includes \" whose pitcher - ERA is \" , their relation is easily understood .", "label": "", "metadata": {}, "score": "71.97996"}
{"text": "1 , an input device 10 receives input from a user and transmits the input along connecting element 12 to processor 14 .Processor 14 contains a central data structure , known as a chart 24 , not shown , where the algorithm is implemented .", "label": "", "metadata": {}, "score": "72.05397"}
{"text": "The system for recognizing a spoken sentence of claim 11 , wherein said processing means includes an input means for recording spoken words and an acoustic device for tranforming spoken words into a medium readable by said processing means .The system for recognizing a spoken sentence of claim 11 , wherein said processing means is coupled to a translating means adapted to receive spoken input and transform said input into a medium readable by said processing means .", "label": "", "metadata": {}, "score": "72.19261"}
{"text": "And it is hard to find all such bugs by hand .One might forget to define some lexical categories , or define ( misspell ) categories that the grammar ca n't access .Or one might write rules such that the left hand side is not accessible from the root .", "label": "", "metadata": {}, "score": "72.25102"}
{"text": "The system for recognizing a spoken sentence of claim 11 , further comprising a knowledge base for supplying symbols , wherein said predictor is coupled to said knowledge base .The system for recognizing a spoken sentence of claim 11 , wherein said language model incorporates stochastic unification grammars .", "label": "", "metadata": {}, "score": "72.27541"}
{"text": "The involvement in NLP research in the Institute of information Technologies - BAS is tightly connected to the basic research topics at the Artificial Intelligence Department - Knowledge Representation and Logic Programming .It has begun a few years ago with the development of the Net - Clause Language ( NCL ) .", "label": "", "metadata": {}, "score": "72.29642"}
{"text": "The tree in portion B reflects the desired outcome of this parse .The tree shows that to recognize this input the parser has to use a left recursive rule two times and the non - left recursive S choice , which is S goes to C , once at the bottom .", "label": "", "metadata": {}, "score": "72.355675"}
{"text": "The categories are as follows : . relations -- the set of relations ( including views ) covered .non - numeric - attibutes -- for each relation , the attributes to be included in the iterface that come from non - numeric domains .", "label": "", "metadata": {}, "score": "72.36481"}
{"text": "LIST INTERFACES -- see the interfaces the user owns or has been granted .SHOW PORTABLE SPEC -- see a portable spec , the data structure from which a NL interface is generated ( see below ) .CREATE INTERFACE -- create a new interface ( a new portable spec ) .", "label": "", "metadata": {}, "score": "72.788795"}
{"text": "The two noun hypotheses ( \" boys \" from frame 0 to frame 2 and \" boys \" from frame 0 to frame 3 ) are non - intersecting hypotheses since they have different stop times , and therefore remain separate .", "label": "", "metadata": {}, "score": "72.96779"}
{"text": "DELETE rows from the table which pass some test build a new table by .SELECTing some rows of interest .PROJECTing one just some columns of interest .JOINing two tables where they agree in some attribute columns .( see examples on the attached sheet ) .", "label": "", "metadata": {}, "score": "72.97147"}
{"text": "Because the chart parser parses symbols only once , it can specifically treat left recursive rules .To add the probabilities correctly , it is very important that the predict function add the rule probabilitiy onto the final probability of the state , not to add it onto the initial probability of the state .", "label": "", "metadata": {}, "score": "72.9959"}
{"text": "NUMERIC ATTRIBUTES -- for each relation , the attributes to be included in the interface that come from numeric domains .COMPUTABLE ATTRIBUTES -- for each relation , the attributes to be included in the interface that come from numeric domains and that are avergeable , totalable , . . . .", "label": "", "metadata": {}, "score": "73.05441"}
{"text": "( j ) generating a probability score for each said completed state ; .( k ) repeating steps ( h ) to ( j ) until no new states can be created ; .( l ) parsing terminal symbols from the current grammar level as start symbols for the next lower grammar level unless at the lowest grammar level ; .", "label": "", "metadata": {}, "score": "73.08246"}
{"text": "The class of grammars currently used by the parser is context - free grammars ( or CFG 's ) .Any arbitrary context - free grammar is permitted , with two minor exceptions to be discussed after context - free grammars are defined .", "label": "", "metadata": {}, "score": "73.09056"}
{"text": "This can be done either directly by accessing the phrase structure rules or indirectly by first computing the reachability matrix and then looking at all pairs X and Y such that X can dominate Y as a left daughter .The preferred embodiment uses the first method .", "label": "", "metadata": {}, "score": "73.14851"}
{"text": "Below that is word grammar level 1 , and below that is phoneme grammar level 2 .The next lower level shown is phone grammar level 3 .Each lower level contains narrower and narrower portions of the inputted data until the lowest level or reference frame grammar level 1 is reached .", "label": "", "metadata": {}, "score": "73.569786"}
{"text": "At this point , the processor initializes all of the state sets to empty at all levels of the first frame and sets the initial probability to 0.0 which is a logarithmic probability .The processor sets the level to 0 ( starts at the sentence grammar level ) , and sets the frame to 0 .", "label": "", "metadata": {}, "score": "73.58179"}
{"text": "For example , a person 's average speech input is 4 - 5 seconds long , which corresponds to 400 - 500 frames .When cubed , those 400 - 500 frames yield 64,000,000 - 125,000,000 processing steps to recognize an input .", "label": "", "metadata": {}, "score": "73.624275"}
{"text": "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ ( loop for ( rel .", "label": "", "metadata": {}, "score": "74.07952"}
{"text": "Natural language interfaces to computer systems that have been constructed employ a grammar which characterizes the set of acceptable input strings .A parser then access this grammar to produce a parse tree ( parse trees for ambiguous input ) for the input string .", "label": "", "metadata": {}, "score": "74.15268"}
{"text": "A wide variety of grammar formalisms and parsing strategies have been developed .For all natural language systems , the user is required to type his question using the keyboard of a computer terminal .When the entire query has been received , the natural language interface processes the input .", "label": "", "metadata": {}, "score": "74.17825"}
{"text": "MORE is inserted after that word .If no other instructions apply and !MORE is on top of stack alpha , the current contents of the beta and gamma stacks are saved and the parser backtracks to the last place that parse paths were split .", "label": "", "metadata": {}, "score": "74.18651"}
{"text": "This grammar and lexicon pair define a particular domain - specific natural language interface , suitable for use in a grammar - dirven , menu - based system .The prototype uses a particular core grammar and lexicon .The grammar assumes that the natural language is English , but it could have been another natural language .", "label": "", "metadata": {}, "score": "74.45643"}
{"text": "numeric - attributes -- for each relation , the attributes to be included in the interface that come numeric domain and that are avergeable , totalable , . . . .identifying - attributes -- for each relation , the attributes that can be used by the user to identify the rows .", "label": "", "metadata": {}, "score": "74.67664"}
{"text": "For example , in the example shown in FIG .10 , a relation between pitchers and teams is specified , together with the natural - language phrases which will call up this relation .It should be noted that the terminology produced by the automatic interface generating method of the present invention may be somewhat awkward .", "label": "", "metadata": {}, "score": "74.79849"}
{"text": "Domains correspond to DATA TYPES in programming languages .Some databases support only system - defined , syntactic domains like CHARACTER and INTEGER ; newer database systems support SEMANTIC DOMAINS ( like user defined data types in programming languages ) .Examples of semantic domains might be : . the set of all Congressmen 's names .", "label": "", "metadata": {}, "score": "74.98643"}
{"text": "The \" output device \" may be a screen , another processor , an audio speaker , a robotic arm , etc .In the implementation of the preferred emmbodiment of the present invention , the input is spoken , the input device is a microphone , the output and output device involve a processor response written to a screen .", "label": "", "metadata": {}, "score": "75.08453"}
{"text": "The system for recognizing a spoken sentence of claim 11 , further comprising a means for generating a chart , wherein the chart is accessed by said parser , said predictor , and said completer for storing intermediate results .The system for recognizing a spoken sentence of claim 12 , wherein the chart comprises states and state sets , said states to be manipulated by said parser and said predictor .", "label": "", "metadata": {}, "score": "75.21506"}
{"text": "The formal statement is : .Rule 3 : # # STR4 # # .Thus , the initial condition of the procedure can be represented as ( W 1 W 2 . . .W n # , S # ) .", "label": "", "metadata": {}, "score": "75.26166"}
{"text": "To add , there must be given a state that differs from a current state in the state set .It does not evaluate \u03c1 or \u03c3 , but instead marks the ending in the existing state set , thereby noting it has been added until the processor can later look up the probability and find the maximum .", "label": "", "metadata": {}, "score": "75.3554"}
{"text": "The system for parsing of claim 20 , wherein the chart comprises states and state sets , said states to be manipulated by said parser and said predictor .The system for parsing of claim 20 , further comprising a knowledge base coupled to said predictor for supplying symbols and appropriate operating data .", "label": "", "metadata": {}, "score": "75.365135"}
{"text": "In general , N will be the Nth node to the right of the arrow ( for N 0 ) .The first feature rule is interpreted as setting the value of FEATURE1 for the NP node to the result of applying the function F1 to the values of FEATURE2 of the NP node and FEATURE3 of the Nom node .", "label": "", "metadata": {}, "score": "75.742714"}
{"text": "When it has done all the predicting and completing it can do , it sees that it needs a verb indicated by v. There are two verb rules , so it predicts them .One is \" sleep \" and the other is \" leap \" , both beginning at frame 2 and having initial and final probabilities of -0.04 .", "label": "", "metadata": {}, "score": "75.78213"}
{"text": "The exact form of a grammar rule is prototype - specific .The basic operation of the MAKE - SEMANTIC - GRAMMAR function is identifier substitution .Generally this occurs in a context of looping through one of the categories , say non - numeric - attributes , and substituting , for every rel and attr pair , an argument list into one or more forms .", "label": "", "metadata": {}, "score": "75.833015"}
{"text": "A normal lexical entry hsa the form : .( ( grammar terminal ) ( menu phrase ) ( menu pane ) ( translation ( lexical item help ) ) .Lexical entries that invoke experts have ( translations ) of a special form , namely : ( translation ) is of the form ( EXPERT code ) , that is , a keyword followed by code .", "label": "", "metadata": {}, "score": "76.050766"}
{"text": "The natural language inputs are parsed using a parser which is generally similar to that disclosed in the 1981 dissertation of Ken Ross entitled \" Parsing English Phrase Structure \" .The system is coded in LISP , and has been demonstrated on a LISP machine from LMI Incorporated .", "label": "", "metadata": {}, "score": "76.09192"}
{"text": "This corpus is comprised of approximately three million words of text , corresponding to more than 150 hours of transcribed speech collected from telephone conversations restricted to 70 different topics .Although only a small fraction of the sentences in this corpus are ' grammatical ' by standard criteria , the robust link grammar parser is able to extract relevant structure for a large portion of the sentences .", "label": "", "metadata": {}, "score": "76.16083"}
{"text": "For each start symbol of grammar , the processor predicts the current frame 's initial and final probability as 0.0 .The processor then parses , given the start frame , the state set , and the level .In the parse algorithm , the processor inputs the matrix of state sets , a level 1 , a frame index i , and outputs an extra state for the next input frame request i+1 .", "label": "", "metadata": {}, "score": "76.363174"}
{"text": "For example , an attribute such as a batter 's hitting average can be computed from his at - bats and hits , and therefore need not be stored separately .It should also be noted that the expert for attribute classification will pop up a list of all possible attributes for each classification , and the user will typically desire not to include some of these attributes in the interface .", "label": "", "metadata": {}, "score": "76.37831"}
{"text": "With natural language systems , N is traditionally words ; however with speech systems , N is equal to frames , which are the fundamental time units used in speech recognition .The algorithm was significant in that it provided a time synchronous algorithm for speech recognition which improved accuracy because the processor did not have to be concerned about how the words fit together .", "label": "", "metadata": {}, "score": "76.92343"}
{"text": "When ( 3 ) is applied , attach the B on alpha B as the right daughter of the top symbol on gamma .The parse tree will now appear on stack alpha , instead of just the root symbol .The statement of the parser given above is neutral with respect to the control structure that the procedure employs .", "label": "", "metadata": {}, "score": "76.950066"}
{"text": "Then the processor predicts and completes grammar rules for the words which are composed of phonemes and when it finds a set of phonemes which are terminal symbols , it then calls itself at grammar level 2 which has phoneme symbols as start symbols .", "label": "", "metadata": {}, "score": "77.22083"}
{"text": "B is on top of stack beta , .C is on top of stack gamma , . and \" Conditions \" are satisfied .then replace A by D , B by E , and C by F. .Given this interpretation of the turing machine instruction , the MSBT parser is instantiated by the following turing machine instructions .", "label": "", "metadata": {}, "score": "77.26518"}
{"text": "For example , a flat graphics display ( e.g. electroluminescent ) could be used instead of a CRT , and user control of the curser could be accomplished , e.g. , by a joystick or by voice recognition .INSERT A .", "label": "", "metadata": {}, "score": "77.32304"}
{"text": "This is what the processor needs to see to indicate it has seen B 3 . \u03b5 is a string of 0 or more terminals and nonterminals In this case the ending frame is also the current frame because the processor has not processed anything .", "label": "", "metadata": {}, "score": "77.33945"}
{"text": "The cycle produces some terminal symbols that are hypothesized at the next lower grammar level .The processor hypothesizes the terminal symbols from this level as start symbols at the next lower grammar level .It returns a set of observations which are scanned into the waiting states .", "label": "", "metadata": {}, "score": "77.41661"}
{"text": "In this example , the input string is \" xyz \" , which is to be parsed as an \" S \" .2.2-Rule ( 3 ) z # # # STR55##Rule ( 2 ) # # STR56 # # S # Rule ( 1 ) applicable 3 ways -See continuations 3.1 , 3.2 and 3.3Cont . 3.2 Rule ( 1 ) z # # # STR65 # # # # STR66##Rule ( 1 ) # # # STR67 # # # # STR68##Rule ( 2 ) # # STR69 # # # # STR70##Rule ( 3 ) # # # STR71##BAD PATH - NO INSTRUCTIONS APPLYCont . 3.3 Rule ( 1 ) z # # # STR72 # # # # STR73##Rule ( 1 ) $ # # # STR74 # # # # STR75##Rule ( 2 ) # # STR76 # # # # STR77##BAD PATH - NO INSTRUCTIONS APPLYDONE _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ .", "label": "", "metadata": {}, "score": "77.63753"}
{"text": "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ ( supplier - n \" ( specific supplier ) \" NOUNS(EXPERT ( list ( setq phrase ( get - type - in \" type a suppliername\"))(list ' quote phrase)))\"Suppliers have name , address , and status attributes .", "label": "", "metadata": {}, "score": "77.97707"}
{"text": "One of the newly created states needs the terminal \" sleep \" and one needs terminal \" leap \" , both of which have the same beginning and end probabilities of -0.03 .There it sees both \" sleep \" and \" leap \" , but \" sleep \" begins at frame 2 and \" leap \" begins at frame 3 .", "label": "", "metadata": {}, "score": "78.017365"}
{"text": "RELATIONAL DATABASE :A collection of 0 or more relations .Formally , a relational database is a time varying collection of normalized relations of assorted degrees .RELATION : A two dimensional named table ( or FLAT FILE in older terminology ) .", "label": "", "metadata": {}, "score": "78.470215"}
{"text": "Translations that are functions are of the form \" lambda x . . .x . . . \" .This amounts to a simplified version of \" lambda \" conversion as used by all work in Montague Grammar ( See Montague 1973 ) .", "label": "", "metadata": {}, "score": "78.563065"}
{"text": "Research on these issues is carried out in the context of the Schisma project , a research project of the Parlevink group in linguistic engineering ; participants in Schisma are KPN Research and the University of Twente .The aims of the Schisma project are twofold : both the accumulation of knowledge in the field of computational linguistics and the development of a natural language interfaced theatre information and booking system is envisaged .", "label": "", "metadata": {}, "score": "78.59565"}
{"text": "The lexicon contains definitions of the terminal symbols of the grammar .These terminal grammar symbols are preferably word classification descriptors , such as verb , noun , and article , with syntactic and semantic information .The terms of the lexicon are assigned features , such as tense , plurality , or definiteness .", "label": "", "metadata": {}, "score": "78.83802"}
{"text": "NORMALIZATION is a design process whereby a complex data structure ( often a hierarchy , or tree structure , or a network , or graph structure ) is decomposed into relations .Notes on current terminology : .Flat file : used more to describe the physical structure of a relation , not the logical structure .", "label": "", "metadata": {}, "score": "78.89818"}
{"text": "Some of the problems involving \" ease of use \" of natural language interfaces are : . users type poorly and often use ungrammatical constructions .--users had no way of knowing the grammatical coverage of the system ( what constructions were allowed in its grammar ) and they had no clear path to learn such limitations .", "label": "", "metadata": {}, "score": "78.9265"}
{"text": "One such defect involves the calculation of probabilities .For context - free grammars , a nonterminal symbol may rewrite to another nonterminal symbol without having to go through a terminal symbol .Probabilities can therefore occur from many directions in the grammar .", "label": "", "metadata": {}, "score": "79.07156"}
{"text": "FIG .4 is an example of a typical left recursive rule showing rule probabilities , using a treatment of conjunctions and disjunctions such as \" a or b or d \" .As seen in portion A of FIG .4 , the example shown has the four terminal symbols : a , b , d and \" or \" .", "label": "", "metadata": {}, "score": "79.14637"}
{"text": "In the inner loop , for every rel attr pair , the substitution is done .In the example above , 9 such rules will result from the pair of loops .The other patent describes the meaning of the translations .", "label": "", "metadata": {}, "score": "79.50077"}
{"text": "\") in the bill table .Sometimes a key consists of several attributes as in the votes table where both the conman and the bill # attributes are neede to uniquely idenfiy rows in the table .Important OPERATIONS on relational databases are : .", "label": "", "metadata": {}, "score": "79.52066"}
{"text": "The method of claim 3 , wherein said probability score for said completed state is the probability for completing states in the state set using already complete states in the state sets .The method of claim 3 , wherein said score is calculated by summing the ending probability of the active state with the difference between the ending and initial probabilities of the complete state , wherein the active state is the state requiring the symbol which the complete state defines .", "label": "", "metadata": {}, "score": "79.70057"}
{"text": "At the bottom of the trace , it is seen that the one - third arises the correct number of times ( 3 ) , the 0.4 arises twice , and the 0.6 arises once , which accurately reflect the number of times the left and nonleft recursive rule were applied .", "label": "", "metadata": {}, "score": "79.79996"}
{"text": "For example , the identifying attributes of a pitcher would include his team , ERA , etc .A key identifying attribute of a pitcher would be his name .A next critical step is arbitrating the access of various users to the interface being constructed .", "label": "", "metadata": {}, "score": "80.29911"}
{"text": "This is especially important for left recursive rules .Subtracting the beginning probability from the ending probability , yields \u03b7 . sigma .-\u03c3.sub.\u03bf ) ] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ .", "label": "", "metadata": {}, "score": "80.428986"}
{"text": "The menu - item is a string ( word or phrase or whatever ) to display as an item in some menu - window .The menu - window identifies in which pane a menu - item will appear .( This menu - window component is specificly for use with the NLMENU system and might not be needed in some other sort of grammar - drive , menu - based iterface driver . )", "label": "", "metadata": {}, "score": "81.0703"}
{"text": "Si prega di creare una nuova lista con un nuovo nome ; sposta alcuni documenti su una lista gi\u00e0 esistente o su un nuova , oppure cancella alcuni documenti .Nota : Le citazioni si basano su standard di riferimento .Tuttavia , le regole di formattazione possono variare notevolmente tra le applicazioni e campi di interesse o di studio .", "label": "", "metadata": {}, "score": "81.22105"}
{"text": "In pseudo code , the entire function is described as follows : .PORTABLE SPEC 'S .How that information is elicited does not concern this section .The BUILD interfaces section of the patent describes extensions to the spec which are documented in the attached program code .", "label": "", "metadata": {}, "score": "81.463455"}
{"text": "INSERTIONS TABLES -- these four specifications list the access .DELETION TABLES -- rights that are reflected in the interface .MODIFICATION TABLES-- .NON - NUMERIC ATTRIBUTES -- for each relation , the attributes to be included in the interface that come from non - numeric domains .", "label": "", "metadata": {}, "score": "82.265976"}
{"text": "The dot above that refers to the place in the rule or how far one has progressed through the rule which , at this point , is none .The numbers at the end of the rule represent the logarithmic probabilities of the initial and final probabilities , respectively .", "label": "", "metadata": {}, "score": "82.50944"}
{"text": "COMBINE INTERFACES existing - interfaces - with - specs - expert GIVING new - interface - expert .SHOW SPECS exisging - interfaces - with - specs - expert .GRANT INTERFACES existing - owned - interfaces - expert TO users - expert .", "label": "", "metadata": {}, "score": "82.576385"}
{"text": "The rows of a relation of degree Ns are called N - TUPLES .So ( 111 - 22 - 3333 , # 331 , no ) is a 3-tuple from the votes relation .A relation of degree 2 is often termed a binary relation , degree 3 ternary , . . . . .", "label": "", "metadata": {}, "score": "82.755684"}
{"text": "L'indirizzo email inserito non \u00e8 in un formato corretto .Inserirlo nuovamente .Puoi inviare questo documento ad un massimo di cinque destinatari .Inserisci indirizzi email destinatari : Separa al massimo 5 indirizzi con la virgola ( , ) .Il campo nome \u00e8 obbligatorio .", "label": "", "metadata": {}, "score": "83.075714"}
{"text": "The numbers 0 , 1 , and 2 indicate the nodes represented in the phrase structure rule . 0 is the node to the left of the arrow , the NP node .1 is the node immediately to the right of the arrow , the det node .", "label": "", "metadata": {}, "score": "83.08455"}
{"text": "For example , the fundamental time unit may be 20 milliseconds .This means that every 20 milliseconds the processor will characterize speech data with a vector of length 18 or so , floating point features of various characteristics of the speech signal and will match those characteristics to the expected data or symbols which correspond to words .", "label": "", "metadata": {}, "score": "83.33244"}
{"text": "A KEY is some subset of the attributes of the relation and is treated as uniquely identifying the rows ( as Bill # in the bill relation ) .A user can uniquely refer to a row of any table by specifying the table name and the values of the key attributes .", "label": "", "metadata": {}, "score": "83.47775"}
{"text": "If no instructions apply and the above conditions are not true , then that path has ended without producing a valid parse of the input string .To obtain all valid parses of the input string , all paths must be pursued until they either produce a valid parse or end without producing a parse .", "label": "", "metadata": {}, "score": "83.79384"}
{"text": "The bottom line represents the best plus some predetermined log probability amount , or threshold .With other algorithms , if the probability of a symbol drops below that threshold at any point , it is discarded .Furthermore , when the best probability symbol completes , the parser will then associate the lower probability symbols with their starting states .", "label": "", "metadata": {}, "score": "84.38797"}
{"text": "To hypothesize , the processor takes a terminal symbol b from a state needed to advance a given state or a set of states .For all terminals \" b \" at a given level 1 , the processor computes a new probability based on the ending probability \u03c1 of the state , \u03c1 ' .", "label": "", "metadata": {}, "score": "84.909035"}
{"text": "The ordering of the rows and columns in a relation is not usually considered to be significant .The number of rows in a relation is the CARDINALITY of the relation .The number of columns is the DEGREE of the relation .", "label": "", "metadata": {}, "score": "85.424225"}
{"text": "For example , in a parts database , if every part has a weight less than five pounds , an expert for part weight can be used which constrains the numerical part weight input to be less than five pounds .Thus , the expert if effect permits sub - queries to the database to be transacted in the midst of formulating a larger query , and thus same much time .", "label": "", "metadata": {}, "score": "85.93658"}
{"text": "When the parser has predicted and completed as much as it can , it has a set of terminal symbols that it needs to see before it can go on and the set consists of one element which is \" boys \" .", "label": "", "metadata": {}, "score": "85.953766"}
{"text": "If X is in the set of terminals ., Y ) ( 8) .where : is a special symbol which is neither a terminal or a nonterminal symbol .C1 is a Ci type variable as defined earlier .( Rules 4 through 10 are added to permit use of grammar rules which contain parentheses and curly brackets .", "label": "", "metadata": {}, "score": "86.891235"}
{"text": "These instructions are of the following form , where A , B , C , D , E , and F can be arbitrary strings of symbols from the terminal and nonterminal alphabet .This is to be interpreted as follows : .", "label": "", "metadata": {}, "score": "86.910355"}
{"text": "Curly brackets indicate that exactly one of the elements within the brackets is to be inserted .Parentheses indicate that one or more ( or none ) of the elements in parentheses can be inserted .Ci - type variables are added merely to keep track of nested brackets and parentheses although this function is easily accomplished in the Lisp implementation ) .", "label": "", "metadata": {}, "score": "87.05298"}
{"text": "II -- Nouns and their Determiner agree in Number and Gender .III -- Adjectives and Nouns agree in Gender .IV -- The language is SVO and in Noun Phrases , the order of constituents is Determiner - Adjective - Noun .", "label": "", "metadata": {}, "score": "87.89214"}
{"text": "RENAME INTERFACE -- rename an existing interface the user owns .COMBINE INTERFACE -- combine interfaces .DROP INTERFACE(S)--drop interfaces the user owns or has been granted .GRANT INTERFACE(S)--grant interfaces to other users .REVOKE INTERFACE -- revoke a granted interface .", "label": "", "metadata": {}, "score": "88.93037"}
{"text": "TUTORIAL .LIST INTERFACES .CREATE INTERFACE new - interface - expert USING spec - initial .MODIFY INTERFACE existing - owned - interface - with - specs - expert BY CHANGING speclist GIVING new - interface - expert .DROP INTERFACES existing - dropable - interfaces - expert .", "label": "", "metadata": {}, "score": "89.01703"}
{"text": "The code ( setq phrse ( get - type - in \" type a supplier name \" ) ) pops up a type - in window and the user types a supplier name , say \" Jones \" . \" Jones \" is then used as the next phrase in the sentence and the translation ( quote \" Jones \" ) is treated as the ( translation ) .", "label": "", "metadata": {}, "score": "89.04286"}
{"text": "Inserisci il tuo nome : Il campo soggetto \u00e8 obbligatorio .Inserisci il soggetto .Soggetto : .Il campo messaggio email \u00e8 obbligatorio .Inserire il messaggio .Messaggio email : Credo tu possa essere interessato a questo documento su .", "label": "", "metadata": {}, "score": "89.42102"}
{"text": "Adjective : lazy , red .Noun : cat , book .Verb : ate , saw .Adverb : slowly , greedily .Nonterminal symbols are those symbols which are not terminal symbols .The Bn 's are either terminal or nonterminal symbols .", "label": "", "metadata": {}, "score": "90.942535"}
{"text": "The only difference is that \" complete \" deals with nonterminal symbols and \" scan \" deals with terminal symbols .First the processor makes the state set at level 1 , frame i+1 , empty .Its probability is \u03c1 , that is the ending probability of that state plus the ending probability of the completed state minus the initial probability of the completed state .", "label": "", "metadata": {}, "score": "91.27137"}
{"text": "COMMIT . where .spec - initial -- COVERED - TABLES ( speclist ) . speclist -- spec ( speclist ) .spec -- COVERED - TABLES . spec -- ACCESS - RIGHTS . spec -- CLASSIFY - ATTRIBUTES .spec -- IDENTIFYING - ATTRIBUTES .", "label": "", "metadata": {}, "score": "91.56166"}
{"text": "Symbols are classified as being either terminal symbols or nonterminal symbols .Terminal symbols are those symbols which appear in the lexicon ( or dictionary ) and thereby classify words according to categories .For example , terminal symbols commonly used in linguistic work are shown to the left of the colon in the example lexicon below .", "label": "", "metadata": {}, "score": "93.21718"}
{"text": "PART ( part # name city color weight ) .SHIPMENT ( supplier # part # quantity ) .which are suppliedby \" ) part # ) ( supplier supplier # ) ( part part#)))(((shipment supplier#)(\"which were shipped by \" .\" whicha were shipments of\")(supplier supplier#)))((other specificaitons to be added later ) ) ) ) _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ .", "label": "", "metadata": {}, "score": "93.65308"}
{"text": "Add extensible support for units like fee , pounds , . . .including support for unit conversion .Add extensible support for Attribute Groups like names ( composed of first and last names , dates , addresses , . . . .", "label": "", "metadata": {}, "score": "93.92943"}
{"text": "The first association is always a direct translation from a specific word ( e.g. \" cat \" ) to its directly associated category ( \" noun \" ) .However , it should be preliminarily noted here that the categories used need not be as broad as familiar English - language parts of speech , but , at least for database - query applications , are preferably modified to include some semantic information .", "label": "", "metadata": {}, "score": "94.00912"}
{"text": "Processor 14 communicates with processor memory 16 via connecting element 18 .After processor 14 has completed the algorithm and has identified the input from input device 10 , processor 14 transmits an output to output device 22 via connecting element 20 .", "label": "", "metadata": {}, "score": "96.95465"}
{"text": "Since the parser has probabilites of -0.09 on state 13 and 0.06 on state 14 , it chooses the best one , which is -0.06 , and traces back through the parse state to find \" boys leap \" .This phrase will then be outputted as the speech recognition processor 's best explanation for the spoken input given .", "label": "", "metadata": {}, "score": "97.16641"}
{"text": "A column of a relation is a subset of a domain , so the congressman.ssn column and the votes.conman column both come from the same domain , the domain of social security numbers .Only data elements from that domain should ever go in those columns .", "label": "", "metadata": {}, "score": "100.48302"}
{"text": "The meaning of the entire tree is the meaning of the VP , via the function \" lambda y ( hit y Mary \" ) , applied to the meaning of the NP , John .This function applied to this argument produces \" ( hit John Mary ) \" .", "label": "", "metadata": {}, "score": "103.64891"}
