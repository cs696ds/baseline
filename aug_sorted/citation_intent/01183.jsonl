{"text": "In it they say : .The overarching claim is that the proper units of a grammar are more similar to the notion of construction in traditional and pedagogical grammars than to that of rule in most versions of generative grammar .", "label": "", "metadata": {}, "score": "31.366287"}
{"text": "The mechanism that allows \" carving out \" of such subsets is called a signature and works as follows .The RIF - FLD language associates a signature with each symbol ( both constant and variable symbols ) and uses signatures to define what is called well - formed terms .", "label": "", "metadata": {}, "score": "34.59674"}
{"text": "Frame , classification , and other terms can be freely nested , as exemplified by p ( ?Some language environments , like FLORA-2 [ FL2 ] , OO jDREW [OOjD ] , and CycL [ CycL ] support fairly large ( partially overlapping ) subsets of RIF - FLD terms , but most languages support much smaller subsets .", "label": "", "metadata": {}, "score": "35.314766"}
{"text": "If a symbol is used in more than one context , the parser should deem it as a syntax error .In dialects that extend RIF 's Basic Condition Language , signature inference of the above kind is not possible , in general , and advanced signature inference might not always be appropriate even when it is possible .", "label": "", "metadata": {}, "score": "35.360256"}
{"text": "However , it is well - known that disjunctions of such conditions can also be used in the bodies of rules without changing the essential properties of the rule language .In other words , a rule with a disjunction in the body can be split into two or more rules that have no such disjunction .", "label": "", "metadata": {}, "score": "36.06203"}
{"text": "However , it is well - known that disjunctions of such conditions can also be used in the bodies of rules without changing the essential properties of the rule language .In other words , a rule with a disjunction in the body can be split into two or more rules that have no such disjunction .", "label": "", "metadata": {}, "score": "36.06203"}
{"text": "Then we extend the basic semantic structures defined in Model Theory for the Core RIF Condition Language and define an interpretation for flat frames .The rest of the semantic definitions does not change , since it is defined in terms of atomic formulas ( the ATOMIC production in the BNF syntax ) .", "label": "", "metadata": {}, "score": "36.416565"}
{"text": "Then we extend the basic semantic structures defined in Model Theory for the Core RIF Condition Language and define an interpretation for flat frames .The rest of the semantic definition does not change , since it is defined in terms of atomic formulas ( the ATOMIC production in the BNF syntax ) .", "label": "", "metadata": {}, "score": "36.54165"}
{"text": "A specification whose locale is ' global .If all of those fail , then the C - code - provided fallback value for this specifier is consulted ( see ' specifier - fallback ' ) .If it is an inst - list , then this function attempts to instantiate that list just as when a specification is located in the first five steps above .", "label": "", "metadata": {}, "score": "36.628033"}
{"text": "The decision on this point is strongly related to the decision on syntactic correspondence .If syntactic correspondence is defined based on the abstract syntax , then it seems reasonable to define the semantic correspondence with respect to the direct semantics .", "label": "", "metadata": {}, "score": "36.647305"}
{"text": "Our main target paradigms include production rules , logic programming , FOL - based rules , reactive rules , and normative rules ( integrity constraints ) .The central part of RIF is its Condition Language .The condition language defines the syntax and semantics for the bodies of the rules in RIF - BLD and the syntax for queries .", "label": "", "metadata": {}, "score": "36.866943"}
{"text": "By focusing on the condition part of the rule bodies we achieve a great deal of syntactic and semantic reuse among the dialects .The sublanguage of positive conditions in RIF - BLD determines what can appear as a body of a rule ( also known as the if - part , antecedent , or condition part of the rule ) supported by RIF - BLD .", "label": "", "metadata": {}, "score": "36.86973"}
{"text": "All declarative environment record bindings are marked as enumerable .( This is n't great ; the semantics of variables in declarative enviroments do n't really match those of properties , so .Create or reconfigure the variable bound to name in this environment according to descriptor .", "label": "", "metadata": {}, "score": "36.88089"}
{"text": "The main advantage of the former approach is that there is a tighter integration of the semantics .The main advantage of the latter approach is that processing can be done using out - of - the - box rules and DL engines ( with minimal modifications ) .", "label": "", "metadata": {}, "score": "36.990993"}
{"text": "We prefer inherited accessor properties to own data properties .Both are read using the same syntax , but inherited accessors seem like a more accurate reflection of what 's going on .Unless otherwise noted , these properties have getters but no setters , as they can not meaningfully be assigned to .", "label": "", "metadata": {}, "score": "36.991783"}
{"text": "Language Log reposted a more complete profile of his life .References .Fillmore , C. , 1968 .The Case for Case .In E. Bach & R. Harms , eds .Universals in Linguistic Theory .New York : Holt , Rinehart and Winston , pp . 1 - 88 .", "label": "", "metadata": {}, "score": "37.000626"}
{"text": "For instance , a value space may be required to be disjoint from the value space of the XML data types .the .XML .or . type .The value spaces and the corresponding mappings for the XML data types are defined by the XML Schema Part 2 : Datatypes specification .", "label": "", "metadata": {}, "score": "37.259285"}
{"text": "As explained in Section Formal Preliminaries a set of signatures restricts this syntax to allow only the terms that are allowed in standard first - order logic .The above .Concrete .Presentation .Where spaces are omitted from the .", "label": "", "metadata": {}, "score": "37.50907"}
{"text": "This document , developed by the Rule Interchange Format ( RIF )Working Group , specifies the basic design for a format that allows logic rules to be translated between rule languages and thus transferred between rule systems .In Phase 1 , the RIF Working Group first defines a condition language , which is envisioned to be a shared part of all RIF dialects .", "label": "", "metadata": {}, "score": "37.54743"}
{"text": "Our main target paradigms include production rules , logic programming , FOL - based rules , reactive rules , and normative rules ( integrity constraints ) .The central part of RIF is its Condition Language .The condition language defines the syntax and semantics for the bodies of the rules in RIF BLD and the syntax for the queries .", "label": "", "metadata": {}, "score": "37.736443"}
{"text": "There is an obvious 1-to-1 mapping between the above LIST class and the following earlier - considered LIST class : .This section develops a RIF Rule Language by extending the RIF Condition Language , where conditions become rule bodies .", "label": "", "metadata": {}, "score": "37.800713"}
{"text": "By focusing on the condition part of the rule bodies we achieve maximum syntactic and a great deal of semantic reuse among the dialects .The language of positive RIF conditions determines what can appear as a body ( the if - part ) of a rule supported by the basic RIF logic .", "label": "", "metadata": {}, "score": "37.806236"}
{"text": "For the basic logic dialect , which is based on Horn rules , the set of intended models of R is commonly agreed upon : it is the unique minimal model of R .However , when rule bodies contain literals negated with the negation - as - failure connective naf , then only some of the minimal models of a rule set are viewed as intended .", "label": "", "metadata": {}, "score": "37.96792"}
{"text": "A dialect is a rule language with a well - defined syntax and semantics .This semantics must be model - theoretic , proof - theoretic , or operational in this order of preference .Some dialects might be proper extensions of others ( both syntactically and semantically ) and some may have incompatible expressive power .", "label": "", "metadata": {}, "score": "38.058174"}
{"text": "A dialect is a rule language with a well - defined syntax and semantics .This semantics must be model - theoretic , proof - theoretic , or operational in this order of preference .Some dialects might be proper extensions of others ( both syntactically and semantically ) and some may have incompatible expressive power .", "label": "", "metadata": {}, "score": "38.058174"}
{"text": "Note that the name and filler of a slot are defined as a sequence of two classes .Also , a Const can have an optional type property .To maintain a clean separation of concerns , the unorderedness of slots within Uniterms and Frames is taken care of by the semantics in Section Semantics .", "label": "", "metadata": {}, "score": "38.332153"}
{"text": "This syntax can be used in the various dialects that extend RIF - BLD .Then we introduce the notion of a signature and specify the restrictions on the way signatures are allowed to be assigned to symbols .Next we define the presentation syntax using EBNF and describe the corresponding XML - based exchange syntax .", "label": "", "metadata": {}, "score": "38.43626"}
{"text": "This may cause a slight loss of potential functionality but if we were to allow it then a user could manage to violate our assertion that the specs contained in the actual specifier lists are all valid .If LOCALE is a particular locale ( a buffer , window , frame , device , or ' global ) , a spec - list consisting of the specification for that locale will be returned .", "label": "", "metadata": {}, "score": "38.87467"}
{"text": "We begin by describing a syntax , which is more general than what the basic logic dialect permits .This syntax can be used in the various dialects that extend RIF 's basic logic dialect .Then we introduce the notion of a signature and specify the restrictions on the way signatures are allowed to be assigned to symbols .", "label": "", "metadata": {}, "score": "39.09104"}
{"text": "The syntax for atomic formulas is extended with slotted formulas and frame formulas .More precisely , an atomic well - formed formula is .The notion of well - formed general formulas needs no adjustments with respect to its earlier definition ( without frames ) .", "label": "", "metadata": {}, "score": "39.28669"}
{"text": "The syntax for a RIF dialect can be obtained from the general syntactic framework of RIF by specializing the following parameters ( which are defined in this document ) : .The alphabet of RIF - FLD can be restricted .Signatures determine which terms in the dialect are well - formed and which are not .", "label": "", "metadata": {}, "score": "39.345993"}
{"text": "But before we can make these distinctions , we first need to introduce a few definitions .An allocation - contour is a coarsening of the normal notion of a scope - contour in order to aggregate variable introduction as much as possible without changing the semantics .", "label": "", "metadata": {}, "score": "39.362442"}
{"text": "If LOCALE is supplied , then instead of returning the actual value , the specification(s ) for the given locale or locale type will be returned .This will only work if the actual value of PROPERTY is a specifier ( this will always be the case for built - in properties , but not or not may apply to user - defined properties ) .", "label": "", "metadata": {}, "score": "39.420662"}
{"text": "If LOCALE is supplied , then instead of returning the actual value , the specification(s ) for the given locale or locale type will be returned .This will only work if the actual value of PROPERTY is a specifier ( this will always be the case for built - in properties , but not or not may apply to user - defined properties ) .", "label": "", "metadata": {}, "score": "39.420662"}
{"text": "P ( ?The syntax of RIF frames permits nesting of two kinds .First , a classification formula of the form obj1#obj2 or obj1##obj2 can appear in the object position of a frame .Second , a frame may appear in the value position of an attribute .", "label": "", "metadata": {}, "score": "39.832054"}
{"text": "For uniformity and greater syntactic convenience , frame formulas can be nested inside other frame formulas .This is syntactic sugar , however , as explained later in this section .The most important additions to the syntax for positive conditions in Section Formal Preliminaries are the notions of slotted terms ( including slotted predicates ) and frames .", "label": "", "metadata": {}, "score": "39.922684"}
{"text": "An example of such a restriction is that no constant in a particular symbol space may be mapped to an element in the value space of any XML Schema data type .The above semantics is not limited to any particular set of symbol spaces or primitive data types .", "label": "", "metadata": {}, "score": "39.944016"}
{"text": "In contrast , a uniterm slot semantically behaves like a unary uninterpreted function symbol .In both cases , however , the order of the slots is immaterial ( in contrast to positional uniterms ) .Syntactically , the extension is achieved by extending the notion of a uniterm with slots and by adding a new kind of formula , called frame formula .", "label": "", "metadata": {}, "score": "40.240437"}
{"text": "The first step in defining a model - theoretic semantics for a logic - based language is to define the notion of a semantic structure , also known as an interpretation .( See end note on the rationale . )In this section we define basic semantic structures .", "label": "", "metadata": {}, "score": "40.352448"}
{"text": "Some popular ways to handle uncertain or inconsistent information ( which is certainly important in the Web environment ) rely on four - valued and other multi - valued logics .Therefore , following M. Fitting , Fixpoint Semantics for Logic Programming A Survey , Theoretical Computer Science , 1999 , we build our definitions to be compatible with future RIF dialects , which will be based on multivalued logics .", "label": "", "metadata": {}, "score": "40.371456"}
{"text": "Some popular ways to handle uncertain or inconsistent information ( which is certainly important in the Web environment ) rely on four - valued and other multi - valued logics .Therefore , following M. Fitting , Fixpoint Semantics for Logic Programming A Survey , Theoretical Computer Science , 1999 , we build our definitions to be compatible with future RIF dialects , which will be based multivalued logics .", "label": "", "metadata": {}, "score": "40.594254"}
{"text": "As before , such formulas are constructed from well - formed atomic formulas using the logical connectives And , Or , and the quantifier Exists .Extended signatures for RIF - BLD .Section Symbols and Signatures defined the allowed signatures for RIF - BLD .", "label": "", "metadata": {}, "score": "40.644394"}
{"text": "For user - defined properties , you can use this function to either change the actual value of the property or , if this value is a specifier , change the specifications within it .-- If VALUE is a specifier ( as would be returned by ' face - property ' if no LOCALE argument is given ) , then some or all of the specifications in the specifier will be added to the property .", "label": "", "metadata": {}, "score": "40.852074"}
{"text": "For user - defined properties , you can use this function to either change the actual value of the property or , if this value is a specifier , change the specifications within it .-- If VALUE is a specifier ( as would be returned by ' face - property ' if no LOCALE argument is given ) , then some or all of the specifications in the specifier will be added to the property .", "label": "", "metadata": {}, "score": "40.852074"}
{"text": "Signatures .In this section we introduce the concept of a signature , which is a key mechanism that allows RIF - FLD to control the context in which the various symbols are allowed to occur .Much of this development is inspired by [ CK95 ] .", "label": "", "metadata": {}, "score": "40.880775"}
{"text": "In the latter case , the free variables in a condition formula must also occur in the then part of the rule .We shall see in Section Horn Rules that such variables are quantified universally outside of the rule , and the scope of such quantification is the entire rule .", "label": "", "metadata": {}, "score": "40.95685"}
{"text": "We give an abstract syntax ( with UML visualization ) and semantics ( model theory ) for positive and slotted conditions as well as for a Horn rule language .Examples in this document are based on a human - oriented syntax and an XML syntax , which are derived from the abstract syntax , but in the current working draft these syntaxes are used only for explanations and illustration .", "label": "", "metadata": {}, "score": "40.965446"}
{"text": "Dialects that extend RIF - BLD might appropriate some of the symbol spaces , which are left undefined in RIF - BLD , and give them special semantics .The RIF - BLD presents a much simpler picture to the user by restricting the set of well - formed terms to a specific coherent set of signatures .", "label": "", "metadata": {}, "score": "41.083908"}
{"text": "Instead they are part of a separate language for signatures , which is akin to grammar rules in that it determines which sequences of tokens are in the language and which are not .In some dialects ( for example RIF - BLD ) , signatures are derived from the context and no separate language for signatures is used .", "label": "", "metadata": {}, "score": "41.157032"}
{"text": "Classification and frame terms are used to describe objects in object - based logics like F - logic [ KLW95 ] .The above definition is very general .It makes no distinction between constant symbols that represent individuals , predicates , and function symbols .", "label": "", "metadata": {}, "score": "41.353325"}
{"text": "Various RIF dialects will extend this semantics in the required directions .Some of these extended semantics might not have a model theory ( for example , production rules ) and some will have non - first - order semantics .However , all these extensions are required to be compatible with the above definition when the rule set is completely covered by RIF BLD .", "label": "", "metadata": {}, "score": "41.41911"}
{"text": "Various RIF dialects will extend this semantics in the required directions .Some of these extended semantics might not have a model theory ( for example , production rules ) and some will have non - first - order semantics .However , all these extensions are required to be compatible with the above definition when the rule set is completely covered by RIF BLD .", "label": "", "metadata": {}, "score": "41.41911"}
{"text": "the intended set of models of R is commonly agreed upon : it is the set of all models of R .However , when rule bodies contain literals negated with the negation - as - failure connective naf , then only some of the models of a rule set are viewed as intended .", "label": "", "metadata": {}, "score": "41.44908"}
{"text": "Integrity constraints ( IC ) .It should be noted , however , that apart from RIF BLD and RIF PRD no decision has been made regarding which dialects will ultimately be part of RIF .The RIF Condition Language is intended to be used only in rule bodies and queries , not in rule heads .", "label": "", "metadata": {}, "score": "41.539814"}
{"text": "The logic underlying rule - based systems also assumes that only the minimal models are intended ( minimality here is with respect to the set of true facts ) .Therefore , the intended models of the above rule set R must have the property that not only p is true but also that q is false .", "label": "", "metadata": {}, "score": "41.62836"}
{"text": "Note that , by definition , atomic formulas that correspond to builtin predicates ( i.e. , formulas with signature bi_atomic ) are not allowed in the rule heads .This restriction is not reflected in the diagram or EBNF syntax above .", "label": "", "metadata": {}, "score": "41.66333"}
{"text": "This is a draft document and may be updated , replaced or obsoleted by other documents at any time .It is inappropriate to cite this document as other than work in progress .Based on the RIF Use Cases and Requirements , this document develops RIF - BLD ( the B asic L ogic D ialect of the R ule I nterchange F ormat ) through a set of foundational concepts that are intended to be shared by all logic - based RIF dialects .", "label": "", "metadata": {}, "score": "41.78184"}
{"text": "The logic underlying rule - based systems also assumes that only the minimal models as intended ( minimality here is with respect to the set of true facts ) .Therefore , the intended models of the above rule set R must have the property that not only p is true but also that q is false .", "label": "", "metadata": {}, "score": "41.91878"}
{"text": "( van Brakel 1992 : 1.1 ) .The family then includes \" the persistence problem , temporal projection problem , inertia problem , qualification problem , ramification problem , extended prediction problem , installation problem , planning problem , holism problem , relevance problem , and so on \" ( 1.2 ) .", "label": "", "metadata": {}, "score": "41.97037"}
{"text": "\" Instantiating \" a specifier in a particular domain means determining the specifier 's \" value \" in that domain .This is accomplished by searching through the specifications in the specifier that correspond to all locales that can be derived from the given domain , from specific to general .", "label": "", "metadata": {}, "score": "41.971626"}
{"text": "the . ruleset .The condition language . will . is . intended .to .be shared among the bodies of the rules expressed in future RIF dialects , such as LP , FO , PR and RR .The condition language might also be used to uniformly express integrity contraints and queries .", "label": "", "metadata": {}, "score": "42.17742"}
{"text": "However , RIF is designed to enable interoperability among rule languages in general , and its uses are not limited to the Web .The semantics of RIF has provisions for future extensions towards dialects that support pure FOL , dialects that support negation as failure ( NAF ) , business ( or production ) rules , reactive rules , and other features .", "label": "", "metadata": {}, "score": "42.29001"}
{"text": "If PROPERTY does not name a built - in property , its value will simply be returned unless it is a specifier object , in which case it will be instanced using ' specifier - instance ' .Optional arguments DEFAULT and NO - FALLBACK are the same as in ' specifier - instance ' .", "label": "", "metadata": {}, "score": "42.316795"}
{"text": "If PROPERTY does not name a built - in property , its value will simply be returned unless it is a specifier object , in which case it will be instanced using ' specifier - instance ' .Optional arguments DEFAULT and NO - FALLBACK are the same as in ' specifier - instance ' .", "label": "", "metadata": {}, "score": "42.316795"}
{"text": "( In the terms used by the ECMAScript specification , the VariableEnvironment of the execution context for non - strict eval code is the referent , and the bindings appear in a new declarative environment , which is the eval code 's LexicalEnvironment . )", "label": "", "metadata": {}, "score": "42.385635"}
{"text": "For instance , p(a)(p(b c ) q ) is also a term .To control the context in which any given symbol can occur in RIF dialects , the language associates a signature with each symbol ( both constant and variable symbols ) .", "label": "", "metadata": {}, "score": "42.40243"}
{"text": "In this section we define basic semantic structures .This definition will be extended in Extension of Semantic Structures for Frames when we introduce frame syntax .Semantic structures are used to assign a truth value to each formula .Currently , by formula we mean anything produced by the CONDITION production in the presentation syntax .", "label": "", "metadata": {}, "score": "42.413788"}
{"text": "In the ongoing discussion of the \" frame problem \" ( McCarthy 1963 ; McCarthy & Hayes 1969 ; Hayes 1992 ) there has been a steady proliferation of problems and problem - names ( in a way that is itself reminiscent of a frame problem ! )", "label": "", "metadata": {}, "score": "42.48959"}
{"text": "They are idiomatic .That is , their meaning is not built up from their constituent parts .The beauty of construction grammar ( just as the beauty of frame semantics ) is in that it can bridge much of the modern thinking about language with grammatical insights and intuitions of generations of researchers from across many schools of thought .", "label": "", "metadata": {}, "score": "42.515728"}
{"text": "It 's obvious that a sentence in a book does not mean something in the sense that a thought in my head does .In short , symbolic capacities are to be grounded in robotic capacities .An ungrounded symbol system has only one set of constraints : purely formal , syntactic ones , operating rulefully on the arbitrary shapes of the symbol tokens .", "label": "", "metadata": {}, "score": "42.559284"}
{"text": "and I SR interpret terms and predicates with named arguments , respectively ; I sub .i . gives meaning to the subclass hierarchy ; and I isa interprets class membership .The intuitive meaning of frame slots is that they are functions that take objects and return sets of objects , where every member of the set has a certain degree of truth .", "label": "", "metadata": {}, "score": "42.57583"}
{"text": "EXACT_P indicates whether the match must be exact ( as opposed to a subset ) .SHORT_P indicates that the short form ( for ' specifier - specs ' ) should be returned if possible .If COPY_TREE_P , ' copy - tree ' is used to ensure that no elements of the new list are shared with the initial list .", "label": "", "metadata": {}, "score": "42.63263"}
{"text": "In addition , RIF promotes the use of Internationalized Resource Identifiers ( or IRI s ) RFC 3987 to refer to individuals , predicates , and functions .To ensure extensibility and to provide for future higher - order dialects based on formalisms such as HiLog and Common Logic , the RIF does not draw a sharp boundary between the symbols used to denote individuals from symbols used as names for functions or predicates .", "label": "", "metadata": {}, "score": "42.64206"}
{"text": "If PROPERTY is not a built - in property , then this function will simply set its value if LOCALE is nil .However , if LOCALE is given , then this function will attempt to add VALUE as the instantiator for the given LOCALE , using ' add - spec - to - specifier ' .", "label": "", "metadata": {}, "score": "42.750732"}
{"text": "If PROPERTY is not a built - in property , then this function will simply set its value if LOCALE is nil .However , if LOCALE is given , then this function will attempt to add VALUE as the instantiator for the given LOCALE , using ' add - spec - to - specifier ' .", "label": "", "metadata": {}, "score": "42.750732"}
{"text": "As we shall soon see , this signature is used in RIF - BLD .Consider the term p ( p ( a ) p ( a b c ) ) .Then r ( r ( a ) r ( a b c ) ) is well - formed .", "label": "", "metadata": {}, "score": "42.75476"}
{"text": "Basic semantic structures .Currently , by formula we mean anything produced by the CONDITION production in the .Concrete .Presentation .EBNF Syntax .Later . on .this . term . on , . formulas .will also include rules .", "label": "", "metadata": {}, "score": "42.784847"}
{"text": "The central class of RIF , CONDITION , is specified recursively through its subclasses and their parts .The Equal class has two side roles .The syntactic classes are partitioned into classes that will not be visible in serializations ( written in all - uppercase letters ) and classes that will be visible in instance markup ( written with a leading uppercase letter only ) .", "label": "", "metadata": {}, "score": "42.977913"}
{"text": "We first define the notion of a truth value formally and then introduce semantic structures .Next we give the semantics to symbol spaces and , finally , define truth values of formulas with respect to semantic structures .Truth values .", "label": "", "metadata": {}, "score": "42.993587"}
{"text": "A boolean value indicating whether this Debugger instance 's handlers , breakpoints , watchpoints , and the like are currently enabled .It is an accessor property with a getter and setter : assigning to it enables or disables this Debugger instance ; reading it produces true if the instance is enabled , or false otherwise .", "label": "", "metadata": {}, "score": "42.994007"}
{"text": "These are the add - meth types that affect locales other than this one .It 's certainly possible to implement an O(n log n ) algorithm , but I doubt there 's any need to .CLOSURE is passed unchanged to MAPFUN .", "label": "", "metadata": {}, "score": "43.105034"}
{"text": "The most basic construct of a logic language is a term .RIF - FLD supports several kinds of terms : constants , variables , the regular positional terms , plus terms with named arguments , equality , classification terms , and frames .", "label": "", "metadata": {}, "score": "43.120617"}
{"text": "Each value must be a debuggee value .( This is not like a with statement : code may access , assign to , and delete the introduced bindings without having any effect on the bindings object . )This method allows debugger code to introduce temporary bindings that are visible to the given debuggee code and which refer to debugger - held debuggee values , and do so without mutating any existing debuggee environment .", "label": "", "metadata": {}, "score": "43.14455"}
{"text": "Each value must be a debuggee value .( This is not like a with statement : code may access , assign to , and delete the introduced bindings without having any effect on the bindings object . )This method allows debugger code to introduce temporary bindings that are visible to the given debuggee code and which refer to debugger - held debuggee values , and do so without mutating any existing debuggee environment .", "label": "", "metadata": {}, "score": "43.14455"}
{"text": "Each value must be a debuggee value .( This is not like a with statement : code may access , assign to , and delete the introduced bindings without having any effect on the bindings object . )This method allows debugger code to introduce temporary bindings that are visible to the given debuggee code and which refer to debugger - held debuggee values , and do so without mutating any existing debuggee environment .", "label": "", "metadata": {}, "score": "43.14455"}
{"text": "X ?Y ) ) ) .EDITORS ' NOTE :The XML syntax for BLD presented here is one of the proposals the Working Group is considering .It is presented here to get feedback on this strawman and to give readers an idea for the kind of information that will be presented in this section .", "label": "", "metadata": {}, "score": "43.153393"}
{"text": "The two most common theories of intended models are based on the so called well - founded models and stable models .Here we will just illustrate the problem with a simple example .Suppose R consists of a single rule p : - naf q .", "label": "", "metadata": {}, "score": "43.292564"}
{"text": "The two most common theories of intended models are based on the so called well - founded models and stable models .Here we will just illustrate the problem with a simple example .Suppose R consists of a single rule p : - naf q .", "label": "", "metadata": {}, "score": "43.292564"}
{"text": "The syntactic classes are partitioned into classes that will not be visible in serializations ( written in all - uppercase letters ) and classes that will be visible in instance markup ( written with a leading uppercase letter only ) .The three classes Var , CONDITION , and ATOMIC will be required in the abstract syntax of Horn Rules .", "label": "", "metadata": {}, "score": "43.2966"}
{"text": "However , we will usually omit the symbol space , for readability .The equality predicate has special model - theoretic semantics , as explained in Section Model Theory for Condition Language of RIF BLD .RIF - BLD requires no extra syntax for declaring signatures , since signatures can be inferred .", "label": "", "metadata": {}, "score": "43.326435"}
{"text": "In the condition language of RIF - BLD , a variable can be free or quantified .All quantification is explicit and the variables introduced by quantification must also occur in the quantified formula .Variables that are not explicitly quantified are free .", "label": "", "metadata": {}, "score": "43.36372"}
{"text": "It should be noted , however , that apart from RIF - BLD and RIF - PRD no decision has been made regarding which dialects will ultimately be part of RIF .The condition sublanguage of RIF - BLD is intended to be used only in rule bodies and queries , not in rule heads .", "label": "", "metadata": {}, "score": "43.44422"}
{"text": "Such formulas are allowed in languages like HiLog , which support predicate constructors like closure in our example .More general formulas are constructed out of atomic formulas with the help of logical connectives .RIF 's Basic Condition Language defines the following general well - formed formulas .", "label": "", "metadata": {}, "score": "43.494827"}
{"text": "REFERENCES .Fetzer , J. H. ( 1993a )Van Brakel 's Position Appears to be Incoherent .PSYCOLOQUY 4(14 ) frame - problem.4 .Ford , K.M. & Hayes , P.J. ( 1991 )Reasoning Agents in a Dynamic World : The Frame Problem , Greenwich : JAI Press .", "label": "", "metadata": {}, "score": "43.514553"}
{"text": "Given unique variable naming , the declaration of any non - outer - variable ( ie , any variable within a scope box ) may be moved to the closest enclosing allocation - contour without changing its semantics .A lexical - composite is a group of objects defined in the same allocation - contour .", "label": "", "metadata": {}, "score": "43.635727"}
{"text": "Note , however , that if the optional argument NO - FALLBACK is non - nil , the fallback value will not be consulted .Note that there may be more than one specification matching a particular locale ; all such specifications are considered before looking for any specifications for more general locales .", "label": "", "metadata": {}, "score": "43.69014"}
{"text": "More precisely , .I isa gives meaning to class membership .The truth valuation for classification formulas of the form o # cl , where o and cl are terms , is defined as follows : .We also want # and # # to have the usual property that all members of a subclass are also members of the superclass , i.e. , we want o # cl and cl # # scl to imply o # scl .", "label": "", "metadata": {}, "score": "43.7154"}
{"text": "Query is an object whose properties restrict which scripts are returned ; a script must meet all the criteria given by query to be returned .If query is omitted , we return the url values of all debuggee scripts .The script must be in the scope of the given global object .", "label": "", "metadata": {}, "score": "43.763515"}
{"text": "Since common optimizations ( say , the \" null closure \" closure representation ) make environments that one would expect to be present , given the source code , unavailable at run time , Debugger .Environment should provide ways to reflect what is and is not available .", "label": "", "metadata": {}, "score": "43.854343"}
{"text": "Section Positive Conditions defined the notion of semantic structures and how such structures determine truth values of RIF conditions .The current section defines what it means for such a structure to satisfy a rule .While semantic structures can be multivalued in RIF dialects that extend the BLD , rules are typically two - valued even in dialects that support inconsistency and uncertainty .", "label": "", "metadata": {}, "score": "43.898514"}
{"text": "Section Positive Conditions defined the notion of semantic structures and how such structures determine truth values of RIF conditions .The current section defines what it means for such a structure to satisfy a rule .While semantic structures can be multivalued in RIF dialects that extend the BLD , rules are typically two - valued even in dialects that support inconsistency and uncertainty .", "label": "", "metadata": {}, "score": "43.898514"}
{"text": "Rationale : There are several equivalent ways to define first - order semantic structures .The one we adopted has the advantage that it generalizes to rule sets with negation as failure ( NAF ) and to logics for dealing with uncertainty and inconsistency .", "label": "", "metadata": {}, "score": "43.970245"}
{"text": "Rationale : There are several equivalent ways to define first - order semantic structures .The one we adopted has the advantage that it generalizes to rule sets with negation as failure ( NAF ) and to logics for dealing with uncertainty and inconsistency .", "label": "", "metadata": {}, "score": "43.970245"}
{"text": "Free variables arise because CONDITION can occur in an if part of a rule .When this happens , the free variables in a condition formula are precisely those variables that also occur in the then part of the rule .We shall see in Section Horn Rules that such variables are quantified universally outside of the rule , and the scope of such quantification is the entire rule .", "label": "", "metadata": {}, "score": "44.096336"}
{"text": "When t , p i , or v i are not just terms but frame formulas themselves , the above is treated as a conjunction of simpler frame formulas , as defined by the unnest transformation in the section on semantics ( below ) .", "label": "", "metadata": {}, "score": "44.379322"}
{"text": "When t , p i , or v i are not just terms but frame formulas themselves , the above is treated as a conjunction of simpler frame formulas , as defined by the unnest transformation in the section on semantics ( below ) .", "label": "", "metadata": {}, "score": "44.379322"}
{"text": "The precise syntax for RIF constants is given in Section Primitive Data Types .At this point we do not commit to any particular vocabulary for the names of variables .These are assumed to be alphanumeric character sequences starting with a ? -sign .", "label": "", "metadata": {}, "score": "44.44581"}
{"text": "This is what Harnad ( 1990 ) calls the ' symbol grounding problem ' \" ( Hayes & Ford 1993 : 4.2 ) .The symbol grounding problem is not just the problem of attaching formal symbols to the world , for an UNGROUNDED symbol system ( like English or geometry ) will serve that purpose admirably well ( as long as it has the right formal , syntactic properties ) .", "label": "", "metadata": {}, "score": "44.506886"}
{"text": "The value space of a data type should not be confused with the lexical space .Lexical spaces define the syntax of the constant symbols that belong to the various primitive data types .In contrast , value spaces define the meaning of the constants in data types .", "label": "", "metadata": {}, "score": "44.511826"}
{"text": "The other choices regarding semantic compatibility are similar to those for OWL Full : .The combination is based on correspondence of models .However , such a combination would not be suited for rule - based processing ; i.e. , there is no embedding of such a combination in RIF .", "label": "", "metadata": {}, "score": "44.73989"}
{"text": "First , as mentioned above , each constant and variable symbol is associated with exactly one signature from a coherent set of signatures .Different symbols can be associated with the same signature , but no symbol can be associated with more than one signature .", "label": "", "metadata": {}, "score": "44.761276"}
{"text": "See ' copy - specifier ' and ' add - spec - to - specifier ' for a description of what each of these means .Most of the time , you do not need to worry about this argument ; the default behavior usually is fine .", "label": "", "metadata": {}, "score": "44.792175"}
{"text": "See ' copy - specifier ' and ' add - spec - to - specifier ' for a description of what each of these means .Most of the time , you do not need to worry about this argument ; the default behavior usually is fine .", "label": "", "metadata": {}, "score": "44.792175"}
{"text": "Therefore , the signature can be determined from the context in which the symbol is used .If a symbol is used in more than one context , the parser should treat it as a syntax error .If no errors are found , all uniterms and atomic formulas are guaranteed to be well - formed .", "label": "", "metadata": {}, "score": "44.847534"}
{"text": "RDFS , . and .RDFS ) .D ) .The definitions are all analogous .A simple interpretation I of a vocabulary V is an rdf - interpretation if V includes the RDF vocabulary and the conditions on rdf - interpretations described in the [ RDF - Semantics ] document hold for I. .", "label": "", "metadata": {}, "score": "45.084373"}
{"text": "That is , the interpretation allows to map any IRI into any value in the domain of the semantic structure .Thus , local constants can denote any element of the domain of discourse , including integers , strings , etc . .", "label": "", "metadata": {}, "score": "45.08824"}
{"text": "In most circumstances , you should not use this function ; use ' specifier - instance ' instead .This attempts to instantiate INST - LIST in the given DOMAIN \\(as if INST - LIST existed in a specification in SPECIFIER ) , matching the specifications against MATCHSPEC .", "label": "", "metadata": {}, "score": "45.11705"}
{"text": "First , they are not assigned any value space .Thus , such symbol spaces are not considered to be primitive data types by RIF even though they may be viewed as data types by some concrete rule languages that use RIF for exchange .", "label": "", "metadata": {}, "score": "45.129715"}
{"text": "features make RIF a Web language .However , RIF is designed to enable interoperability among rule languages in general , and its uses are not limited to the Web .The semantics of RIF has provisions for future extensions towards dialects that support pure FOL , dialects that support negation as failure ( NAF ) , business ( or production ) rules , reactive rules , and other features .", "label": "", "metadata": {}, "score": "45.182182"}
{"text": "A RIF - producing system includes a RIF compliant inference engine and a transformation from the language of that engine into valid RIF XML format .Such an engine must support all the symbol spaces that are mentioned in the documents produced by the aforesaid transformation .", "label": "", "metadata": {}, "score": "45.4502"}
{"text": "A canonical definition of this corresponding URI enables the reconstruction of the original ill - typed literal , e.g. for round - tripping .Agreement needs to be reached on what this URI looks like .The equivalent of blank nodes in RIF are existentially quantified variables in the body of the rule .", "label": "", "metadata": {}, "score": "45.534355"}
{"text": "In contrast to first - order logic , most rule - based systems do not consider p and q symmetrically .Instead , they view the rule p : - naf q as a statement that p must be true if it is not possible to establish the truth of q .", "label": "", "metadata": {}, "score": "45.858437"}
{"text": "In contrast to first - order logic , most rule - based systems do not consider p and q symmetrically .Instead , they view the rule p : - naf q as a statement that p must be true if it is not possible to establish the truth of q .", "label": "", "metadata": {}, "score": "45.858437"}
{"text": "Builtin predicates are not subject to the above signature inference rule .The signatures of the builtin predicates are defined by List_of_functions_and_operators .In dialects that extend RIF - BLD , signature inference may not always be possible .We expect that most dialects will use signature inference and RIF does not define any special sublanguage for signatures .", "label": "", "metadata": {}, "score": "45.909363"}
{"text": "A nested frame represents a conjunction of flat frames .For instance , .Formally , given a frame , f , we define the Unnest transformation and postulate f to be true in a semantic structure iff Unnest(f ) is true .", "label": "", "metadata": {}, "score": "46.162792"}
{"text": "Buyer ?P ( ? inst # class . sub # # super .The syntax of RIF frames permits nesting of two kinds .First , a classification formula of the form obj1 # obj2 or obj1 # # obj2 can appear in the object position of a frame .", "label": "", "metadata": {}, "score": "46.173187"}
{"text": "Fields are implemented by indexing into the frame containing that field .From directly within an object , a field of this object 's object - frame is an instance - variable .\" value \" is a Field of the above lexical composite .", "label": "", "metadata": {}, "score": "46.179165"}
{"text": "the datatype map D corresponds to the fixed datatype map of RIF , D RIF .We define the notion of common interpretation , which is an interpretation of both an RIF rule sets and an RDF graph .This common interpretation is the basis for the semantic definitions in the following sections .", "label": "", "metadata": {}, "score": "46.33158"}
{"text": "VARNAME .A CLASSIFICATION specifies that one object is a member ( in case of the # -connective ) or a subclass ( in case of the # # -connective ) of another object .Example 3 shows Uniterm and Frame conditions , the latter with variables for the three major ( combinations of ) syntactic categories , corresponding to the three components of RDF triples .", "label": "", "metadata": {}, "score": "46.34233"}
{"text": "However , only \" value \" is used freely by any of the lexical - facets , so the lexical - composite 's frame holds just this one variable .We now distinguish along several dimensions of kinds of variables usage .", "label": "", "metadata": {}, "score": "46.37583"}
{"text": "At any point , a symbol system has only dealt with a small amount of data ( relative to human scale performance ) .That 's why such systems are often called \" toy \" systems .Yet in projecting a systematic ( usually natural - language ) interpretation onto such a toy , one is at the same time OVERinterpreting it ( typically overinterpreting it mentalistically , in terms of what it \" knows , \" \" thinks , \" \" means \" ) .", "label": "", "metadata": {}, "score": "46.461693"}
{"text": "They act like macros and are not visible in instance markup .For the XML Schema Definition ( XSD ) of the RIF - BLD condition language see Appendix Specification .The XML syntax for symbol spaces utilizes the type attribute associated with XML term elements such as Const .", "label": "", "metadata": {}, "score": "46.53283"}
{"text": "This nested notation is convenient and allows succinct representation of object properties , but is no more than a shorthand notation .A nested frame represents a conjunction of flat frames .For instance , .Formally , given a frame , f , we define the Unnest transformation and postulate f to be true in a semantic structure iff Unnest(f ) is true .", "label": "", "metadata": {}, "score": "46.56886"}
{"text": "Any value , get , and set properties of attributes must be debuggee values .( This function behaves like Object.defineProperty , except that the target object is implicit , and in a different compartment from the function and descriptor . )", "label": "", "metadata": {}, "score": "46.597893"}
{"text": "( Are there any other cases ? )A Fast variable is one for whom the compiler was able to determine that a Box was necessary .The variable 's value may be stored where the reference to the Box would have been stored , and it is accessed and assigned by C++-level access and assignment to this location .", "label": "", "metadata": {}, "score": "46.629417"}
{"text": "They are not limited to the constituents of a single syntactic tree .Meaning , they span what has been considered as the building blocks of language .They specify at the same time syntactic , lexical , semantic and pragmatic information .", "label": "", "metadata": {}, "score": "46.67964"}
{"text": "Otherwise , this function is identical to ' specifier - spec - list ' .The \" short form \" is designed for readability and not for ease of use in Lisp programs , and is as follows : 1 .If there is only one instantiator , then an inst - pair ( i.e. cons of tag and instantiator ) will be returned ; otherwise a list of inst - pairs will be returned .", "label": "", "metadata": {}, "score": "46.71249"}
{"text": "Signatures in the RIF Basic Condition Language .RIF 's basic condition language presents a much simpler picture to the user by restricting the set of well - formed terms to a specific coherent set of signatures .Namely , the signature set of RIF 's basic logic language contains the following signatures : .", "label": "", "metadata": {}, "score": "46.77755"}
{"text": "Similarly , the objects defined within a lexical composite are deemed lexical - facets .The objects defined directly within a lexical composite ( ie , not nested within an inner allocation contour ) are direct - lexical - facets of the lexical composite .", "label": "", "metadata": {}, "score": "46.87873"}
{"text": "See also ' specifier - matching - instance ' for a fuller description of the matching process . \"NOTE :If you want to remove a property from a face , use ' remove - face - property ' rather than attempting to set a value of nil for the property .", "label": "", "metadata": {}, "score": "46.976845"}
{"text": "See also ' specifier - matching - instance ' for a fuller description of the matching process . \"NOTE :If you want to remove a property from a face , use ' remove - face - property ' rather than attempting to set a value of nil for the property .", "label": "", "metadata": {}, "score": "46.976845"}
{"text": "Finally , if LOCALE is ' all , the specifications for all locales of all types will be returned .The specifications in a specifier determine what the value of PROPERTY will be in a particular \\\"domain\\ \" or set of circumstances , which is typically a particular Emacs window along with the buffer it contains and the frame and device it lies within .", "label": "", "metadata": {}, "score": "47.014732"}
{"text": "Finally , if LOCALE is ' all , the specifications for all locales of all types will be returned .The specifications in a specifier determine what the value of PROPERTY will be in a particular \\\"domain\\ \" or set of circumstances , which is typically a particular Emacs window along with the buffer it contains and the frame and device it lies within .", "label": "", "metadata": {}, "score": "47.014732"}
{"text": "In these cases , we expect those dialects to introduce their own primitives for defining signatures .The central syntactic class of RIF , CONDITION , is specified recursively through its subclasses and their parts .The Equal class has two side roles .", "label": "", "metadata": {}, "score": "47.1033"}
{"text": "In the two - valued case , a set of objects associated with the truth value true represents the ( set of ) values that the slot returns when applied to an object .Formally , this is expressed by extending I Truth to flat frames as follows : .", "label": "", "metadata": {}, "score": "47.1824"}
{"text": "This draft also introduces a frame - based syntax and semantics and defines a normative way for RIF rules to interact with RDF . semantics . is . designed .for . modularity . and . to . enable .further . extensions .", "label": "", "metadata": {}, "score": "47.18531"}
{"text": "Here are some examples : -- For chartable ( e.g. display table ) specifiers , MATCHSPEC should be a character , and the specification ( a chartable ) must give a value for that character in order to be considered .This allows you to specify , e.g. , a buffer - local display table that only gives values for particular characters .", "label": "", "metadata": {}, "score": "47.2025"}
{"text": "The three classes Var , CONDITION , and ATOMIC are used in the syntax of Horn Rules .We now give an EBNF for the RIF presentation syntax .This syntax is somewhat abstract in nature .In particular , it does not address the concrete details of how constants and variables are represented .", "label": "", "metadata": {}, "score": "47.208042"}
{"text": "COLOR should be an instantiator ( see ' color - specifier - p ' ) , a list of instantiators , an alist of specifications ( each mapping a locale to an instantiator list ) , or a color specifier object .", "label": "", "metadata": {}, "score": "47.291172"}
{"text": "COLOR should be an instantiator ( see ' color - specifier - p ' ) , a list of instantiators , an alist of specifications ( each mapping a locale to an instantiator list ) , or a color specifier object .", "label": "", "metadata": {}, "score": "47.291172"}
{"text": "COLOR should be an instantiator ( see ' color - specifier - p ' ) , a list of instantiators , an alist of specifications ( each mapping a locale to an instantiator list ) , or a color specifier object .", "label": "", "metadata": {}, "score": "47.291172"}
{"text": "COLOR should be an instantiator ( see ' color - specifier - p ' ) , a list of instantiators , an alist of specifications ( each mapping a locale to an instantiator list ) , or a color specifier object .", "label": "", "metadata": {}, "score": "47.291172"}
{"text": "In particular , it might be used as a sublanguage for specifying the conditional part in the bodies of production rules ( RIF PRD ) , reactive rules , and normative rules .As mentioned , IRI constants are used in RIF both as logical constants and as names for predicate and function symbols .", "label": "", "metadata": {}, "score": "47.29605"}
{"text": "Here , Nil is a special singleton class .The properties ( \" role stripes \" ) arg1 and arg2 at the same time suggest minimal use of positional information in concrete syntaxes : the natural order of the two elements of a LIST that is a PAIR .", "label": "", "metadata": {}, "score": "47.31682"}
{"text": "Script instances for all debuggee scripts .The script must include given column on the line given by the line property .If this property is present , the url and line properties must both be present as well .The script must be in the scope of the given global object .", "label": "", "metadata": {}, "score": "47.3336"}
{"text": "Formally , terms are defined as follows : .Constants and variables .Positional terms .If t and t 1 , ... , t n are terms then t(t 1 ... t n ) is a positional term .Positional terms in RIF - FLD generalize the regular notion of a term used in first - order logic .", "label": "", "metadata": {}, "score": "47.38413"}
{"text": "In particular , it might be used as a sublanguage for specifying the conditional part in the bodies of production rules ( PRD ) , reactive rules , and normative rules .As mentioned , IRI constants are used in RIF both as logical constants , as names of predicate , and of function symbols .", "label": "", "metadata": {}, "score": "47.395065"}
{"text": "However , this feature is just a syntactic sugar that does not extend the expressive power .Slotted terms are like regular terms except that the arguments are named and their order is considered to be immaterial .In order to talk about the slotted terms that are also well - formed , we need to extend the notion of a signature to include slots .", "label": "", "metadata": {}, "score": "47.434296"}
{"text": "The condition language is then extended to Horn rules and this document specifies a presentation syntax and a corresponding concrete XML syntax for RIF - BLD .A model - theoretic semantics for the language is also defined .May Be Superseded .", "label": "", "metadata": {}, "score": "47.434345"}
{"text": "Example : ' a local symbol ' .In this notation , single quotes and backslashes that occur inside such strings are escaped with backslashes .Other XML data types that are likely to be incorporated in RIF include xsd : double , xsd : date , and a type for temporal duration .", "label": "", "metadata": {}, "score": "47.553207"}
{"text": "Finally , CONDITION assembles everything into what we call RIF conditions .RIF dialects will extend these conditions in various ways .Note that individuals , function symbols , and predicate symbols all belong to the same set of symbols ( Const ) .", "label": "", "metadata": {}, "score": "47.765068"}
{"text": "In form ( b ) , the variables that do not appear in the rule then part are instead quantified existentially in the if part .These two forms are logically equivalent .EDITORS ' NOTE :The XML syntax for BLD presented here is one of the proposals the Working Group is considering .", "label": "", "metadata": {}, "score": "47.813286"}
{"text": "Formally , this is expressed by extending I Truth to flat frames as follows : .I SF interprets terms with named arguments .This is analogous to the interpretation of regular ( positional ) . terms , . immaterial , .", "label": "", "metadata": {}, "score": "47.8217"}
{"text": "Other values that are legal as a locale ( e.g. a buffer ) are not valid as a domain because they do not provide enough information to identify a particular device ( see ' valid - specifier - domain - p ' ) .", "label": "", "metadata": {}, "score": "47.888607"}
{"text": "The current frame must be a generator frame that has not yet completed in some other way .You may use yield resumption values to substitute a new value or one already yielded by a generator , or to make a generator yield additional values .", "label": "", "metadata": {}, "score": "48.013363"}
{"text": "INST - LIST ) is called a ' specification ' or ' spec ' .A spec - list , then , can be viewed as a list of specifications .HOW - TO - ADD specifies how to combine the new specifications with the existing ones , and has the same semantics as for ' add - spec - to - specifier ' .", "label": "", "metadata": {}, "score": "48.0198"}
{"text": "First , as mentioned above , each symbol ( constant or variable ) is associated with exactly one signature from a coherent set of signatures .( Different symbols can be associated with the same signature , but one symbol can not be associated with more than one signature . )", "label": "", "metadata": {}, "score": "48.031586"}
{"text": "To make RIF dialects suitable as Web languages , RIF supports XML Schema and some other primitive data types .In addition , RIF promotes the use of .To ensure extensibility and to provide for future higher - order dialects based on formalisms , such as HiLog and Common Logic , the RIF logic language does not draw sharp boundary between the symbols used to denote individuals from symbols used as names for functions or predicates .", "label": "", "metadata": {}, "score": "48.074936"}
{"text": "Normally DOMAIN will be a window or nil ( meaning the selected window ) , and an instance object describing how the background appears in that particular window and buffer will be returned .See ' face - property - instance ' for more information . \"", "label": "", "metadata": {}, "score": "48.088863"}
{"text": "Normally DOMAIN will be a window or nil ( meaning the selected window ) , and an instance object describing how the background appears in that particular window and buffer will be returned .See ' face - property - instance ' for more information . \"", "label": "", "metadata": {}, "score": "48.088863"}
{"text": "Normally DOMAIN will be a window or nil ( meaning the selected window ) , and an instance object describing how the background appears in that particular window and buffer will be returned .See ' face - property - instance ' for more information . \"", "label": "", "metadata": {}, "score": "48.088863"}
{"text": "Normally DOMAIN will be a window or nil ( meaning the selected window ) , and an instance object describing how the background appears in that particular window and buffer will be returned .See ' face - property - instance ' for more information . \"", "label": "", "metadata": {}, "score": "48.088863"}
{"text": "v ( a c ) p ) is also a term .To control the context in which any given symbol can occur in a RIF dialect , the language associates a signature with each symbol ( both constant and variable symbols ) .", "label": "", "metadata": {}, "score": "48.1688"}
{"text": "\\(The valid device types and device classes are always tags , as are any tags defined by ' define - specifier - tag ' . )It is called a \" tag set \" \\(as opposed to a list ) because the order of the tags or the number of times a particular tag occurs does not matter .", "label": "", "metadata": {}, "score": "48.179718"}
{"text": "I SR is used to interpret predicates with slotted arguments .This is analogous to the interpretation of regular ( positional ) predicates except for two differences : .A . tuple . in .The . argument . to .a slotted predicate is a finite bag of . slot - value . slot / value . pairs rather than an ordered sequence .", "label": "", "metadata": {}, "score": "48.187965"}
{"text": "Pop any younger frames from the stack , and then change this frame into a frame for a call to function , with the given this value and arguments .Arguments should be an array of debuggee values .This frame must be a \" call \" frame .", "label": "", "metadata": {}, "score": "48.244034"}
{"text": "DOMAIN can be a frame or device , instead of a window .The value returned for a such a domain is used in special circumstances when a more specific domain does not apply ; for example , a frame value might be used for coloring a toolbar , which is conceptually attached to a frame rather than a particular window .", "label": "", "metadata": {}, "score": "48.267693"}
{"text": "DOMAIN can be a frame or device , instead of a window .The value returned for a such a domain is used in special circumstances when a more specific domain does not apply ; for example , a frame value might be used for coloring a toolbar , which is conceptually attached to a frame rather than a particular window .", "label": "", "metadata": {}, "score": "48.267693"}
{"text": "If LOCALE is a locale type , the specifications for all locales of that type will be copied .LOCALE can also be a list of locales , locale types , and/or ' all ; this is equivalent to calling ' copy - specifier ' for each of the elements of the list .", "label": "", "metadata": {}, "score": "48.290222"}
{"text": "( In the terms used by the ECMAScript specification , the VariableEnvironment of the execution context for the eval code is the VariableEnvironment this environment represents , and the bindings appear in a new declarative environment , which is the eval code 's LexicalEnvironment . )", "label": "", "metadata": {}, "score": "48.344078"}
{"text": "If LOCALE is omitted , the FACE 's actual value for PROPERTY will be returned .For built - in properties , this will be a specifier object of a type appropriate to the property ( e.g. a font or color specifier ) .", "label": "", "metadata": {}, "score": "48.355667"}
{"text": "If LOCALE is omitted , the FACE 's actual value for PROPERTY will be returned .For built - in properties , this will be a specifier object of a type appropriate to the property ( e.g. a font or color specifier ) .", "label": "", "metadata": {}, "score": "48.355667"}
{"text": "It makes no distinction between constant symbols that represent individuals , predicates , and function symbols .The same symbol can occur in multiple contexts at the same time .For instance , p(p(a ) p(a b c ) ) is a term .", "label": "", "metadata": {}, "score": "48.36376"}
{"text": "Frame methods and accessor properties work as described on generator frames , even when the generator frame is suspended .You may examine a suspended generator frame 's variables , and use its script and offset members to see which yield it is suspended at .", "label": "", "metadata": {}, "score": "48.465218"}
{"text": "All bound variables that occur in the rule are implicitly or explicitly universally quantified outside of the rule .The class Ruleset contains zero or more RULE s , where each RULE is one of the following classes : .Implies , which distinguishes if - CONDITION from then - ATOMIC parts .", "label": "", "metadata": {}, "score": "48.49712"}
{"text": "Both of those articles give ample examples of how constructions work and what they do and I commend them to your linguistic enjoyment .Once more with meaning : the FrameNet years .Both frame semantics and construction grammar impacted Fillmore 's work in lexicography with Sue Atkins and culminated in FrameNet a machine readable frame semantic dictionary providing a model for a semantic module to a construction grammar .", "label": "", "metadata": {}, "score": "48.60222"}
{"text": "Return a property descriptor for the property named name of the referent .If the referent has no such property , return undefined .Return an array of strings naming all the referent 's own properties , as if Object.getOwnPropertyNames(referent ) had been called in the debuggee , and the result copied in the scope of the debugger 's global object .", "label": "", "metadata": {}, "score": "48.613953"}
{"text": "symbols are drawn from the same universal set .RIF dialects control the contexts in which the different symbols can occur by attaching signatures to these symbols .RIF 's basic logic dialect carefully selects signatures for the symbols so that the corresponding logic will be first - order : each symbol has a unique role as an individual , a function symbol of a particular arity , or a predicate symbol of a particular arity .", "label": "", "metadata": {}, "score": "48.68531"}
{"text": "In RIF 's basic Logic dialect , there is no need to declare signatures , since they can be inferred .Indeed , the basic logic dialect . assumes . requires .that each symbol is associated with a unique signature .", "label": "", "metadata": {}, "score": "48.692505"}
{"text": "The preliminary suggestion for the specification of combinations , as well as entailment regimes , through meta data in RIF rule sets was formulated in a preliminary section in the architecture document .Given an RDF vocabulary V and a set of blank nodes B , disjoint from the symbols in V , an RDF graph is a set of RDF triples s p o . , where s is either a blank node or a URI reference , p is a URI reference , and o is a blank node , a URI reference , a plain literal , or a typed literal ; see also RDF - Concepts .", "label": "", "metadata": {}, "score": "48.74211"}
{"text": "Since Debugger instances do n't hold strong references to their debuggee globals , if a debuggee global is otherwise unreachable , it may be dropped at any moment from the array this method returns .Return an array containing the values of the url properties of all debuggee scripts matching query .", "label": "", "metadata": {}, "score": "48.78985"}
{"text": "It can be represented by an IRI or be known only locally .Semantically , a frame slot is a set - valued function that represents a property of an object .Such a function maps an object i d to a set of values of the property .", "label": "", "metadata": {}, "score": "48.81066"}
{"text": "Truth valuation of formulas .Observe that the notion of signatures from Section Symbols and Signatures is used only to constrain the syntax and does not appear in the definition of the semantic structure .This is because when we define truth valuations for formulas , below , all formulas are assumed to be well - formed .", "label": "", "metadata": {}, "score": "48.8222"}
{"text": "We illustrate the above definitions with the following examples .Consider the term p(p(a ) p(a b c ) ) .Then r(r(a ) r ( a b c ) ) is well - formed .The interesting twist here is that r(a ) is an atomic formula that occurs as an argument to a function symbol .", "label": "", "metadata": {}, "score": "48.8322"}
{"text": "Frames not matching these propertiess should have frame local faces .The value should be nil , if uninitialized , or a plist otherwise .See ' defface ' for a list of valid keys and values for the plist . \" ) ( defun get - custom - frame - properties ( & optional frame ) \" Return a plist with the frame properties of FRAME used by custom .", "label": "", "metadata": {}, "score": "48.8599"}
{"text": "Frames not matching these propertiess should have frame local faces .The value should be nil , if uninitialized , or a plist otherwise .See ' defface ' for a list of valid keys and values for the plist . \" ) ( defun get - custom - frame - properties ( & optional frame ) \" Return a plist with the frame properties of FRAME used by custom .", "label": "", "metadata": {}, "score": "48.8599"}
{"text": "See ' specifier - matching - instance ' for a description of matchspecs .If a Lisp caller wants to set a fallback , they should just set the global value .By design , you can not change the fallback value , and specifiers created with ' make - specifier ' will never have a fallback ( although a similar , Lisp - accessible capability may be provided in the future to allow for inheritance ) .", "label": "", "metadata": {}, "score": "48.864914"}
{"text": "Recall that if \u03c3 is a signature then \u03c3 # denotes its name .A slotted formula is just like an atomic formula of Section Formal Preliminaries except that the arguments of the predicate are named and their order is considered immaterial .", "label": "", "metadata": {}, "score": "48.8852"}
{"text": "For the Horn subset , Q is a universal prefix , i.e. , all variables in the rule are universally quantified outside of the rule .We first define the notion of rule satisfaction without the quantification prefix Q : .In this case we also say that I is a model of the rule .", "label": "", "metadata": {}, "score": "48.896835"}
{"text": "For the Horn subset , Q is a universal prefix , i.e. , all variables in the rule are universally quantified outside of the rule .We first define the notion of rule satisfaction without the quantification prefix Q : .In this case we also say that I is a model of the rule .", "label": "", "metadata": {}, "score": "48.896835"}
{"text": "Frames .A well - formed frame formula is one of the following : .Membership formula : o # c , where o , c are well - formed terms .Informally , such a formula says that object o is a member of class c .", "label": "", "metadata": {}, "score": "48.949028"}
{"text": "Frames .A well - formed frame formula is one of the following : .Membership formula : o#c , where o , c are well - formed terms .Informally , such a formula says that object o is a member of class c .", "label": "", "metadata": {}, "score": "48.949028"}
{"text": "In that case specifications are searched for as follows : 1 .A specification whose locale is the window itself ; 2 .A specification whose locale is the window 's buffer ; 3 .A specification whose locale is the window 's frame ; 4 .", "label": "", "metadata": {}, "score": "48.982452"}
{"text": "More general formulas are constructed out of atomic formulas with the help of logical connectives .The condition sublanguage of RIF - BLD defines the following general well - formed condition formulas .If \u03c6 is a well - formed atomic formula then it is also a well - formed condition formula .", "label": "", "metadata": {}, "score": "48.99887"}
{"text": "The aforesaid term t is a well - formed slotted atomic formula if \u03c3 is atomic .A slotted atomic formula is just like an atomic formula of Section Symbols and Signatures except that the arguments of the predicate are named and their order is considered immaterial .", "label": "", "metadata": {}, "score": "49.118576"}
{"text": "We will continue to use Const to refer to the set of all constant symbols and Var to refer to the set of all variable symbols .The other components of I are mappings defined as follows : .I C from Const to elements of D .", "label": "", "metadata": {}, "score": "49.13614"}
{"text": "In such a case , the instantiator used to create that instance object will be used ( for example , if you set a font - instance object as the value of the ' font property , then the font name used to create that object will be used instead ) .", "label": "", "metadata": {}, "score": "49.152336"}
{"text": "In such a case , the instantiator used to create that instance object will be used ( for example , if you set a font - instance object as the value of the ' font property , then the font name used to create that object will be used instead ) .", "label": "", "metadata": {}, "score": "49.152336"}
{"text": "All methods are optional , and reasonable default methods will be\\n \" \" provided .Currently there are two defined methods : ' instantiate and\\n \" \" ' validate .\\n \" \" \\n \" \" ' instantiate specifies how to do the instantiation ; if omitted , the\\n \" \" instantiator itself is simply returned as the instance .", "label": "", "metadata": {}, "score": "49.236397"}
{"text": "Frame.prototype.environment to return more complete environment chains than Debugger . Object.prototype.environment .This possibility should be documented , along with its effects on environment identity .The interface should provide clean , predictable ways to observe the effects of garbage collection .", "label": "", "metadata": {}, "score": "49.244705"}
{"text": "From a theoretical perspective , RIF - BLD corresponds to the language of definite Horn rules ( see Horn Logic ) with equality and with a standard first - order semantics .Syntactically , RIF - BLD has a number of extensions to support features such as objects and frames , internationalized resource identifiers ( or IRIs , defined by RFC 3987 ) as identifiers for concepts , and XML Schema data types .", "label": "", "metadata": {}, "score": "49.44261"}
{"text": "The tags which are device types and classes match devices of that type or class .User - defined tags can have any predicate , or none ( meaning that all devices match ) .When attempting to instance a specifier , a particular instantiator is only considered if the device of the domain being instanced over matches all tags in the tag set attached to that instantiator .", "label": "", "metadata": {}, "score": "49.4503"}
{"text": "( This function behaves like Object.defineProperties , except that the target object is implicit , and in a different compartment from the properties argument . )Prevent properties from being added to or deleted from the referent .Return this Debugger .", "label": "", "metadata": {}, "score": "49.45456"}
{"text": "RIF dialects control the contexts in which the different symbols can occur by attaching signatures to these symbols .RIF - BLD carefully selects signatures for the symbols so that the corresponding logic will be first - order : each symbol has a unique role as a symbol that represents an individual object , a function symbol of a particular arity , or a predicate symbol of a particular arity .", "label": "", "metadata": {}, "score": "49.51523"}
{"text": "If LOCALE is nil or ' all , a spec - list of all specifications in SPECIFIER will be returned .LOCALE can also be a list of locales , locale types , and/or ' all ; the result is as if ' specifier - spec - list ' were called on each element of the list and the results concatenated together .", "label": "", "metadata": {}, "score": "49.59873"}
{"text": "Like other . predicates , . predicates .it has a signature , . which . and .this . signature .The equality predicate has special model - theoretic semantics , as explained in Section Model Theory for RIF 's Basic Condition Language .", "label": "", "metadata": {}, "score": "49.619972"}
{"text": "To define how semantic structures determine the truth values of RIF formulas , we introduce the following sets : .D - a non - empty set of elements called the domain of I , .Const - the set of individuals , predicate names , and function symbols , .", "label": "", "metadata": {}, "score": "49.668114"}
{"text": "Put another way , deslotifying , and the other optimizations below , can be seen as special - cases for Slots of various general purpose optimizations .Following this transformation , our variable usages may now be further classified according to where their storage is allocated .", "label": "", "metadata": {}, "score": "49.69465"}
{"text": "The basic language construct is called term , which is defined inductively as follows : .If t and t 1 , ... , t n are terms then t ( t 1 ... t n ) is a term .This definition is very general .", "label": "", "metadata": {}, "score": "49.69853"}
{"text": "A slot can be represented by an individual symbol or , more generally , by a Uniterm .It can be represented by an IRI or be known only locally .Semantically , a frame slot is a set - valued function that represents a property of an object .", "label": "", "metadata": {}, "score": "49.70464"}
{"text": "DEVICE defaults to the selected device if omitted .This includes the built - in ones ( the device types and classes ) .If EXACT_P is 0 , A must be a subset of B. Otherwise , A must be ' equal ' to B. The sets must be canonicalized .", "label": "", "metadata": {}, "score": "49.739273"}
{"text": "The arguments passed to the current frame , or null if this is not a \" call \" frame .When non - null , this is an object , allocated in the same global as the debugger , with Array.prototype on its prototype chain , a non - writable length property , and properties whose names are array indices .", "label": "", "metadata": {}, "score": "49.76082"}
{"text": "McCarthy , J and Hayes , P ( 1969 )Some philosophical problems from the standpoint of Artificial Intelligence .In B. Meltzer & D. Michie ( eds ) Machine Intelligence 4 .Elsevier .van Brakel , J. ( 1992 )", "label": "", "metadata": {}, "score": "49.796867"}
{"text": "First of all , it is used by RIF BLD , as described in this document .The other future dialects or groups of dialects where the Condition Language or its extensions might be used include : .Rule bodies and queries in declarative logic programming dialects ( LP ) .", "label": "", "metadata": {}, "score": "49.822147"}
{"text": "Normally DOMAIN will be a window or nil ( meaning the selected window ) , and an instance object describing how the foreground appears in that particular window and buffer will be returned .See ' face - property - instance ' for more information . \"", "label": "", "metadata": {}, "score": "49.86313"}
{"text": "Normally DOMAIN will be a window or nil ( meaning the selected window ) , and an instance object describing how the foreground appears in that particular window and buffer will be returned .See ' face - property - instance ' for more information . \"", "label": "", "metadata": {}, "score": "49.86313"}
{"text": "This process is called \\\"instantiation\\ \" .To put settings into a specifier , use ' set - specifier ' , or the lower - level functions ' add - spec - to - specifier ' and ' add - spec - list - to - specifier ' .", "label": "", "metadata": {}, "score": "50.000694"}
{"text": "This allows the code using each Debugger instance to place whatever properties it likes on its Debugger .Frame instances , without worrying about interfering with other debuggers . )Note that frames only become inactive at times that are predictable for the debugger : when the debuggee runs , or when the debugger removes frames from the stack itself .", "label": "", "metadata": {}, "score": "50.025814"}
{"text": "To this end , we require that the mapping I sub defines a partial order on D .More precisely , .I isa gives meaning to class membership .The truth valuation for classification formulas of the form o#cl , where o and cl are terms , is defined as follows : .", "label": "", "metadata": {}, "score": "50.03216"}
{"text": "Such a combination is hard to process in the general case ( reasoning is undecidable ) .There are , however , several known decidable subsets which impose certain restrictions either on the OWL ontology or the RIF rules .For example , direct rule - based processing can be done by suitably restricting the OWL component to a so - called DLP subset .", "label": "", "metadata": {}, "score": "50.047043"}
{"text": "Notice that the mapping I Truth is uniquely determined by the four mapping comprising I and , therefore , it does not need to be listed explicitly .Interpretation of symbol spaces .We now explain how symbol spaces are integrated into the semantics of the basic RIF logic .", "label": "", "metadata": {}, "score": "50.088753"}
{"text": "Normally DOMAIN will be a window or nil ( meaning the selected window ) , and an instance object describing how the font appears in that particular window and buffer will be returned .See ' face - property - instance ' for more information . \"", "label": "", "metadata": {}, "score": "50.194878"}
{"text": "Normally DOMAIN will be a window or nil ( meaning the selected window ) , and an instance object describing how the font appears in that particular window and buffer will be returned .See ' face - property - instance ' for more information . \"", "label": "", "metadata": {}, "score": "50.194878"}
{"text": "The compiler generates code to access and assign to this variable by directly accessing and assigning to this separately allocated storage .We refer to this separate storage as a Box .An example would be a mutable variable ( one declared \" : settable \" after deslotifying ) that is used by both a direct and an indirect lexical - facet of its defining lexical - composite .", "label": "", "metadata": {}, "score": "50.22587"}
{"text": "( except , possibly , when such a constant is equated to a constant of type rif : iri ) .Symbols with ill - formed lexical part .RIF constant symbols that belong to one of the RIF - supported symbol spaces must be well - formed , i.e. , their lexical form must belong to the lexical space associated with the symbol space .", "label": "", "metadata": {}, "score": "50.336388"}
{"text": "X ?Y ) ) ) .The part of such a symbol that occurs inside the double quotes is called the lexical form of the symbol .The surrounding double quotes are not part of the literal .If a double quote is included as part of a literal , it must be escaped with the backslash .", "label": "", "metadata": {}, "score": "50.42027"}
{"text": "Based on the RIF Use Cases and Requirements , this document develops RIF BLD ( the B asic L ogic D ialect of the R ule I nterchange F ormat ) through a set of foundational concepts . that .RIF dialects .", "label": "", "metadata": {}, "score": "50.587257"}
{"text": "On success , return undefined ; on failure , throw an appropriate exception .Name must be a string whose value is a valid ECMAScript identifier name .Return a reference to the innermost environment , starting with this environment , that binds name .", "label": "", "metadata": {}, "score": "50.62007"}
{"text": "quantifier .The basic language construct is called term , which is defined inductively as follows : .If t and t 1 , ... , t n are terms then t ( t 1 ... t n ) is a term .", "label": "", "metadata": {}, "score": "50.666"}
{"text": "A RIF - consuming system includes a RIF - compliant inference engine and a transformation from RIF XML to the language of the engine .A consumer engine is not required to support all symbol spaces that are subspaces of the symbol spaces supported by the producer engine .", "label": "", "metadata": {}, "score": "50.687088"}
{"text": "operators , in infix or prefix notation .This table is given in the form of binary class2token facts , accessed via a lookup function .The main mapper is given in the form of ( left - to - right oriented ) equations defining abs2con4 g as a binary function with the abstract syntax as first argument , the table as second argument , and the .", "label": "", "metadata": {}, "score": "50.742783"}
{"text": "v ) if ?v is a variable in Var .Truth valuation for formulas .Observe that the notion of signatures from Section Formal Preliminaries is used only to constrain the syntax and does not appear in the definition of the semantic structure .", "label": "", "metadata": {}, "score": "50.788544"}
{"text": "For Locals and Fields , an earlier phase of compilation is the deslotifying source - to - source transformation .In the output of this transformation , all non - outer - variables are declared only \" : settable \" or \" : final \" , to indicate whether or not they 're mutable .", "label": "", "metadata": {}, "score": "50.791397"}
{"text": "We can now define I Truth for slotted predicates as follows : .I sub gives meaning to the subclass relationship .The truth valuation for classification formulas of the form sc##cl , where sc and cl are terms , is defined as follows : .", "label": "", "metadata": {}, "score": "50.844536"}
{"text": "It is a bit of a mouthful but it captures in a paragraph the absolute fundamentals of the semantics of human language as opposed to projecting the rules of formal logic and truth conditions onto an impoverished version of language that all the generative - inspired approaches try to do .", "label": "", "metadata": {}, "score": "50.919197"}
{"text": "Frame Semantics and the nature of language .Annals of the New York Academy of Sciences , 280 ( Origins and Evolution of Language and Speech ) , pp.20 - 32 .Fillmore , C. , 1982 .Frame Semantics .In The Linguistic Society of Korea , ed .", "label": "", "metadata": {}, "score": "50.997963"}
{"text": "If LOCALE specifies a valid domain ( i.e. a window , frame , or device ) , this function instantiates the specifier over that domain , applies FUNC to the resulting instance , and adds the result back as an instantiator for that locale .", "label": "", "metadata": {}, "score": "51.017094"}
{"text": "If LOCALE specifies a valid domain ( i.e. a window , frame , or device ) , this function instantiates the specifier over that domain , applies FUNC to the resulting instance , and adds the result back as an instantiator for that locale .", "label": "", "metadata": {}, "score": "51.017094"}
{"text": "This is analogous to the interpretation of regular ( positional ) terms with two differences : .The argument to a slotted term is a finite bag of slot / value pairs rather than an ordered sequence .Bags are used here because , for slotted terms , the order of slot / value pairs is immaterial , but sets can not be used , since I may happen to map different slots into the same value in D .", "label": "", "metadata": {}, "score": "51.116093"}
{"text": "While FrameNet is much more than that and has very much abandoned the claim to universal deep structures , it can be seen as accomplishing the mission of a language with meaning Fillmore set out on in the 1960s .Remembering Fillmore .", "label": "", "metadata": {}, "score": "51.150883"}
{"text": "Let SigNames be a non - empty , partially - ordered finite or countably infinite set of signature names .We require that this set includes at least the name atomic , which represents the context of atomic formulas .Dialects are free to introduce additional signature names .", "label": "", "metadata": {}, "score": "51.15327"}
{"text": "A constant symbol of the form \" xyz\"^^label is well - formed if its lexical form , xyz belongs to the lexical space associated with the symbol space label .In addition the semantics of a symbol space defines .A non - empty set called the value space of the data type ; and .", "label": "", "metadata": {}, "score": "51.32019"}
{"text": "Rule bodies and queries in declarative logic programming dialects ( LP ) .Rule bodies in first - order dialects ( FO ) .Conditions in the rule bodies of the Production Rule Dialect ( RIF PRD ) .The event and condition parts of the rule bodies in reactive rule dialects ( RR ) .", "label": "", "metadata": {}, "score": "51.33338"}
{"text": "Presentation syntax .This syntax is used in formal definitions , especially for the semantics .It is a human - oriented syntax and , therefore , we use it in the model theory and the examples .The presentation syntax is not meant to be used for exchange of RIF rules .", "label": "", "metadata": {}, "score": "51.333656"}
{"text": "Signatures are used to control the context in which various symbols are allowed to occur , as explained next .Each variable symbol is associated with exactly one signature from a coherent set of signatures .A constant symbol can have one or more signatures , and different symbols can be associated with the same signature .", "label": "", "metadata": {}, "score": "51.373802"}
{"text": "A CLASSIFICATION specifies that one object is a member ( in case of the # -connective ) or a subclass ( in case of the # # -connective ) of another object ( classes are treated as objects ) .presentation . syntax can again be done via automatic EBNF - to - EBNF mapping .", "label": "", "metadata": {}, "score": "51.49046"}
{"text": "When you instance a specifier , you can explicitly request that the fallback not be consulted .( The C code does this , for example , when merging faces . )See ' specifier - instance ' .Since it is quite common for this function to get called from somewhere in redisplay we need to make sure that quits are ignored .", "label": "", "metadata": {}, "score": "51.52478"}
{"text": "Symbols with an ill - formed lexical part .RIF constant symbols that belong to one of the aforesaid RIF - supported symbol spaces must be well - formed , i.e. , their lexical part must belong to the lexical space associated with the symbol space .", "label": "", "metadata": {}, "score": "51.558052"}
{"text": "More general formulas are constructed out of atomic formulas with the help of logical connectives .A formula is a statement that can have one of the following forms : .Atomic : If \u03c6 is a well - formed atomic formula then it is also a well - formed formula .", "label": "", "metadata": {}, "score": "51.667206"}
{"text": "However , as this embedding is only used for reasoning , I ( JosDeBruijn ) do n't think this is necessary .This datatype might be necessary for the exchange of RDF rule languages ; see the corresponding preliminary section in the architecture document .", "label": "", "metadata": {}, "score": "51.732124"}
{"text": "See ' set - face - property ' for the semantics of the LOCALE , TAG - SET , and HOW - TO - ADD arguments .\" See ' face - property - instance ' for the semantics of the DOMAIN argument . \" Then , check those properties specific to ; ; the particular device type .", "label": "", "metadata": {}, "score": "51.748646"}
{"text": "See ' set - face - property ' for the semantics of the LOCALE , TAG - SET , and HOW - TO - ADD arguments .\" See ' face - property - instance ' for the semantics of the DOMAIN argument . \" Then , check those properties specific to ; ; the particular device type .", "label": "", "metadata": {}, "score": "51.748646"}
{"text": "In that case , they will need to define a concrete language for specifying signatures .Let SigNames be a non - empty , partially - ordered finite or countably infinite set of symbols , disjoint from Const , Var , and ArgNames , called signature names .", "label": "", "metadata": {}, "score": "51.824318"}
{"text": "The order of the arguments in arrow expressions with named arguments is immaterial , so any permutation of arguments yields the same expression .A set S of signatures is coherent iff .Dialects may further specialize this signature .Dialects may further specialize this signature .", "label": "", "metadata": {}, "score": "51.833317"}
{"text": "The symbols need not have any intrinsic meaning of their own ; they need only be systematically interpretable by us as meaning what they mean , and then our own minds and actions can mediate the connection between the symbols and what they can be interpreted as being about .", "label": "", "metadata": {}, "score": "51.893135"}
{"text": "Such polymorphism is common practice in Logic Programming ( e.g. , [ Prolog ] , [ F - logic ] , [ HiLog ] ) and in [ RDF].This extensibility is achieved in RIF by building its syntax on the basis of signatures .", "label": "", "metadata": {}, "score": "52.066242"}
{"text": "This means that DEVICE matches each tag in the tag set .( Every tag recognized by XEmacs has a predicate associated with it that specifies which devices match it . )If PREDICATE is specified , it should be a function of one argument \\(a device ) that specifies whether the tag matches that particular device .", "label": "", "metadata": {}, "score": "52.06849"}
{"text": "Finally , CONDITION assembles everything into what we earlier called RIF condition formulas .Note that individuals , function symbols , and predicate symbols all belong to the same set of symbols Const .This syntax is more general than what RIF - BLD actually permits .", "label": "", "metadata": {}, "score": "52.087803"}
{"text": "This is analogous to the interpretation of regular ( positional ) predicates except for two differences : .The argument to a slotted predicate is a finite bag of slot / value pairs rather than an ordered sequence .Bags ( also known as multisets ) are used here because for slotted predicates the order of slot - value pairs does not matter , but sets can not be used , since I may happen to map different slots into the same value in D .", "label": "", "metadata": {}, "score": "52.114105"}
{"text": "Formal systems do very well in the world of formal , Platonic objects : An axiomatic system can successfully \" second - guess \" all the truths of arithmetic ( I hope no one will cite Goedelian limits on provability as instances of the frame problem ! )", "label": "", "metadata": {}, "score": "52.224373"}
{"text": "Rereading it now after many many years , it 's becoming clear how many things from it I 've internalized ( and frankly , reinvented some of the ideas I forgot had been there ) .Constructing Fillmore .About the same time , and merging the two earlier insights , Fillmore started working on the principles that have come to be known as construction grammar .", "label": "", "metadata": {}, "score": "52.2707"}
{"text": "Last year I presented a paper on the power of the concept of frame where I found even more terms that have a close affinity to it which only underscores the far reaching consequences of Fillmore 's insight .As I was looking for some more quotes from that article , I realized that I 'd have to pretty much cut and paste in the whole of it .", "label": "", "metadata": {}, "score": "52.285828"}
{"text": "We say an environment binds an identifier if that environment itself associates the identifier with a variable , independently of its outer environments .We say an identifier is in scope in an environment if the identifier is bound in that environment or any enclosing environment .", "label": "", "metadata": {}, "score": "52.28691"}
{"text": "In this way , each constant symbol can be either an individual , a predicate of one particular arity , or a function symbol of one particular arity .The set of all constant symbols in RIF has a number of predefined subsets , called symbol spaces , which are used to represent XML data types , data types defined in other W3C specifications , such as rdf : XMLLiteral , and to distinguish other sets of constants .", "label": "", "metadata": {}, "score": "52.301445"}
{"text": "Therefore , we define a finite subset of R RDF , R RDF- , which can be used for reasoning .Note that this subset does not change the semantics ; the embedding is still faithful with respect to the semantics of combinations . is an RDF axiomatic triple of the form rdf:_i rdf : type rdf : Property .", "label": "", "metadata": {}, "score": "52.308014"}
{"text": "A term is either a term in the sense of Section Formal Preliminaries or a slotted term .Slotted terms are defined as follows : .Slotted terms are like regular terms except that the arguments of such a term are named .", "label": "", "metadata": {}, "score": "52.320053"}
{"text": "The current document is the second draft of the RIF - BLD specification ( in the first draft called ' RIF Core ' ) .A number of extensions are planned to support built - ins , additional primitive XML data types , the notion of RIF compliance , and so on .", "label": "", "metadata": {}, "score": "52.33211"}
{"text": "The lexical space of rdf : XMLLiteral is defined in the document [ RDF - CONCEPTS ] .rif : text ( for text strings with language tags attached ) .This symbol space represents text strings with a language tag attached .", "label": "", "metadata": {}, "score": "52.43628"}
{"text": "The functions described below may only be called with a this value referring to a Debugger .Object instance ; they may not be used as methods of other kinds of objects .The descriptions use \" referent \" to mean \" the referent of this Debugger .", "label": "", "metadata": {}, "score": "52.510635"}
{"text": "This can be a singleton set or even an empty set .In contrast , a uniterm slot semantically behaves like a unary uninterpreted function symbol .In both cases , however , the order of the slots is immaterial ( in contrast to positional uniterms ) .", "label": "", "metadata": {}, "score": "52.55764"}
{"text": "In form ( a ) , all variables are quantified universally outside of the rule .In form ( b ) , the variables that do not appear in the rule then part are instead quantified existentially in the if part .", "label": "", "metadata": {}, "score": "52.599472"}
{"text": "See ' set - face - property ' for the semantics of the LOCALE , TAG - SET , and HOW - TO - ADD arguments . \"( interactive ( face - interactive \" display - table \" ) ) ( set - face - property face ' display - table display - table locale tag - set how - to - add ) ) ; ; The following accessors and mutators are , IMHO , good ; ; implementation .", "label": "", "metadata": {}, "score": "52.768642"}
{"text": "See ' set - face - property ' for the semantics of the LOCALE , TAG - SET , and HOW - TO - ADD arguments . \"( interactive ( face - interactive \" display - table \" ) ) ( set - face - property face ' display - table display - table locale tag - set how - to - add ) ) ; ; The following accessors and mutators are , IMHO , good ; ; implementation .", "label": "", "metadata": {}, "score": "52.768642"}
{"text": "The correspondence between the RIF structures and the RDF interpretation is defined through a number of conditions which ensure the correspondence in the interpretation of names ( i.e. URIs and literals ) and formulas , i.e. the correspondence between RDF triples of the form s p o . and RIF . frames .", "label": "", "metadata": {}, "score": "52.879913"}
{"text": "To retrieve settings , use ' specifier - specs ' , or its lower - level counterpart ' specifier - spec - list ' .To determine the actual value , use ' specifier - instance ' .A specifier is an object that can be used to keep track of a property whose value can be per - buffer , per - window , per - frame , or per - device , and can further be restricted to a particular console - type or device - class .", "label": "", "metadata": {}, "score": "52.923058"}
{"text": "The assignment can be explicit or implicit ( for instance , derived from the context in which each symbol is used ) .constant .variable . positional .with named arguments .equality . frame .class membership . subclass .", "label": "", "metadata": {}, "score": "52.93759"}
{"text": "The first article , more of a slim monograph at 80 odd pages , was Case for Case ( which , for some reason , I first read in Russian translation ) .Published in 1968 it was one of the first efforts to find deeper functional connections in generative grammar ( following on his earlier work with transformations ) .", "label": "", "metadata": {}, "score": "53.015755"}
{"text": "If FONT is a specifier object , LOCALE can be a locale , a locale type , ' all , or nil ; see ' copy - specifier ' for its semantics .Otherwise LOCALE specifies the locale under which the specified instantiator(s ) will be added , and defaults to ' global .", "label": "", "metadata": {}, "score": "53.0287"}
{"text": "If FONT is a specifier object , LOCALE can be a locale , a locale type , ' all , or nil ; see ' copy - specifier ' for its semantics .Otherwise LOCALE specifies the locale under which the specified instantiator(s ) will be added , and defaults to ' global .", "label": "", "metadata": {}, "score": "53.0287"}
{"text": "Otherwise ( s , u ) is an ill - typed literal .We define the RIF equivalent of the RDF names , given an RDF vocabulary V .All in all , it appears that the value space of the string datatype in XML Schema 1.1 is a superset of the value space of the RDF plain literals without language tags , but there are RDF plain literals which are not strings in XML Schema 1.0 .", "label": "", "metadata": {}, "score": "53.05992"}
{"text": "We represent the abstract syntax of the RIF Condition Language with the help of usual EBNF , employed here to define BLD in a fully striped normal form .The above abstract syntax can be illustrated with a UML diagram , as shown below .", "label": "", "metadata": {}, "score": "53.06201"}
{"text": "Remove it from the list .for_disksave & & !internal_equal can trigger a quit .That leads to Bad Things .We pick what are perhaps the most likely places where interesting stuff will be . symbol ) ) return Dynarr_at ( the_specifier_type_entry_dynarr , i ) .", "label": "", "metadata": {}, "score": "53.10347"}
{"text": "So we will either not notice them or cease to regard them as evidence that there is something wrong with this kind of model in the first place .I am more pessimistic .I think the reason the frame problem keeps rearing its head is because there is something intrinsically wrong with an ungrounded symbolic approach to modeling the mind ( if not to building useful tools for systems with minds ) .", "label": "", "metadata": {}, "score": "53.147762"}
{"text": "# -- a signature name reserved for membership terms .# # -- a signature reserved for subclass terms .Dialects are expected to introduce additional signature names .For instance , RIF - BLD introduces one other signature name , term .", "label": "", "metadata": {}, "score": "53.14794"}
{"text": "All the components except the last five , I slot , I SF , I SR , I sub , I isa , are the same as before .The new mapping I slot is used to interpret frames ; the mappings I SF and I SR interpret terms and predicates with named arguments , respectively ; I sub gives meaning to the subclass hierarchy ; and I isa interprets class membership .", "label": "", "metadata": {}, "score": "53.167297"}
{"text": "Return an array of Debugger .Script instances for all debuggee scripts matching query .Each instance appears only once in the array .Query is an object whose properties restrict which scripts are returned ; a script must meet all the criteria given by query to be returned .", "label": "", "metadata": {}, "score": "53.187023"}
{"text": "Currently the only useful value for MATCHSPEC is a charset , when used in conjunction with the face 's font ; this allows you to retrieve a font that can be used to display a particular charset , rather than just any font .", "label": "", "metadata": {}, "score": "53.217983"}
{"text": "Currently the only useful value for MATCHSPEC is a charset , when used in conjunction with the face 's font ; this allows you to retrieve a font that can be used to display a particular charset , rather than just any font .", "label": "", "metadata": {}, "score": "53.217983"}
{"text": "Note , however , that such restrictions are not necessary if the combined semantics uses the RDF - compatible semantics of OWL DL , because this semantics is defined for all RDF graphs .In that case , no guarantees whatsoever can be given about reasoning .", "label": "", "metadata": {}, "score": "53.35542"}
{"text": "The defining occurence of a variable occurs only in a FinalPattern or a VarPattern : .FinalPattern : .In both cases , when this pattern is matched against a specimen , the match always succeeds and the specimen becomes the initial value of the variable .", "label": "", "metadata": {}, "score": "53.410797"}
{"text": "Object instance belonging to this Debugger instance , then its referent is used .If the object is not a global object , then the global in whose scope it was allocated is used .Note that the result may include values for scripts that can no longer ever be used by the debuggee , say , those for eval code that has finished running , or unreachable functions .", "label": "", "metadata": {}, "score": "53.513847"}
{"text": "The return value will be a list of instantiators ( e.g. strings specifying a font or color name ) , or a list of specifications , each of which is a cons of a locale and a list of instantiators .Specifically , if LOCALE is a particular locale ( a buffer , window , frame , device , or ' global ) , a list of instantiators for that locale will be returned .", "label": "", "metadata": {}, "score": "53.616875"}
{"text": "The return value will be a list of instantiators ( e.g. strings specifying a font or color name ) , or a list of specifications , each of which is a cons of a locale and a list of instantiators .Specifically , if LOCALE is a particular locale ( a buffer , window , frame , device , or ' global ) , a list of instantiators for that locale will be returned .", "label": "", "metadata": {}, "score": "53.616875"}
{"text": "Each Debugger instance maintains a set of global objects that , taken together , comprise the debuggee .Code evaluated in the scope of a debuggee global object , directly or indirectly , is considered debuggee code .Similarly : .When a debuggee stack frame completes its execution , or when some sort of debuggee call initiated by the debugger finishes , the Debugger interface provides a value describing how the code completed ; these are called completion values .", "label": "", "metadata": {}, "score": "53.65358"}
{"text": "If MAPFUN ever returns non - zero , the mapping is halted and the value returned is returned from map_specifier ( ) .Otherwise , the mapping proceeds to the end and map_specifier ( ) returns 0 .The specification maps from LOCALE ( which should be a window , buffer , frame , device , or ' global , and defaults to ' global ) to INSTANTIATOR , whose allowed values depend on the type of the specifier .", "label": "", "metadata": {}, "score": "53.660194"}
{"text": "Y in the first RIF condition of Example 1 is quantified , existentially , but ?X is free .However , when this condition occurs in the if part of the second rule in Example 1 , then this variable is quantified universally outside of the rule .", "label": "", "metadata": {}, "score": "53.67442"}
{"text": "Y in the first RIF condition of Example 1 is quantified , existentially , but ?X is free .However , when this condition occurs in the if part of the second rule in Example 1 , then this variable is quantified universally outside of the rule .", "label": "", "metadata": {}, "score": "53.67442"}
{"text": "In this way , both semantics ( the RIF and the RDF semantics ) apply to all symbols in the combination .The semantics of RIF - RDF combinations is defined in terms of common models .We only treat the case of D - interpretation .", "label": "", "metadata": {}, "score": "53.782845"}
{"text": "Script instance ) , or null on frames that do not represent calls to debuggee code .On frames whose callee property is not null , this is equal to callee.script .The lexical environment within which evaluation is taking place ( a Debugger .", "label": "", "metadata": {}, "score": "53.787674"}
{"text": "Next we define well - formed terms and their signatures .Like the constant symbols , well - formed terms can have more than one signature .A constant or variable symbol with signature \u03b7 is a well - formed term with signature \u03b7 .", "label": "", "metadata": {}, "score": "53.796062"}
{"text": "Quantification : I Truth ( Exists ?v 1 ... ?v 1 , ... , ?v n .In this section we extend Positive Conditions , defined in Section Positive Conditions , with slotted Uniterm s and Frame formulas .", "label": "", "metadata": {}, "score": "53.797348"}
{"text": "Lexical space refers to the syntax of the constant symbols that belong to a particular primitive data type .For instance , \" 1.2\"^^xsd : decimal and \" 1.20\"^^xsd : decimal are two legal constants in RIF because 1.2 and 1.20 belong to the lexical space of xsd : decimal .", "label": "", "metadata": {}, "score": "53.80686"}
{"text": "The semantics of combinations is defined in terms of combined models .Intuitively , given an RIF semantic structure , we define the corresponding RDF interpretation .If the RDF interpretation satisfies the RDF graphs , as well as the RIF rule set , then it is a model of the combination .", "label": "", "metadata": {}, "score": "53.80844"}
{"text": "Any value assigned to a debugging handler must be either a function or undefined ; otherwise a TypeError is thrown .New code , represented by the Debugger .Script instance script , has been loaded in the scope of the debuggee global object global .", "label": "", "metadata": {}, "score": "53.813362"}
{"text": "Facts are generated by the ATOMIC production , and can be viewed as the then part of an Implies with an empty conjunctive if ( or with true as the if part ) .The .CLAUSE .RULE .production generates a universally closed rule or fact .", "label": "", "metadata": {}, "score": "53.83824"}
{"text": "In addition , RIF - BLD imposes the following restrictions : .The terms that are allowed as slot names in slotted terms .they must be constant symbols .This means that RIF - BLD does not allow variables or complex terms ( like f ( ) , f(a , b ) ) as slot names in slotted uniterms ( but there are no such restrictions on slots in frames ) .", "label": "", "metadata": {}, "score": "53.858444"}
{"text": "This specifier stuff needs some rethinking .( really ! )( or ( null domain ) ( not ( equal inst ( face - property - instance face ' font domain ) ) ) ; ; do n't do it for standard faces , or you 'll get inheritance loops .", "label": "", "metadata": {}, "score": "53.884815"}
{"text": "This specifier stuff needs some rethinking .( really ! )( or ( null domain ) ( not ( equal inst ( face - property - instance face ' font domain ) ) ) ; ; do n't do it for standard faces , or you 'll get inheritance loops .", "label": "", "metadata": {}, "score": "53.884815"}
{"text": "RIF - BLD presentation syntax does not commit to any particular vocabulary for the names of variables or for the literals used in constant symbols .In the examples , variables are denoted by Unicode character sequences beginning with a ? -sign .", "label": "", "metadata": {}, "score": "53.95169"}
{"text": "These will also be ; ; frobbed further in init - other - random - faces .; ; These warnings are there for a reason .Just specify your fonts ; ; correctly .Deal with it .Additionally , one can use ; ; ' log - warning - minimum - level ' instead of this . ; ( defvar inhibit - font - complaints nil ; \" Whether to suppress complaints about incomplete sets of fonts . \")", "label": "", "metadata": {}, "score": "53.967964"}
{"text": "These will also be ; ; frobbed further in init - other - random - faces .; ; These warnings are there for a reason .Just specify your fonts ; ; correctly .Deal with it .Additionally , one can use ; ; ' log - warning - minimum - level ' instead of this . ; ( defvar inhibit - font - complaints nil ; \" Whether to suppress complaints about incomplete sets of fonts . \")", "label": "", "metadata": {}, "score": "53.967964"}
{"text": "To this end , we introduce the following restriction on the mappings I isa and I sub : . is used by employing a distinguished binary function symbol , List , and a distinguished constant symbol , Nil .Besides dealing with these two distinguished symbols , nothing else changes ( especially , in the semantics ) .", "label": "", "metadata": {}, "score": "54.02363"}
{"text": "This section describes the status of this document at the time of its publication .Other documents may supersede this document .No Endorsement .Publication as a Working Draft does not imply endorsement by the W3C Membership .This is a draft document and may be updated , replaced or obsoleted by other documents at any time .", "label": "", "metadata": {}, "score": "54.027393"}
{"text": "Instead , white space is informally used as a delimiter .This is done on purpose , since RIF 's presentation syntax is intended to be used for specifying semantics and to illustrate the main RIF concepts through examples .It is not intended as a concrete syntax for a rule language .", "label": "", "metadata": {}, "score": "54.1176"}
{"text": "Object instance presents its referent as it would be seen from a particular compartment .This \" viewing compartment \" is chosen to match the way the debugger came across the referent .As a consequence , a single Debugger instance may actually have several Debugger .", "label": "", "metadata": {}, "score": "54.193565"}
{"text": "For example , for a font specifier ( as returned by the ' face - font ' function ) , the returned value will be a font - instance object .For glyphs , the returned value will be a string , pixmap , or subwindow .", "label": "", "metadata": {}, "score": "54.25844"}
{"text": "The same symbol can occur in multiple contexts at the same time .For instance , if p , a , and b are symbols then p ( p ( a ) p ( a p c ) ) is a term .", "label": "", "metadata": {}, "score": "54.265163"}
{"text": "Name must be a string whose value is a valid ECMAScript identifier name .Code is a string .All extant handler methods , breakpoints , watchpoints , and so on remain active during the call .If code is not strict mode code , then variable declarations in code affect this environment .", "label": "", "metadata": {}, "score": "54.330803"}
{"text": "A use occurence of a variable on the left side of an assignment expression .The assignment expression as a whole has the value the expression on the right evaluates to , but we do n't bother to show this in the implementation sketch below .", "label": "", "metadata": {}, "score": "54.445065"}
{"text": "If a given method is absent from handler , then events of that sort are ignored .The watchpoint consults handler 's properties each time an event occurs , so adding methods to or removing methods from handler after setting the watchpoint enables or disables reporting of the corresponding events .", "label": "", "metadata": {}, "score": "54.48579"}
{"text": "Tools should instead use the [ [ Remote Debugging Protocol ] ] for all inter - thread communication .Properties are configurable .This applies to both \" own \" and prototype properties , and to both methods and data properties .", "label": "", "metadata": {}, "score": "54.50712"}
{"text": "Object instance belonging to this Debugger instance , then its referent is used .If the object is not a global object , then the global in whose scope it was allocated is used .Note that the result may include Debugger .", "label": "", "metadata": {}, "score": "54.529068"}
{"text": "If this frame 's environment property is null , throw a TypeError .All extant handler methods , breakpoints , watchpoints , and so on remain active during the call .If code is not strict mode code , then variable declarations in code affect the environment of this frame .", "label": "", "metadata": {}, "score": "54.54772"}
{"text": "A symbol space in RIF has the following components : .A non - empty set of character strings called the lexical space of the symbol space .The lexical space for a type , D , determines which character strings are allowed as value in a symbol like \" value \" D .", "label": "", "metadata": {}, "score": "54.583317"}
{"text": "The choice of symbol spaces supported by the dialect .Symbol spaces determine the \" shapes \" of the symbols that are allowed by the syntax of the dialect .The choice of the formulas supported by the dialect .RIF - FLD allows to build formulas of the following kind : .", "label": "", "metadata": {}, "score": "54.58557"}
{"text": "In : Working Papers of the AAAI Spring Symposium on Machine Learning of Natural Language and Ontology ( DW Powers & L Reeker , Eds . ) pp .65 - 74 .Presented at Symposium on Symbol Grounding : Problems and Practice , Stanford University , March 1991 .", "label": "", "metadata": {}, "score": "54.682"}
{"text": "Optional argument HOW - TO - ADD specifies what to do with existing specifications in DEST .If nil , then whichever locales or locale types are copied will first be completely erased in DEST .Otherwise , it is the same as in ' add - spec - to - specifier ' .", "label": "", "metadata": {}, "score": "54.74254"}
{"text": "Forall , which is specified through its parts , i.e. one or more variable ( Var ) declarations and , recursively , a RULE as the formula in their scope .Var , ATOMIC , and CONDITION were defined as part of the syntax for positive conditions in Positive Conditions .", "label": "", "metadata": {}, "score": "54.752644"}
{"text": "( This function behaves like the standard Object.isSealed function , except that the object inspected is implicit and in a different compartment from the caller . )Return true if the referent is frozen \u2014 that is , if it is not extensible , and all its properties have been marked as non - configurable and read - only .", "label": "", "metadata": {}, "score": "54.7607"}
{"text": "( face - property - instance face ' reverse domain default no - fallback ) ) ( defun set - face - reverse - p ( face reverse - p & optional locale tag - set how - to - add ) \" Change whether FACE is reversed in LOCALE ( TTY locales only ) .", "label": "", "metadata": {}, "score": "54.771046"}
{"text": "( face - property - instance face ' reverse domain default no - fallback ) ) ( defun set - face - reverse - p ( face reverse - p & optional locale tag - set how - to - add ) \" Change whether FACE is reversed in LOCALE ( TTY locales only ) .", "label": "", "metadata": {}, "score": "54.771046"}
{"text": "It should be a function of\\n \" \" two arguments : an instantiator and a flag CAN - SIGNAL - ERROR .If this\\n \" \" flag is false , the function must simply return t or nil indicating\\n \" \" whether the instantiator is valid .", "label": "", "metadata": {}, "score": "54.776413"}
{"text": "First , some symbol spaces , called primitive data types , have a value space , denoted VS symsp , and a mapping from the lexical space to the VS symsp , denoted L symsp , where symsp is an identifier for the symbol space .", "label": "", "metadata": {}, "score": "54.822315"}
{"text": "( One major problem is that validating an instantiator is supposed to require only that the specifier type is passed , while with this approach the actual specifier is needed . )What really needs to be done is to write a function ' make - specifier - type ' that creates new specifier types .", "label": "", "metadata": {}, "score": "54.870464"}
{"text": "\\(The default value of nil is a subset of all tag sets , so in this case no instantiators will be screened out . )If EXACT - P is non - nil , however , TAG - SET must be equal to an instantiator 's tag set for the instantiator to be returned .", "label": "", "metadata": {}, "score": "54.872414"}
{"text": "A number of extensions are planned to support built - ins , additional primitive XML data types , the notion of RIF compliance , and so on .Tool support for RIF BLD is forthcoming .RIF dialects that extend BLD will be specified in other documents by this working group .", "label": "", "metadata": {}, "score": "54.87543"}
{"text": "( Chartable specifiers are not yet implemented . ) -- For font specifiers , MATCHSPEC should be a charset , and the specification ( a font string ) must have a registry that matches the charset 's registry .( This only makes sense with Mule support . )", "label": "", "metadata": {}, "score": "54.87771"}
{"text": "The value of such an attribute is supposed to be the signature name for the corresponding symbol .The sig attribute is optional , and its value can be inferred for the basic language .For instance , in our example , the values p4 and i for the attribute sig could be inferred from the usage of the symbols purchase and Author .", "label": "", "metadata": {}, "score": "54.999847"}
{"text": "FACE may be either a face object or a symbol representing a face .See ' face - property ' for more information . \"( face - property face ' font locale tag - set exact - p ) ) ( defun face - font - instance ( face & optional domain charset ) \" Return the instance of FACE 's font in DOMAIN .", "label": "", "metadata": {}, "score": "55.02024"}
{"text": "FACE may be either a face object or a symbol representing a face .See ' face - property ' for more information . \"( face - property face ' font locale tag - set exact - p ) ) ( defun face - font - instance ( face & optional domain charset ) \" Return the instance of FACE 's font in DOMAIN .", "label": "", "metadata": {}, "score": "55.02024"}
{"text": "Section Formal Preliminaries defined the allowed signatures for the basic logic dialect of RIF .With the introduction of slotted signatures , we augment the set of allowed signatures in the basic dialect as follows : .In addition , RIF 's Basic Logic Dialect imposes the following restrictions : . subclass Var property name : VARNAME subclass Uniterm .", "label": "", "metadata": {}, "score": "55.04068"}
{"text": "The value space may be constrained in various ways or it can be completely fixed .For instance , the XML Schema Part 2 : Datatypes specification defines a concrete value space for each XML data type , including the data types such as xsd : decimal , which are of interest to RIF .", "label": "", "metadata": {}, "score": "55.056374"}
{"text": "Also , FSFmacs name .( defvaralias ' initialize - face - resources ' init - face - from - resources ) ( defun face - spec - set ( face spec & optional frame ) \" Set FACE 's face attributes according to the first matching entry in SPEC .", "label": "", "metadata": {}, "score": "55.065643"}
{"text": "Also , FSFmacs name .( defvaralias ' initialize - face - resources ' init - face - from - resources ) ( defun face - spec - set ( face spec & optional frame ) \" Set FACE 's face attributes according to the first matching entry in SPEC .", "label": "", "metadata": {}, "score": "55.065643"}
{"text": "( This function behaves like the standard Object.seal function , except that the object to be sealed is implicit and in a different compartment from the caller . )Prevent properties from being added to or deleted from the referent , and mark each property as non - writable .", "label": "", "metadata": {}, "score": "55.088722"}
{"text": "Object instance is replaced .If handler is null , the referent is no longer watched .Handler may have the following methods , called under the given circumstances : .A property named name has been added to the referent .", "label": "", "metadata": {}, "score": "55.09482"}
{"text": "RIF - RDF combinations can be embedded into RIF Rule sets in a fairly straightforward way , thereby demonstrating how an RIF - compliant translator without native support for RDF can process RIF - RDF combinations .For the embedding we use the concrete syntax of RIF and the N - Triples syntax for RDF .", "label": "", "metadata": {}, "score": "55.106907"}
{"text": "It 's the union of the non - outer - variables used freely by any of the lexical - facets of a lexical - composite .From directly within an object ( ie , not within a nested object ) the frame holding the state of this object is the object - frame .", "label": "", "metadata": {}, "score": "55.173233"}
{"text": "Return the debuggee value that represents value in the debuggee .If value is a primitive , we return it unchanged ; if value is an object , we return the Debugger .Object instance representing that object , wrapped appropriately for use in this Debugger .", "label": "", "metadata": {}, "score": "55.17627"}
{"text": "See ' face - property - instance ' for the semantics of the DOMAIN argument . \"( face - property - instance face ' display - table domain default no - fallback ) ) ( defun set - face - display - table ( face display - table & optional locale tag - set how - to - add ) \" Change the display table of FACE to DISPLAY - TABLE in LOCALE .", "label": "", "metadata": {}, "score": "55.19614"}
{"text": "See ' face - property - instance ' for the semantics of the DOMAIN argument . \"( face - property - instance face ' display - table domain default no - fallback ) ) ( defun set - face - display - table ( face display - table & optional locale tag - set how - to - add ) \" Change the display table of FACE to DISPLAY - TABLE in LOCALE .", "label": "", "metadata": {}, "score": "55.19614"}
{"text": "Terms with named arguments .The term t here represents a predicate or a function ; s 1 , ... , s n represent argument names ; and v 1 , ... , v n represent argument values .Terms with named arguments are like regular positional terms except that the arguments are named and their order is immaterial .", "label": "", "metadata": {}, "score": "55.45214"}
{"text": "If any onStep handler forces the frame to return early ( by returning a resumption value other than undefined ) , any remaining debuggers ' onStep handlers do not run .This property must be either undefined or a function .On newly created frames , this property 's value is undefined .", "label": "", "metadata": {}, "score": "55.456287"}
{"text": "( \" Same tag set \" means that they contain the same elements .The order may be different . ) ' remove - tag - set - append Remove any existing instantiators whose tag set is the same as TAG - SET ; then put the new instantiator at the end of the current list . '", "label": "", "metadata": {}, "score": "55.570896"}
{"text": "The mapping function tr is extended to embed triples as RIF statements and graphs as sets of RIF statements .Finally , two embedding functions , tr .S . and tr Q embed RDF graphs as RIF rule sets and conditions , respectively .", "label": "", "metadata": {}, "score": "55.587307"}
{"text": "Frob INST_LIST according to ADD_METH .No need to call an after - change function ; the calling function will do this .Return either SPEC_PREPEND or SPEC_APPEND , indicating whether to prepend or append the NEW_LIST .ADD_METH specifies what to do with existing specifications in the specifier , and is an enum that corresponds to the values in ' add - spec - to - specifier ' .", "label": "", "metadata": {}, "score": "55.636765"}
{"text": "See ' face - property - instance ' for the semantics of the DOMAIN argument . \"( font - width ( face - font face ) domain charset ) ) ( defun face - height ( face & optional domain charset ) \" Return the height of FACE in DOMAIN .", "label": "", "metadata": {}, "score": "55.708473"}
{"text": "See ' face - property - instance ' for the semantics of the DOMAIN argument . \"( font - width ( face - font face ) domain charset ) ) ( defun face - height ( face & optional domain charset ) \" Return the height of FACE in DOMAIN .", "label": "", "metadata": {}, "score": "55.708473"}
{"text": "For RIF - BLD , TV includes only two values , t ( true ) and f ( false ) .( See end note on truth values . )( See end note on ordering truth values . )Semantic structures .", "label": "", "metadata": {}, "score": "55.71186"}
{"text": "Variable access .This is simply the use occurence of a variable name as an expression ( for language history weenies , an \" rValue \" ) .For example , \" a \" in \" a + b \" is an access to the variable named \" a \" .", "label": "", "metadata": {}, "score": "55.729523"}
{"text": "This property is only used on window system devices .FACE may be either a face object or a symbol representing a face .PIXMAP should be an instantiator ( see ' image - specifier - p ' ) , a list of instantiators , an alist of specifications ( each mapping a locale to an instantiator list ) , or an image specifier object .", "label": "", "metadata": {}, "score": "55.735413"}
{"text": "This property is only used on window system devices .FACE may be either a face object or a symbol representing a face .PIXMAP should be an instantiator ( see ' image - specifier - p ' ) , a list of instantiators , an alist of specifications ( each mapping a locale to an instantiator list ) , or an image specifier object .", "label": "", "metadata": {}, "score": "55.735413"}
{"text": "Return value immediately as the current value of the function .Value must be a debuggee value .( Most handler functions support this , except those whose descriptions say otherwise . )Yield value immediately as the next value of the current frame , which must be a generator frame .", "label": "", "metadata": {}, "score": "55.771843"}
{"text": "Semantics of undefined symbol spaces .Section Symbol Spaces addressed the syntactic aspects of the treatment of \" unknown \" symbol spaces , i.e. , symbol spaces that are not defined by the RIF specification .It defined the lexical space of those symbols as the set of all Unicode strings .", "label": "", "metadata": {}, "score": "55.807255"}
{"text": "The semantic aspects of symbol spaces will be described in Section Semantic Framework .Each symbol in Const belongs to exactly one symbol space .Each symbol space has an associated lexical space and an identifier .The lexical space of a symbol space is a non - empty set of Unicode character strings .", "label": "", "metadata": {}, "score": "55.850624"}
{"text": "Specifiers are created in the syms_of ( ) functions .This is the same deal as for weak hash tables .", "label": "", "metadata": {}, "score": "55.898827"}
{"text": "The order of arguments in a slotted signature is assumed to be immaterial , so any permutation of arguments is assumed to yield the same signature expression .By analogy with earlier definitions , if \u03ba .n . is bool then the expression is also a slotted Boolean signature expression .", "label": "", "metadata": {}, "score": "55.936928"}
{"text": "For instance , \" abc\"^^cde is such an uninterpreted symbol .Dialects that extend the basic RIF logic dialect might appropriate some of the symbol spaces , which are undefined in the basic RIF dialect , and give them special semantics .", "label": "", "metadata": {}, "score": "55.944748"}
{"text": "FACE may be either a face object or a symbol representing a face .FONT should be an instantiator ( see ' font - specifier - p ' ) , a list of instantiators , an alist of specifications ( each mapping a locale to an instantiator list ) , or a font specifier object .", "label": "", "metadata": {}, "score": "55.972946"}
{"text": "FACE may be either a face object or a symbol representing a face .FONT should be an instantiator ( see ' font - specifier - p ' ) , a list of instantiators , an alist of specifications ( each mapping a locale to an instantiator list ) , or a font specifier object .", "label": "", "metadata": {}, "score": "55.972946"}
{"text": "If LOCALE is a particular locale , what happens depends on what sort of locale is given .If you gave a device , frame , or window , then it 's always possible to determine what the font actually will be , so this is determined and the resulting font is frobbed and added back as a specification for this locale .", "label": "", "metadata": {}, "score": "56.03026"}
{"text": "If LOCALE is a particular locale , what happens depends on what sort of locale is given .If you gave a device , frame , or window , then it 's always possible to determine what the font actually will be , so this is determined and the resulting font is frobbed and added back as a specification for this locale .", "label": "", "metadata": {}, "score": "56.03026"}
{"text": "Note also that , since CONDITION permits disjunction and existential quantification , the rules defined by the Implies production are more general than pure Horn rules .This extension was explained in the introduction to Section Positive Conditions .Well - formed rules .", "label": "", "metadata": {}, "score": "56.1009"}
{"text": "Note also that , since CONDITION permits disjunction and existential quantification , the rules defined by the Implies production are more general than pure Horn rules .This extension was explained in the introduction to Section Positive Conditions .Well - formed rules .", "label": "", "metadata": {}, "score": "56.1009"}
{"text": "When one of the events described below occurs in debuggee code , the engine pauses the debuggee and calls the corresponding debugging handler on each Debugger instance that is observing the debuggee .The handler functions receive the Debugger instance as their this value .", "label": "", "metadata": {}, "score": "56.175423"}
{"text": "From today 's perspective , its emphasis on the deep and surface structures , as well as its relatively impoverished semantics may seem a bit dated , but it represents an engagement with language used to express real meaning .Fillmore in the frame .", "label": "", "metadata": {}, "score": "56.26294"}
{"text": "Condition 4 ensures that all literal values in D are included in LV .Condition 5 ensures that RDF triples are interpreted in the same way as properties frames .Condition 6 ensures that IRIs are interpreted in the same way .", "label": "", "metadata": {}, "score": "56.2658"}
{"text": "Unfortunately calling equal is no good either as this does n't take into account things attached to the specifier - for instance strings on extents .If not , set a default so this never happens or correct it in the value_changed_in_frame method .", "label": "", "metadata": {}, "score": "56.282593"}
{"text": "We call those stack frames a Debugger does reveal visible frames .If the non - debuggee function eventually calls back into debuggee code , then those frames are visible .( Note that the debuggee is not considered an \" immediate caller \" of handler methods it triggers .", "label": "", "metadata": {}, "score": "56.31649"}
{"text": "When the referent frame is popped , the argument value 's properties ' getters throw an error .Calls to frames ' handler methods are cross - compartment , intra - thread calls : the call takes place in the thread to which the frame belongs , and runs in the compartment to which the handler method belongs .", "label": "", "metadata": {}, "score": "56.3288"}
{"text": "Otherwise , the face will be resourced over all possible locales ( i.e. all frames , all devices , and ' global ) . \"( cond ( ( null init - face - from - resources ) ; ; Do nothing . )", "label": "", "metadata": {}, "score": "56.34524"}
{"text": "Otherwise , the face will be resourced over all possible locales ( i.e. all frames , all devices , and ' global ) . \"( cond ( ( null init - face - from - resources ) ; ; Do nothing . )", "label": "", "metadata": {}, "score": "56.34524"}
{"text": "The format of a spec - list is ( ( LOCALE ( TAG - SET .INSTANTIATOR ) is called an ' inst - pair ' .A list of inst - pairs is called an ' inst - list ' .", "label": "", "metadata": {}, "score": "56.35292"}
{"text": "Truth valuation for well - formed formulas in RIF 's basic condition language is determined using the following function , denoted I Truth : .Quantification : I Truth ( Exists ?v 1 ... ?v 1 , ... , ?", "label": "", "metadata": {}, "score": "56.384117"}
{"text": "Other symbol spaces may have their value spaces constrained in some ways , but not fixed .For instance , the value space of rif : iri is defined below as the entire domain of interpretation .This means that this value space can not be an arbitrary subset of that domain .", "label": "", "metadata": {}, "score": "56.4008"}
{"text": "We use a bubble sort here ( copied from extent_fragment_update ( ) ) -- reduces the function call overhead , and is the fastest sort for small numbers of items .Two canonicalized tag sets can be compared with ' equal ' to see if they represent the same tag set .", "label": "", "metadata": {}, "score": "56.45801"}
{"text": "A non - live Debugger .Frame instance no longer holds a strong reference to the generator - iterator object .A Debugger .Script instance refers to a sequence of bytecode in the debuggee ; it is the JavaScript - level presentation of a JSAPI JSScript object .", "label": "", "metadata": {}, "score": "56.532753"}
{"text": "( font - ascent ( face - font face ) domain charset ) ) ( defun face - descent ( face & optional domain charset ) \" Return the descent of FACE in DOMAIN .See ' face - property - instance ' for the semantics of the DOMAIN argument . \"", "label": "", "metadata": {}, "score": "56.55458"}
{"text": "( font - ascent ( face - font face ) domain charset ) ) ( defun face - descent ( face & optional domain charset ) \" Return the descent of FACE in DOMAIN .See ' face - property - instance ' for the semantics of the DOMAIN argument . \"", "label": "", "metadata": {}, "score": "56.55458"}
{"text": "( face - property - instance face ' blinking domain default no - fallback ) ) ( defun set - face - blinking - p ( face blinking - p & optional locale tag - set how - to - add ) \" Change whether FACE is blinking in LOCALE ( TTY locales only ) .", "label": "", "metadata": {}, "score": "56.5765"}
{"text": "( face - property - instance face ' blinking domain default no - fallback ) ) ( defun set - face - blinking - p ( face blinking - p & optional locale tag - set how - to - add ) \" Change whether FACE is blinking in LOCALE ( TTY locales only ) .", "label": "", "metadata": {}, "score": "56.5765"}
{"text": "If instead , LOCALE is a locale type ( i.e. ' window , ' buffer , ' frame , or ' device ) , the specifications for all locales of that type will be removed .If LOCALE is nil or ' all , all specifications will be removed .", "label": "", "metadata": {}, "score": "56.608543"}
{"text": "NILP ( assq_no_quit ( tag , Vuser_defined_tags ) ) ) ?A specifier tag set is an entity that is attached to an instantiator and can be used to restrict the scope of that instantiator to a particular device class or device type and/or to mark instantiators added by a particular package so that they can be later removed .", "label": "", "metadata": {}, "score": "56.609184"}
{"text": "PSYCOLOQUY ( ISSN 1055 - 0143 ) is sponsored by the American Psychological Association ( APA ) .Psycoloquy 4(34 ) : Problems , Problems : .PROBLEMS , PROBLEMS : THE FRAME PROBLEM AS A SYMPTOM OF THE SYMBOL GROUNDING PROBLEM Commentary on Van Brakel and Fetzer on Ford & Hayes on the Frame Problem .", "label": "", "metadata": {}, "score": "56.669582"}
{"text": "We distinguish between syntactic correspondence for the cases of combination with OWL Full and OWL DL , respectively .For the case of compatibility with OWL Full , syntactic correspondence should be defined in the same way as in RDF Compatibility , because the syntax is the same as that of RDF : a triple s p o .", "label": "", "metadata": {}, "score": "56.672676"}
{"text": "Arguments must either be an array ( in the debugger ) of debuggee values , or null or undefined , which are treated as an empty array .All extant handler methods , breakpoints , watchpoints , and so on remain active during the call .", "label": "", "metadata": {}, "score": "56.675453"}
{"text": "If \u03ba above is bool then the signature is called a Boolean signature expression .A set S of signatures is said to be coherent if .no two different signatures in S have the same name .Well - formed terms and formulas .", "label": "", "metadata": {}, "score": "56.769665"}
{"text": "NILP ( no_fallback ) , Qzero ) ; return UNBOUNDP ( instance ) ?If no instance can be generated for this domain , return DEFAULT .This function is identical to ' specifier - instance ' except that a specification will only be considered if it matches MATCHSPEC .", "label": "", "metadata": {}, "score": "56.770645"}
{"text": "Optional argument HOW - TO - ADD specifies what to do if there are already specifications in the specifier .It should be one of ' prependPut at the beginning of the current list of instantiators for LOCALE . 'appendAdd to the end of the current list of instantiators for LOCALE . '", "label": "", "metadata": {}, "score": "56.79099"}
{"text": "Object.prototype.getOwnPropertyDescriptor .Name must be a string whose value is a valid ECMAScript identifier name .If this is an \" object \" or \" with \" environment record , this simply returns the descriptor for the given property of the environment 's object .", "label": "", "metadata": {}, "score": "56.87497"}
{"text": "If COLOR is a specifier object , LOCALE can be a locale , a locale type , ' all , or nil ; see ' copy - specifier ' for its semantics .Otherwise LOCALE specifies the locale under which the specified instantiator(s ) will be added , and defaults to ' global .", "label": "", "metadata": {}, "score": "56.916855"}
{"text": "If COLOR is a specifier object , LOCALE can be a locale , a locale type , ' all , or nil ; see ' copy - specifier ' for its semantics .Otherwise LOCALE specifies the locale under which the specified instantiator(s ) will be added , and defaults to ' global .", "label": "", "metadata": {}, "score": "56.916855"}
{"text": "If COLOR is a specifier object , LOCALE can be a locale , a locale type , ' all , or nil ; see ' copy - specifier ' for its semantics .Otherwise LOCALE specifies the locale under which the specified instantiator(s ) will be added , and defaults to ' global .", "label": "", "metadata": {}, "score": "56.916855"}
{"text": "If COLOR is a specifier object , LOCALE can be a locale , a locale type , ' all , or nil ; see ' copy - specifier ' for its semantics .Otherwise LOCALE specifies the locale under which the specified instantiator(s ) will be added , and defaults to ' global .", "label": "", "metadata": {}, "score": "56.916855"}
{"text": "Try to find one by checking the specifier types from most specific ( buffer ) to most general ( global ) .If we find an instance , return it .Otherwise return Qunbound .In practice , when called from redisplay the arg will usually be a window and occasionally a frame .", "label": "", "metadata": {}, "score": "56.932373"}
{"text": "Syntax .EBNF Syntax below , which lowers the Abstract Syntax , is used throughout this document to explain and illustrate the main ideas . presentation . syntax , described in this EBNF ( usual except for whitespace handling ) , is work in progress and under discussion .", "label": "", "metadata": {}, "score": "56.97671"}
{"text": "( face - property - instance face ' highlight domain default no - fallback ) ) ( defun set - face - highlight - p ( face highlight - p & optional locale tag - set how - to - add ) \" Change whether FACE is highlighted in LOCALE ( TTY locales only ) .", "label": "", "metadata": {}, "score": "57.049477"}
{"text": "( face - property - instance face ' highlight domain default no - fallback ) ) ( defun set - face - highlight - p ( face highlight - p & optional locale tag - set how - to - add ) \" Change whether FACE is highlighted in LOCALE ( TTY locales only ) .", "label": "", "metadata": {}, "score": "57.049477"}
{"text": "Local variables are implemented directly as C++ local Fat Pointer variables . \" getter \" , \" setter \" , and \" newValue \" above are Locals .A Field is a state variable of a lexical - composite , so it lives in the frame of that lexical - composite .", "label": "", "metadata": {}, "score": "57.05593"}
{"text": "Seoul Korea : Hanshin Pub . Co. , pp . 111 - 139 .Fillmore , C.J. , Kay , P. & O'Connor , M.C. , 1988 .Regularity and Idiomaticity in Grammatical Constructions : The Case of Let Alone .Language , 64(3 ) , pp.501 - 538 .", "label": "", "metadata": {}, "score": "57.07125"}
{"text": "The induction and representation of categories .In : Harnad , S. ( ed . )Categorical Perception : The Groundwork of Cognition .New York : Cambridge University Press .Harnad , S. ( 1990 )The Symbol Grounding Problem .", "label": "", "metadata": {}, "score": "57.10259"}
{"text": "See ' set - face - property ' for the semantics of the LOCALE , TAG - SET , and HOW - TO - ADD arguments . \"( interactive ( face - interactive \" blinking - p \" \" blinking \" ) ) ( set - face - property face ' blinking blinking - p locale tag - set how - to - add ) ) ( defun face - reverse - p ( face & optional domain default no - fallback ) \" Return t if FACE is reversed in DOMAIN ( TTY domains only ) .", "label": "", "metadata": {}, "score": "57.144478"}
{"text": "See ' set - face - property ' for the semantics of the LOCALE , TAG - SET , and HOW - TO - ADD arguments . \"( interactive ( face - interactive \" blinking - p \" \" blinking \" ) ) ( set - face - property face ' blinking blinking - p locale tag - set how - to - add ) ) ( defun face - reverse - p ( face & optional domain default no - fallback ) \" Return t if FACE is reversed in DOMAIN ( TTY domains only ) .", "label": "", "metadata": {}, "score": "57.144478"}
{"text": "Valid locales are devices , frames , windows , buffers , and ' global .\\(nil is not valid . )A domain is used to instance a specifier ( i.e. determine the specifier 's value in that domain ) .Valid domains are image instances , windows , frames , and devices .", "label": "", "metadata": {}, "score": "57.198204"}
{"text": "Many approaches for the combination of Description Logics and rules have been described in the academic literature .Most of these approaches are applicable to OWL DL or subsets thereof .For a brief overview of some of the approaches , see the corresponding section on the OWL Compatibility page .", "label": "", "metadata": {}, "score": "57.21469"}
{"text": "rif : local ( for constant symbols that are not visible outside of a particular set of RIF formulas ) .Symbols in this symbol space are used locally in their respective rule sets .This means that occurrences of the same rif : local -constant in different rule sets are viewed as unrelated distinct constants , but occurrences of the same constant in the same rule set must refer to the same object .", "label": "", "metadata": {}, "score": "57.25656"}
{"text": "rif : local ( for constant symbols that are not visible outside of a particular set of RIF formulas ) .Symbols in this symbol space are used locally in their respective rule sets .This means that occurrences of the same rif : local -constant in different rule sets are viewed as unrelated distinct constants , but occurrences of the same constant in the same rule set must refer to the same object .", "label": "", "metadata": {}, "score": "57.25656"}
{"text": "Well , sometime .( Currently May 2000 , 21.2 is in development .19.14 was released in June 1996 . )The instantiator can be any kind of Lisp object , and the\\n \" \" instance computed from it is likewise any kind of Lisp object .", "label": "", "metadata": {}, "score": "57.26866"}
{"text": "support polymorphic symbols ( i.e. , symbols that have more than one contextual use ; e.g. , of a constant and of a predicate ) .Such polymorphism is common practice in Logic Programming ( e.g. , [ Prolog ] , [ F - logic ] , [ HiLog ] ) and in [ RDF].", "label": "", "metadata": {}, "score": "57.269783"}
{"text": "( This is what redisplay does , in fact . ) NILP ( no_fallback ) , Qzero ) ; return UNBOUNDP ( instance ) ?This attempts to instantiate INST - LIST in the given DOMAIN , as if INST - LIST existed in a specification in SPECIFIER .", "label": "", "metadata": {}, "score": "57.28381"}
{"text": "See ' face - property ' for more information . \"( face - property face ' background locale tag - set exact - p ) ) ( defun face - background - instance ( face & optional domain default no - fallback ) \" Return the instance of FACE 's background in DOMAIN .", "label": "", "metadata": {}, "score": "57.28451"}
{"text": "See ' face - property ' for more information . \"( face - property face ' background locale tag - set exact - p ) ) ( defun face - background - instance ( face & optional domain default no - fallback ) \" Return the instance of FACE 's background in DOMAIN .", "label": "", "metadata": {}, "score": "57.28451"}
{"text": "Harnad , S. ( 1992 )Connecting Object to Symbol in Modeling Cognition .In : A. Clarke and R. Lutz ( Eds ) Connectionism in Context Springer Verlag .Harnad , S. , Hanson , S.J. & Lubin , J. ( 1991 )", "label": "", "metadata": {}, "score": "57.310513"}
{"text": "The referent 's properties do not appear directly as properties of the Debugger .Object instance ; the debugger can access them only through methods like Debugger .Object.prototype.getOwnPropertyDescriptor and Debugger .Object.prototype.defineProperty , ensuring that the debugger will not inadvertently invoke the referent 's getters and setters .", "label": "", "metadata": {}, "score": "57.339287"}
{"text": "If there is no older frame , this is null .True if the frame this Debugger .Frame instance refers to is still on the stack ( or , in the case of generator - iterator objects , has not yet finished its iteration ) ; false if it has completed execution or been popped in some other way .", "label": "", "metadata": {}, "score": "57.408363"}
{"text": "Frame instance referring to a generator - iterator frame has a strong reference to the generator - iterator object ; the frame ( and its object ) will live as long as the Debugger .Frame instance does .However , when the generator function returns , throws an exception , or is terminated , thus ending the iteration , the Debugger .", "label": "", "metadata": {}, "score": "57.67865"}
{"text": "doc - string Description of what the face 's normal use is .NOTE :This is not a specifier , unlike all the other built - in properties , and can not contain locale - specific values . \"( setq face ( get - face face ) ) ( if ( memq property built - in - face - specifiers ) ( set - specifier ( get face property ) value locale tag - set how - to - add ) ; ; This section adds user defined properties .", "label": "", "metadata": {}, "score": "57.80966"}
{"text": "doc - string Description of what the face 's normal use is .NOTE :This is not a specifier , unlike all the other built - in properties , and can not contain locale - specific values . \"( setq face ( get - face face ) ) ( if ( memq property built - in - face - specifiers ) ( set - specifier ( get face property ) value locale tag - set how - to - add ) ; ; This section adds user defined properties .", "label": "", "metadata": {}, "score": "57.80966"}
{"text": "Remove all breakpoints set in this script .If offset is present , remove all breakpoints set at that offset in this script ; if offset is not a valid bytecode offset in this script , throw an error .A Debugger .", "label": "", "metadata": {}, "score": "57.831814"}
{"text": "If more than one Debugger instance is debugging the same code , each Debugger gets a separate Debugger .Object instance for a given object .This allows the code using each Debugger instance to place whatever properties it likes on its own Debugger .", "label": "", "metadata": {}, "score": "57.87431"}
{"text": "If this value is not an object , it may be different from the value produced by the new expression , which will be the value of the frame 's this property .( In ECMAScript terms , the onPop handler receives the value returned by the [ [ Call ] ] method , not the value returned by the [ [ Construct ] ] method . )", "label": "", "metadata": {}, "score": "57.910667"}
{"text": "To adopt a constructional approach is to undertake a commitment in principle to account for the entirety of each language .( 1 )a. What have you done ?b. Never will I leave you .c. So will she .", "label": "", "metadata": {}, "score": "57.98919"}
{"text": "See ' face - property ' for more information . \"( face - property face ' foreground locale tag - set exact - p ) ) ( defun face - foreground - instance ( face & optional domain default no - fallback ) \" Return the instance of FACE 's foreground in DOMAIN .", "label": "", "metadata": {}, "score": "57.98978"}
{"text": "See ' face - property ' for more information . \"( face - property face ' foreground locale tag - set exact - p ) ) ( defun face - foreground - instance ( face & optional domain default no - fallback ) \" Return the instance of FACE 's foreground in DOMAIN .", "label": "", "metadata": {}, "score": "57.98978"}
{"text": "For instance , if p , a , and b are symbols then p(p(a ) p(a p c ) ) is a term .Even variables and general terms are allowed to occur in the position of predicates and function symbols , so p(a ) ( ?", "label": "", "metadata": {}, "score": "58.039898"}
{"text": "Let SigNames be a non - empty finite or countably infinite set of signature names .We . assume . require .that this set includes at least the following signature names : i and bool .The signature name i . is . intended .", "label": "", "metadata": {}, "score": "58.105736"}
{"text": "In this case , correspondence of atomic formulas would be defined in the same way as for OWL Full , i.e. a triple s p o .Namely , the RDF representation is required to fulfill certain disjointness conditions which are not required in the abstract syntax .", "label": "", "metadata": {}, "score": "58.115273"}
{"text": "Quantification : If \u03c6 is a well - formed formula and ?V 1 , ... , ?V n are variables then Exists ?V 1 ... ?V n ( \u03c6 ) and Forall ?V 1 ... ?V n ( \u03c6 ) are well - formed formulas .", "label": "", "metadata": {}, "score": "58.16638"}
{"text": "Notes on RIF - compliant support for symbol spaces .A RIF - compliant inference engine must support the following symbol spaces : xsd : string , xsd : decimal , xsd : time , xsd : date , xsd : dateTime , rdf : XMLLiteral , rif : text , rif : iri , rif : local .", "label": "", "metadata": {}, "score": "58.187332"}
{"text": "The set of truth values is denoted by TV .For RIF 's basic logic dialect , TV includes only two values , t ( true ) and f ( false ) .( See end note on truth values . )", "label": "", "metadata": {}, "score": "58.273743"}
{"text": "PSYCOLOQUY 3(59 ) frame - problem.1 .Hayes , P.J. and Ford , K.M. ( 1993 ) Effective Descriptions Need Not Be Complete .PSYCOLOQUY 4(21 ) frame - problem.5 .McCarthy , J ( 1963 )Situations , Actions and Causal Laws .", "label": "", "metadata": {}, "score": "58.274918"}
{"text": "recursively .All the components except the last five , I slot , I SF , I SR , I sub , I isa , are the same as before .The new mapping I slot is used to interpret frames ; the mappings I .", "label": "", "metadata": {}, "score": "58.27864"}
{"text": "Object instance referring to the copy .Note that this returns primitive values unchanged .This means you can use Debugger .Object.prototype.copy as a generic \" debugger value to debuggee value \" conversion function \u2014 within the limitations of the \" structured cloning \" algorithm .", "label": "", "metadata": {}, "score": "58.280357"}
{"text": "We also define the following mapping , I , based on the mappings I C , I V , and I F : .I ( ?v ) , if ?v is a variable in Var .Semantics of symbol spaces .", "label": "", "metadata": {}, "score": "58.29538"}
{"text": "Double quotes that appear inside strings are escaped with a backslash and a backslash that is supposed to appear in the string must be escaped with another backslash .xsd : time .This corresponds to the XML data type xsd : time .", "label": "", "metadata": {}, "score": "58.301033"}
{"text": "( setq face ( get - face face ) ) ( let ( ( specifier ( get face property ) ) ) ; ; if a user - property does not have a specifier but a ; ; locale was specified , put a specifier there . ; ; If there was already a value there , convert it to a ; ; specifier with the value as its ' global instantiator .", "label": "", "metadata": {}, "score": "58.318665"}
{"text": "( setq face ( get - face face ) ) ( let ( ( specifier ( get face property ) ) ) ; ; if a user - property does not have a specifier but a ; ; locale was specified , put a specifier there . ; ; If there was already a value there , convert it to a ; ; specifier with the value as its ' global instantiator .", "label": "", "metadata": {}, "score": "58.318665"}
{"text": "Var , ATOMIC , and CONDITION were defined as part of the syntax for positive conditions in Positive Conditions .The symbol : - denotes the implication connective used in rules .The statement ATOMIC : - CONDITION should be informally read as if CONDITION is true then ATOMIC is also true .", "label": "", "metadata": {}, "score": "58.37503"}
{"text": "; ; ; Code : ( defgroup faces nil \" Support for multiple text attributes ( fonts , colors , ... )Such a collection of attributes is called a \\\"face\\ \" . \"( funcall fn face ) ) ) ( value ( if bool ( y - or - n - p ( format \" Should face % s be % s ? \"", "label": "", "metadata": {}, "score": "58.378845"}
{"text": "; ; ; Code : ( defgroup faces nil \" Support for multiple text attributes ( fonts , colors , ... )Such a collection of attributes is called a \\\"face\\ \" . \"( funcall fn face ) ) ) ( value ( if bool ( y - or - n - p ( format \" Should face % s be % s ? \"", "label": "", "metadata": {}, "score": "58.378845"}
{"text": "See ' remove - specifier ' for the meaning of the LOCALE , TAG - SET , and EXACT - P arguments .\" This makes FACE inherit all its display properties from ' default .WARNING : Be absolutely sure you want to do this ! ! !", "label": "", "metadata": {}, "score": "58.431213"}
{"text": "See ' remove - specifier ' for the meaning of the LOCALE , TAG - SET , and EXACT - P arguments .\" This makes FACE inherit all its display properties from ' default .WARNING : Be absolutely sure you want to do this ! ! !", "label": "", "metadata": {}, "score": "58.431213"}
{"text": "If the variable is declared \" : final \" , the Slot object will only respond to getValue .Each case has four rows , corresponding to the four variable usage constructs .The upper left box will show all the variable decalarions that this case applies to -- one per line .", "label": "", "metadata": {}, "score": "58.43642"}
{"text": "See ' face - property ' for more information . \"( face - property face ' display - table locale tag - set exact - p ) ) ( defun face - display - table - instance ( face & optional domain default no - fallback ) \" Return the instance of FACE 's display table in DOMAIN .", "label": "", "metadata": {}, "score": "58.478043"}
{"text": "See ' face - property ' for more information . \"( face - property face ' display - table locale tag - set exact - p ) ) ( defun face - display - table - instance ( face & optional domain default no - fallback ) \" Return the instance of FACE 's display table in DOMAIN .", "label": "", "metadata": {}, "score": "58.478043"}
{"text": "A specifier is an object that can be used to keep track of a property whose value can be per - buffer , per - window , per - frame , or per - device , and can further be restricted to a particular console - type or device - class .", "label": "", "metadata": {}, "score": "58.494156"}
{"text": "( face - property - instance face ' dim domain default no - fallback ) ) ( defun set - face - dim - p ( face dim - p & optional locale tag - set how - to - add ) \" Change whether FACE is dimmed in LOCALE ( TTY locales only ) .", "label": "", "metadata": {}, "score": "58.49881"}
{"text": "( face - property - instance face ' dim domain default no - fallback ) ) ( defun set - face - dim - p ( face dim - p & optional locale tag - set how - to - add ) \" Change whether FACE is dimmed in LOCALE ( TTY locales only ) .", "label": "", "metadata": {}, "score": "58.49881"}
{"text": "A subclass term of the form t 1 # # t 2 is well - formed and has a signature \u03ba iff .Note that , according to the above definition , f ( ) and f are distinct terms .We define atomic formulas as follows : .", "label": "", "metadata": {}, "score": "58.499405"}
{"text": "Whether such scripts appear can be affected by the garbage collector 's behavior , so this function 's behavior is not entirely deterministic .Remove all breakpoints set in this Debugger instance that use handler as their handler .Note that , if breakpoints using other handler objects are set at the same location(s ) as handler , they remain in place .", "label": "", "metadata": {}, "score": "58.52127"}
{"text": "For every primitive datatype symsp it must hold that : .That is , when restricted to a symbol space , symsp , I C must map the corresponding constants according to L symsp .RIF - BLD does not impose restrictions on the interpretation of constants ( the mapping I C ) in symbol spaces which are not primitive datatypes .", "label": "", "metadata": {}, "score": "58.54218"}
{"text": "If it is nil , then apply SPEC to each frame individually .See ' defface ' for information about SPEC . \" Iff optional FRAME is non - nil , set it for that frame only .See ' defface ' for information about SPEC . \"", "label": "", "metadata": {}, "score": "58.55004"}
{"text": "If it is nil , then apply SPEC to each frame individually .See ' defface ' for information about SPEC . \" Iff optional FRAME is non - nil , set it for that frame only .See ' defface ' for information about SPEC . \"", "label": "", "metadata": {}, "score": "58.55004"}
{"text": "( cond ( ( eq ' x ( frame - type frame ) ) ( x - init - frame - faces frame ) ) ( ( eq ' mswindows ( frame - type frame ) ) ( mswindows - init - frame - faces frame ) ) ; ; Is there anything which should be done for TTY 's ? ) ) ) ; ; # # # # This is somewhat X - specific , and is called when the first ; ; X device is created ( even if there were TTY devices created ; ; beforehand ) .", "label": "", "metadata": {}, "score": "58.580193"}
{"text": "( cond ( ( eq ' x ( frame - type frame ) ) ( x - init - frame - faces frame ) ) ( ( eq ' mswindows ( frame - type frame ) ) ( mswindows - init - frame - faces frame ) ) ; ; Is there anything which should be done for TTY 's ? ) ) ) ; ; # # # # This is somewhat X - specific , and is called when the first ; ; X device is created ( even if there were TTY devices created ; ; beforehand ) .", "label": "", "metadata": {}, "score": "58.580193"}
{"text": "If DEST is nil or omitted , a new specifier will be created and the specifications copied into it .Otherwise , the specifications will be copied into the existing specifier in DEST .If LOCALE is nil or ' all , all specifications will be copied .", "label": "", "metadata": {}, "score": "58.616867"}
{"text": "If s is a constant or variable symbol with signature \u03b7 then s is a well - formed term with signature \u03b7 .A term t ( t 1 ... t n ) is a well - formed atomic formula iff it is a well - formed term with the signature atomic .", "label": "", "metadata": {}, "score": "58.665337"}
{"text": "The statement ATOMIC : - CONDITION should be informally read as if CONDITION is true then ATOMIC is also true .Rules are generated by the Implies production .Facts are generated by the ATOMIC production , and can be viewed as the then part of an Implies with an empty conjunctive if ( or with true as the if part ) .", "label": "", "metadata": {}, "score": "58.727272"}
{"text": "Symbols in that symbol space have the form \" XYZ\"^^rif : local , where XYZ is any string of characters ( provided that each occurrence of \" and of \\ in such a string is escaped with a backslash ) .Thus , the lexical space of rif : local is the same as the lexical space of xsd : string .", "label": "", "metadata": {}, "score": "58.80768"}
{"text": "A generator frame disappears from the stack each time the generator yields a value and is suspended , and reappears atop the stack when it is resumed to produce the generator 's next value .The same Debugger .Frame instance refers to the generator frame until it returns , throws an exception , or is terminated .", "label": "", "metadata": {}, "score": "58.808144"}
{"text": "The symbols f n p n , and bi n are reserved signature names in RIF - BLD .It can not have the signature atomic or bi_atomic ( only terms can have such signatures , not symbols ) .The constant symbols that correspond to XML Schema data types all have the signature term in RIF - BLD .", "label": "", "metadata": {}, "score": "58.810604"}
{"text": "If this environment represents the variable environment ( the top - level environment within the function , which receives var definitions ) for a call to a function f , then this property 's value is a Debugger .Object instance referring to f. Otherwise , this property 's value is null .", "label": "", "metadata": {}, "score": "58.912712"}
{"text": "See ' set - face - property ' for the semantics of the LOCALE , TAG - SET , and HOW - TO - ADD arguments . \"( interactive ( face - interactive \" highlight - p \" \" highlighted \" ) ) ( set - face - property face ' highlight highlight - p locale tag - set how - to - add ) ) ( defun face - dim - p ( face & optional domain default no - fallback ) \" Return t if FACE is dimmed in DOMAIN ( TTY domains only ) .", "label": "", "metadata": {}, "score": "58.913353"}
{"text": "See ' set - face - property ' for the semantics of the LOCALE , TAG - SET , and HOW - TO - ADD arguments . \"( interactive ( face - interactive \" highlight - p \" \" highlighted \" ) ) ( set - face - property face ' highlight highlight - p locale tag - set how - to - add ) ) ( defun face - dim - p ( face & optional domain default no - fallback ) \" Return t if FACE is dimmed in DOMAIN ( TTY domains only ) .", "label": "", "metadata": {}, "score": "58.913353"}
{"text": "If the finally block finishes normally , the exception resumes propagation , and the debugger 's onExceptionUnwind handler is called again , in the same frame .( The other possibility is for the finally block to exit due to a return , continue , or break statement , or a new exception .", "label": "", "metadata": {}, "score": "58.91967"}
{"text": "The symbol space rif : local is used for constant symbols ( including predicate and function symbols ) that are local to the various sets of RIF formulas .They are not visible outside . of .the . rule . set . in . which .", "label": "", "metadata": {}, "score": "58.92198"}
{"text": "Each symbol in Const belongs to a symbol space .Each symbol space has an associated lexical space and a number of identifiers .The lexical space of a symbol space is a non - empty set of Unicode character strings .", "label": "", "metadata": {}, "score": "58.9243"}
{"text": "See ' set - face - property ' for the semantics of the LOCALE , TAG - SET , and HOW - TO - ADD arguments . \"( interactive ( face - interactive \" underline - p \" \" underlined \" ) ) ( set - face - property face ' underline underline - p locale tag - set how - to - add ) ) ( defun face - strikethru - p ( face & optional domain default no - fallback ) \" Return t if FACE is strikethru - d ( i.e. struck through ) in DOMAIN .", "label": "", "metadata": {}, "score": "59.02456"}
{"text": "See ' set - face - property ' for the semantics of the LOCALE , TAG - SET , and HOW - TO - ADD arguments . \"( interactive ( face - interactive \" underline - p \" \" underlined \" ) ) ( set - face - property face ' underline underline - p locale tag - set how - to - add ) ) ( defun face - strikethru - p ( face & optional domain default no - fallback ) \" Return t if FACE is strikethru - d ( i.e. struck through ) in DOMAIN .", "label": "", "metadata": {}, "score": "59.02456"}
{"text": "Conjunction .Disjunction .Classical negation .Default negation .Rule .Quantification : universal and existential .A dialect might support all of these formulas or it might impose various restrictions .For instance , the formulas in the conclusion and the premises of rules might be restricted , certain quantifications might be prohibited , classical or default negation ( or both ) might not be allowed , etc . .", "label": "", "metadata": {}, "score": "59.02972"}
{"text": "RDF , .RIF .Classes are also objects .For instance , they can be members of some other classes .( In object - oriented languages these latter classes are known as meta - classes . )Subclass formula : s##c , where s , c are well - formed terms .", "label": "", "metadata": {}, "score": "59.108696"}
{"text": "Environment instance represents a lexical environment , associating names with variables .Each Debugger .Frame instance representing a debuggee frame has an associated environment object describing the variables in scope in that frame ; and each Debugger .Object instance representing a debuggee function has an environment object representing the environment the function has closed over .", "label": "", "metadata": {}, "score": "59.138996"}
{"text": "If the referent is not a function that is debuggee code , return undefined .Each argument must be a debuggee value .All extant handler methods , breakpoints , watchpoints , and so on remain active during the call .Details of how the call is carried out are given in the description of [ [ # Debugger .", "label": "", "metadata": {}, "score": "59.173466"}
{"text": "Such a set can thus be infinite , finite , or even empty .In RIF - BLD , signatures can have at most one arrow expression .Other dialects ( such as HiLog [ CKW93 ] , for example ) may require polymorphic symbols and thus allow signatures with more than one arrow expression in them .", "label": "", "metadata": {}, "score": "59.228523"}
{"text": "The main arguments for option 2 are ( i ) that it is easier to implement ( assuming there are complete OWL Full reasoners around , which is actually not a very realistic assumption ) and ( ii ) easier to extend towards rule languages with negation .", "label": "", "metadata": {}, "score": "59.287853"}
{"text": "However , in the special case where both the old and new predicates are nil , we know that we do n't have to do this .( It 's probably common for people to call ( define - specifier - tag ) more than once on the same tag , and the most common case is where PREDICATE is not specified . ) NILP ( call1 ( predicate , device ) ) ?", "label": "", "metadata": {}, "score": "59.328766"}
{"text": "The class Ruleset contains zero or more RULE s , which are universally quantified RIF CLAUSE s. The class Forall is specified through its parts , i.e. , zero or more variable ( Var ) declarations and a CLAUSE formula , which can be an Implies or an ATOMIC formula .", "label": "", "metadata": {}, "score": "59.449753"}
{"text": "The above is a standard syntax for a variant of first - order logic .The application of a symbol from Const to a sequence of terms is called Uniterm ( \" Universal term \" ) since it can be used to play the role of a function term or an atomic formula depending on the syntactic context in which the application occurs .", "label": "", "metadata": {}, "score": "59.508392"}
{"text": "DISPLAY is part of a spec such as can be used in ' defface ' .If FRAME is nil or omitted , the selected frame is used .\" If FRAME is nil or omitted , initialize them for all frames .", "label": "", "metadata": {}, "score": "59.55655"}
{"text": "DISPLAY is part of a spec such as can be used in ' defface ' .If FRAME is nil or omitted , the selected frame is used .\" If FRAME is nil or omitted , initialize them for all frames .", "label": "", "metadata": {}, "score": "59.55655"}
{"text": "A script for code passed to direct eval is at a static level one greater than that of the script containing the call to eval , because direct eval code runs within the caller 's scope .However , a script for code passed to an indirect eval call is at static level zero , since it is evaluated in the global scope . should be set in g 's script , not in f 's , even though neither script contains code at that line .", "label": "", "metadata": {}, "score": "59.5739"}
{"text": "Only instantiators where TAG - SET ( a list of zero or more tags ) is a subset of ( or possibly equal to ) the instantiator 's tag set are copied .The default value of nil is a subset of all tag sets , so in this case no instantiators will be screened out .", "label": "", "metadata": {}, "score": "59.588787"}
{"text": "To illustrate the above definitions , we give several examples .Consider the term p(p(a ) p(a b c ) ) .An even more advanced example of a signature is when the right - hand side of an arrow expression is a signature other than i or bool .", "label": "", "metadata": {}, "score": "59.67047"}
{"text": "Positional information is optionally exploited only for the arg role elements .For example , role elements ( declare and formula ) are explicit within the Exists element .Following the examples of Java and RDF , we use capitalized names for class elements and names that start with lowercase for role elements .", "label": "", "metadata": {}, "score": "59.708324"}
{"text": "Thus , classes are also objects and they can be members of some other classes .( In object - oriented languages these latter classes are sometimes known as meta - classes . )Subclass formula : s # # c , where s , c are well - formed terms .", "label": "", "metadata": {}, "score": "59.736088"}
{"text": "Their value spaces and the lexical - to - value space mappings are defined as follows : .For XML Schema data types ( xsd : long , xsd : integer , xsd : decimal , xsd : string , xsd : time , and xsd : dateTime ) , these are defined in the XML Schema Part 2 : Datatypes specification .", "label": "", "metadata": {}, "score": "59.845467"}
{"text": "An Outer variable is one whose defining occurence is outside any scope box , and is therefore considered to be part of the outer scope . \" any \" above is an outer - variable .This optimization places a severe limit on separate compilation , as a Script would then be specific to the outer scope in which the top - level expression was evaluated .", "label": "", "metadata": {}, "score": "59.893562"}
{"text": "( Note that with statements have their own environment type . )A Debugger .Object instance referring to the object whose properties this environment reflects .If this is a declarative environment record , this accessor throws a TypeError ( since declarative environment records have no such object ) .", "label": "", "metadata": {}, "score": "59.940414"}
{"text": "Obviously , he wrote many more but compared to his massive impact , his output was relatively modest .His ideas have been with me all through my life as a linguist and on reflection , they form a foundation about what I know language to be .", "label": "", "metadata": {}, "score": "59.98268"}
{"text": "See ' set - face - property ' for the semantics of the LOCALE , TAG - SET , and HOW - TO - ADD arguments . \"( interactive ( face - interactive \" dim - p \" \" dimmed \" ) ) ( set - face - property face ' dim dim - p locale tag - set how - to - add ) ) ( defun face - blinking - p ( face & optional domain default no - fallback ) \" Return t if FACE is blinking in DOMAIN ( TTY domains only ) .", "label": "", "metadata": {}, "score": "60.031395"}
{"text": "See ' set - face - property ' for the semantics of the LOCALE , TAG - SET , and HOW - TO - ADD arguments . \"( interactive ( face - interactive \" dim - p \" \" dimmed \" ) ) ( set - face - property face ' dim dim - p locale tag - set how - to - add ) ) ( defun face - blinking - p ( face & optional domain default no - fallback ) \" Return t if FACE is blinking in DOMAIN ( TTY domains only ) .", "label": "", "metadata": {}, "score": "60.031395"}
{"text": "We need not consider BoxedFields declared \" : final \" , as final field variable usage will always be FastField usage .C++ .name : settable .name .frame [ index ] .frame [ index ] .& name .", "label": "", "metadata": {}, "score": "60.04381"}
{"text": "For further details on defining the semantics for RIF dialects see end note on intended models for rule sets .We will now define what it means for a set of rules to entail a RIF condition .Let S be a RIF ruleset and \u03c6 a closed RIF condition ( a condition with no occurrences of free variables ) .", "label": "", "metadata": {}, "score": "60.055847"}
{"text": "Some debugger operations that appear to simply inspect the debuggee 's state may actually cause debuggee code to run .For example , reading a variable might run a getter function on the global or on a with expression 's operand ; and getting an object 's property descriptor will run a handler trap if the object is a proxy .", "label": "", "metadata": {}, "score": "60.093876"}
{"text": "The ' Exists ' formula is an \" existential formula \" , which in Horn - like conditions is the only quantified formula but in later conditions may be complemented with \" universal formula \" ( Var+ denotes the list of free variables in CONDITION ) .", "label": "", "metadata": {}, "score": "60.120552"}
{"text": "I sub gives meaning to the subclass relationship .The truth valuation for classification formulas of the form sc # # cl , where sc and cl are terms , is defined as follows : .In addition , we want the operator # # to be transitive , i.e. , we would like c1 # # c2 and c2 # # c3 to imply c1 # # c3 .", "label": "", "metadata": {}, "score": "60.191624"}
{"text": "This function is ugly and messy and is primarily used as an internal helper function for ' make - face - bold ' et al . , so you probably do n't want to use it or read the rest of the documentation .", "label": "", "metadata": {}, "score": "60.198235"}
{"text": "This function is ugly and messy and is primarily used as an internal helper function for ' make - face - bold ' et al . , so you probably do n't want to use it or read the rest of the documentation .", "label": "", "metadata": {}, "score": "60.198235"}
{"text": "X( book^^rif : local ( ?I ? X ( ?I ? X ( ?X ?X ?I ?X ?S ( ?X ?EDITORS ' NOTE :The XML syntax for BLD presented here is one of the proposals the Working Group is considering .", "label": "", "metadata": {}, "score": "60.29255"}
{"text": "Only instantiators where TAG - SET ( a list of zero or more tags ) is a subset of ( or possibly equal to ) the instantiator 's tag set are removed .The default value of nil is a subset of all tag sets , so in this case no instantiators will be screened out .", "label": "", "metadata": {}, "score": "60.325882"}
{"text": "( Forall tr ( s p o . ) ) for every RDF axiomatic triple s p o . ) union .x And(dt ( ? x , u ) dt ( ? x , u ' ) ) for any two URIs u and u ' in the domain of D RIF such that the value spaces of D RIF ( u ) and D RIF ( u ' ) are disjoint , and does not entail Exists ?", "label": "", "metadata": {}, "score": "60.35576"}
{"text": "( defun face - underline - p ( face & optional domain default no - fallback ) \" Return t if FACE is underlined in DOMAIN .See ' face - property - instance ' for the semantics of the DOMAIN argument . \"", "label": "", "metadata": {}, "score": "60.396698"}
{"text": "( defun face - underline - p ( face & optional domain default no - fallback ) \" Return t if FACE is underlined in DOMAIN .See ' face - property - instance ' for the semantics of the DOMAIN argument . \"", "label": "", "metadata": {}, "score": "60.396698"}
{"text": "In order to talk about the slotted terms that are also well - formed , we need to extend the notion of a signature to include slots .But now a signature expression can be not only a base expression or an arrow expression ; it can , in addition , be a slotted arrow expression .", "label": "", "metadata": {}, "score": "60.415264"}
{"text": "The getterSetterPair function defines an allocation - contour , as do the two nested functions .Since getter and setter are both defined directly within this allocation - contour ( not within a nested contour ) , they jointly form a lexical - composite , of which they are the two direct - lexical - facets .", "label": "", "metadata": {}, "score": "60.4376"}
{"text": "It is meant to evolve to a specification of OWL compatibility for BLD .Besides this page , the working group might create a page which exemplifies typical usage patterns when combining OWL and rules .This section , together with the mentioned usage patterns , are expected to be included in Recommendation - track deliverable on using RIF in combination with OWL , as called for by the working group charter .", "label": "", "metadata": {}, "score": "60.524742"}
{"text": "The set of all symbol spaces that partition Const is considered to be part of the logic language used by RIF rule sets .RIF supports the following symbol spaces .Rule sets that are exchanged through RIF can use additional symbol spaces as explained below .", "label": "", "metadata": {}, "score": "60.59116"}
{"text": "To simplify the language , we will often use symbol space identifiers to refer to the actual symbol spaces ( for instance , we may use \" symbol space xsd : string \" instead of \" symbol space identified by xsd : string \") .", "label": "", "metadata": {}, "score": "60.591454"}
{"text": "Even though RDF allows the use of arbitrary datatype URIs in typed literals , not all such datatype URIs are recognized in the semantics .In fact , simple entailment does not recognize any datatype and RDF and RDFS entailment recognize only the XML content datatype ( identified with rdf : XMLLiteral ) .", "label": "", "metadata": {}, "score": "60.601585"}
{"text": "internationalized . resource identifier or IRI ) and rif : local ( for constant symbols that are not visible outside of a particular set of RIF formulas ) .for .symbol spaces . in .the . syntax .we .", "label": "", "metadata": {}, "score": "60.68421"}
{"text": "The following extends the XML syntax of Positive Conditions , by serializing the above Abstract EBNF Syntax of RIF Horn rules in XML .The Forall element contains the role elements declare and formula , which were earlier used within the Exists element of Positive Conditions .", "label": "", "metadata": {}, "score": "60.7129"}
{"text": "The lowering of the abstract syntax to this .concrete . presentation . syntax can be done via automatic EBNF - to - EBNF mapping .The mapper , abs2con4 g ( \" abs tract to con crete for g rammar \" ) , uses a TokenTable parameter specifying how to map certain abstract classes , in prefix notation , to .", "label": "", "metadata": {}, "score": "60.754295"}
{"text": "If it returns undefined , the exception continues to propagate as normal : if control in frame is in a try block , control jumps to the corresponding catch or finally block ; otherwise , frame is popped , and the exception propagates to frame 's caller .", "label": "", "metadata": {}, "score": "60.75866"}
{"text": "( interactive ( face - interactive \" font \" ) ) ( set - face - property face ' font font locale tag - set how - to - add ) ) ( defun face - foreground ( face & optional locale tag - set exact - p ) \" Return the foreground of FACE in LOCALE , or nil if it is unspecified .", "label": "", "metadata": {}, "score": "60.770958"}
{"text": "( interactive ( face - interactive \" font \" ) ) ( set - face - property face ' font font locale tag - set how - to - add ) ) ( defun face - foreground ( face & optional locale tag - set exact - p ) \" Return the foreground of FACE in LOCALE , or nil if it is unspecified .", "label": "", "metadata": {}, "score": "60.770958"}
{"text": "TokenTable)VARNAME . quantified .All quantification is explicit .All variables introduced by quantification . should . also occur in the quantified formula .Initially , only existential quantification is used .Universal quantification will be introduced later .We adopt the usual scoping rules for quantifiers from first - order logic .", "label": "", "metadata": {}, "score": "60.782806"}
{"text": "This will attempt to make the font bold for X locales and will set the highlight flag for TTY locales .If LOCALE is nil , omitted , or ' all ' , this will attempt to frob all font specifications for FACE to make them appear bold .", "label": "", "metadata": {}, "score": "60.86621"}
{"text": "This will attempt to make the font bold for X locales and will set the highlight flag for TTY locales .If LOCALE is nil , omitted , or ' all ' , this will attempt to frob all font specifications for FACE to make them appear bold .", "label": "", "metadata": {}, "score": "60.86621"}
{"text": "The consumer is allowed to replace the constants in an unsupported symbol space with the corresponding constant symbols in a supported superspace .For example , \" 123\"^^xsd : short can be replaced with \" 123\"^^xsd : decimal and \" abc123\"^^xsd : IDREF with \" abc123\"^^xsd : string .", "label": "", "metadata": {}, "score": "60.89017"}
{"text": "We define two mappings for RDF graphs , one ( tr . ) in which variables are Skolemized , i.e. replaced with constant symbols , and one ( tr Q ) in which variables are existentially quantified .The function sk takes as arguments a formula with variables R , and returns a formula R ' , which is obtained from R by replacing every variable symbol ?", "label": "", "metadata": {}, "score": "60.8949"}
{"text": "They act like macros and are not visible in instance markup .Example 2 ( A RIF condition and its XML serialization ) : a. RIF condition : And ( Exists ?Buyer ( purchase ( ?Buyer ?Seller book ( ?", "label": "", "metadata": {}, "score": "60.93191"}
{"text": "the for statement head has two entry points at offsets 5 and 20 ( for the initialization , which is performed only once , and the loop test , which is performed at the start of each iteration ) ; .Return a new array whose elements are Debugger .", "label": "", "metadata": {}, "score": "60.983673"}
{"text": "X ( book ( ?I ? X ( ?I ? X ( ?X ?X ?I ?X ?S ( ?X ?( A RIF condition and its XML serialization ) : a. RIF condition : And ( Exists ?", "label": "", "metadata": {}, "score": "61.065437"}
{"text": "FACE may be either a face object or a symbol representing a face .Normally DOMAIN will be a window or nil ( meaning the selected window ) , and an instance object describing how the background appears in that particular window and buffer will be returned .", "label": "", "metadata": {}, "score": "61.068504"}
{"text": "FACE may be either a face object or a symbol representing a face .Normally DOMAIN will be a window or nil ( meaning the selected window ) , and an instance object describing how the background appears in that particular window and buffer will be returned .", "label": "", "metadata": {}, "score": "61.068504"}
{"text": "FACE may be either a face object or a symbol representing a face .Normally DOMAIN will be a window or nil ( meaning the selected window ) , and an instance object describing how the background appears in that particular window and buffer will be returned .", "label": "", "metadata": {}, "score": "61.068504"}
{"text": "FACE may be either a face object or a symbol representing a face .Normally DOMAIN will be a window or nil ( meaning the selected window ) , and an instance object describing how the background appears in that particular window and buffer will be returned .", "label": "", "metadata": {}, "score": "61.068504"}
{"text": "Correspondence is defined with respect to the abstract syntax of OWL DL , in which the atomic formulas are essentially unary and binary predicate expressions .In this case , class membership expressions in OWL DL correspond to unary predicate expressions in RIF , and property value expressions in OWL DL corresponds to binary predicate expressions in RIF .", "label": "", "metadata": {}, "score": "61.08972"}
{"text": "The following extends the XML syntax of Positive Conditions , by serializing the above EBNF Syntax of RIF Horn rules in XML .The Forall element contains the role elements declare and formula , which were earlier used within the Exists element of Positive Conditions .", "label": "", "metadata": {}, "score": "61.173775"}
{"text": "The transformation cases : . same .a : final(vg ) a .& a .x : final ?& a . same .x : final ?x : final ?getValue a_Slot . setValue(v ) ; v a_Slot .", "label": "", "metadata": {}, "score": "61.250122"}
{"text": "Object instance .( This function behaves like the standard Object.freeze function , except that the object to be sealed is implicit and in a different compartment from the caller . )Prevent properties from being added to the referent .( This function behaves like the standard Object.preventExtensions function , except that the object to operate on is implicit and in a different compartment from the caller . )", "label": "", "metadata": {}, "score": "61.288315"}
{"text": "In the next version of this document we intend to introduce a syntax for defining prefixes for compact URIs .Constant symbols that belong to the various symbol spaces have special presentation syntax and semantics .Formally , a symbol space is a named subset of the set of all constants , Const .", "label": "", "metadata": {}, "score": "61.30971"}
{"text": "Object instance whose referent is the global object .The stack frame frame is about to begin executing code .The exception value is being thrown by frame , which is running debuggee code .If it returns undefined , the exception is thrown as normal .", "label": "", "metadata": {}, "score": "61.339172"}
{"text": "For this , the mapper , abs2con4 g , and the table , class2token , of Section Positive Conditions are extended .TokenTable ) CONDITION . syntax )a. Universal form : Forall ? item ? deliverydate ? scheduledate ? item ) : - And ( perishable ( ? item ) delivered ( ? item ? item ? scheduledate ) timediff ( ? diffdate ? deliverydate ? scheduledate ) greaterThan ( ? diffdate 10 ) ) )", "label": "", "metadata": {}, "score": "61.376198"}
{"text": "Variables are written as Unicode strings preceded with the symbol \" ? \" The syntax for constant symbols is given in Section Symbol Spaces .The language of RIF - BLD is the set of formulas constructed using the above alphabet according to the rules spelled out below .", "label": "", "metadata": {}, "score": "61.432587"}
{"text": "This syntax is the normative XML serialization of the presentation syntax .The key features of this syntax are derived from the presentation syntax , but some aspects related to rule exchange do not have counterparts in the presentation syntax .In the RIF presentation syntax , variables are written as Unicode strings preceded with the symbol \" ? \" The syntax for constant symbols is given in Section Symbol Spaces below .", "label": "", "metadata": {}, "score": "61.53476"}
{"text": "The arguments LOCALE , TAG - SET and EXACT - P are the same as for ' remove - specifier ' . \"( mapc ( lambda ( x ) ( remove - specifier ( face - property face x ) locale tag - set exact - p ) ) built - in - face - specifiers ) nil ) ( defun set - face - parent ( face parent & optional locale tag - set how - to - add ) \" Set the parent of FACE to PARENT , for all properties .", "label": "", "metadata": {}, "score": "61.624657"}
{"text": "The arguments LOCALE , TAG - SET and EXACT - P are the same as for ' remove - specifier ' . \"( mapc ( lambda ( x ) ( remove - specifier ( face - property face x ) locale tag - set exact - p ) ) built - in - face - specifiers ) nil ) ( defun set - face - parent ( face parent & optional locale tag - set how - to - add ) \" Set the parent of FACE to PARENT , for all properties .", "label": "", "metadata": {}, "score": "61.624657"}
{"text": "name .& name .Ref(SettableBoxScript , namePtr ) .FastFields .An element of a state - array holds the current value of the variable .The state array itself is accessed by a C++ local thin pointer variable , here named \" frame \" .", "label": "", "metadata": {}, "score": "61.699158"}
{"text": "\" paleturquoise \" ) ( ( mswindows default color ) .\" green \" ) ) ' global ) ; ; Define some logical color names to be used when reading the pixmap files .As part of its Phase 1 deliverable , the RIF Working Group defines a condition language , which is envisioned to be a shared part of all RIF dialects .", "label": "", "metadata": {}, "score": "61.705467"}
{"text": "This allows the code using each Debugger instance to place whatever properties it likes on its own Debugger .Object instances , without worrying about interfering with other debuggers . )Debugger .Environment instances protect their referents from the garbage collector ; as long as the Debugger .", "label": "", "metadata": {}, "score": "61.74717"}
{"text": "Descriptors passed to handler 's methods are ordinary objects in the debugger 's compartment , except for value , get , and set properties in descriptors , which are debuggee values ; they are the sort of value expected by Debugger .", "label": "", "metadata": {}, "score": "61.75532"}
{"text": "The only requirement on these datatype maps is that the rdf : XMLLiteral datatype must be in there ; apart from that , an arbitrary number of datatypes can be used .OWL uses the same mechanism , but additionally requires the datatypes corresponding to xsd : string and xsd : integer to be defined .", "label": "", "metadata": {}, "score": "61.769703"}
{"text": "So , there are three sub - options : a )There are no requirements on the shape of the OWL DL ontology .b ) RIF recommends to use only the DLP subset of OWL DL in combination with RIF ; anyone wanting to go beyond this subset is on their own wrt . processing .", "label": "", "metadata": {}, "score": "61.77855"}
{"text": "Of the debugger 's objects , only Debugger .Object instances may be passed to the debuggee : when this occurs , the debuggee receives the Debugger .Object 's referent , not the Debugger .Object instance itself .In the descriptions below , the term \" debuggee value \" means either a primitive value or a Debugger .", "label": "", "metadata": {}, "score": "61.79306"}
{"text": "RIF , on the contrary , recognizes a number of different data types , and does not allow to express ill - typed literals .Finally , D - entailment is defined with respect to arbitrary datatype maps ( mappings from URIs to datatypes ) which include rdf : XMLLiteral , whereas RIF has a fixed number of datatypes , so it essentially has a fixed datatype map .", "label": "", "metadata": {}, "score": "61.87595"}
{"text": "It is a static error to assign to a value declared \" : final \" .Such programs must be rejected at compile time .Slot access .The \" & name \" expression evaluates to a Slot for accessing or modifying the value of variable \" name \" .", "label": "", "metadata": {}, "score": "61.89169"}
{"text": "A typed literal ( s , u ) is a well - typed literal if .u is in the domain of D RIF and s is in the lexical space of D RIF ( u ) .u is the URI of a symbol space defined by RIF and s is in the lexical space of the symbol space , or .", "label": "", "metadata": {}, "score": "61.89689"}
{"text": "The first instantiator that is valid for the domain ( usually this means that the instantiator is recognized by the device [ i.e. the X server or TTY device ] that the domain is on .The function ' face - property - instance ' actually does all this , and is used to determine how to display the face .", "label": "", "metadata": {}, "score": "61.968063"}
{"text": "The first instantiator that is valid for the domain ( usually this means that the instantiator is recognized by the device [ i.e. the X server or TTY device ] that the domain is on .The function ' face - property - instance ' actually does all this , and is used to determine how to display the face .", "label": "", "metadata": {}, "score": "61.968063"}
{"text": "The basic language does not need any special syntax for defining signatures -- all signature names are already defined : bool , i , f0 , f1 , p0 , p1 , etc .The dialects , however , will need a special sublanguage for defining signatures .", "label": "", "metadata": {}, "score": "61.977543"}
{"text": "No .Errors are handled in Lisp primitives implementation .Invalid domain is a design error here - kkm .At least try the fallback ...If this fails , then we just return Qunbound .If no instance can be generated for this domain , return DEFAULT .", "label": "", "metadata": {}, "score": "61.98806"}
{"text": "RIF - compliant implementations must support the following symbol spaces .Rule sets that are exchanged through RIF can use additional symbol spaces as explained below .This symbol space represents text strings with a language tag attached .The lexical space of rif : text is the set of all Unicode strings of the form ... @LANG , i.e. , strings that end with @LANG where LANG is a language identifier as defined in IETF RFC 3066 .", "label": "", "metadata": {}, "score": "62.070496"}
{"text": "NILP ( a ) & & !Read only are ghost specifiers unless Vunlock_ghost_specifiers is non - nil .All other specifiers are read - write .# # # # We should figure out the frequency with which this is called with the various types and reorder the check accordingly .", "label": "", "metadata": {}, "score": "62.121216"}
{"text": "Outers .Variable usage is by explicitly messaging a scope object that represents the top level scope of the lexically enclosing top level expression .This scope object is accessed through the C++ local Fat Pointer variable \" Outers \" .Within an object expression , Outers is initialized by .", "label": "", "metadata": {}, "score": "62.22097"}
{"text": "( color - instance - name ( face - foreground - instance face domain default no - fallback ) ) ) ( defun set - face - foreground ( face color & optional locale tag - set how - to - add ) \" Change the foreground color of FACE to COLOR in LOCALE .", "label": "", "metadata": {}, "score": "62.302574"}
{"text": "( color - instance - name ( face - foreground - instance face domain default no - fallback ) ) ) ( defun set - face - foreground ( face color & optional locale tag - set how - to - add ) \" Change the foreground color of FACE to COLOR in LOCALE .", "label": "", "metadata": {}, "score": "62.302574"}
{"text": "IP is a superset of the set of all k in D such that there exist a , b in D and I slot .Condition 1 ensures that all resources in an RDF interpretation correspond to elements in the RIF domain .", "label": "", "metadata": {}, "score": "62.317104"}
{"text": "For instance , some versions of NAF use three truth values : t , f , and u ( undefined ) .Handling of contradictions and uncertainty requires at least four truth values : t , u , f , and i ( inconsistent ) .", "label": "", "metadata": {}, "score": "62.336052"}
{"text": "For instance , some versions of NAF use three truth values : t , f , and u ( undefined ) .Handling of contradictions and uncertainty requires at least four truth values : t , u , f , and i ( inconsistent ) .", "label": "", "metadata": {}, "score": "62.336052"}
{"text": "If offset is omitted , return the handlers of all breakpoints set anywhere in this script .If offset is present , but not a valid offset in this script , throw an error .Remove all breakpoints set in this Debugger instance that use handler as their handler .", "label": "", "metadata": {}, "score": "62.385048"}
{"text": "( In the terms used by the ECMAScript specification , the VariableEnvironment of the execution context for the eval code is the referent . )Like evalInGlobal , but evaluate code using the referent as the variable object , but with a lexical environment extended with bindings from the object bindings .", "label": "", "metadata": {}, "score": "62.399685"}
{"text": "FACE may be either a face object or a symbol representing a face .See ' face - property ' for more information . \"( face - property face ' background - pixmap locale tag - set exact - p ) ) ( defun face - background - pixmap - instance ( face & optional domain default no - fallback ) \" Return the instance of FACE 's background pixmap in DOMAIN .", "label": "", "metadata": {}, "score": "62.447964"}
{"text": "FACE may be either a face object or a symbol representing a face .See ' face - property ' for more information . \"( face - property face ' background - pixmap locale tag - set exact - p ) ) ( defun face - background - pixmap - instance ( face & optional domain default no - fallback ) \" Return the instance of FACE 's background pixmap in DOMAIN .", "label": "", "metadata": {}, "score": "62.447964"}
{"text": "( cond ( frame ; ; Try to get from cache .( let ( ( cache ( frame - property frame ' custom - properties ) ) )( unless cache ; ; Oh well , get it then .( setq cache ( extract - custom - frame - properties frame ) ) ; ; and cache it ... ( set - frame - property frame ' custom - properties cache ) ) cache ) ) ; ; We avoid this cache , because various frame and device ; ; properties can change .", "label": "", "metadata": {}, "score": "62.495995"}
{"text": "( cond ( frame ; ; Try to get from cache .( let ( ( cache ( frame - property frame ' custom - properties ) ) )( unless cache ; ; Oh well , get it then .( setq cache ( extract - custom - frame - properties frame ) ) ; ; and cache it ... ( set - frame - property frame ' custom - properties cache ) ) cache ) ) ; ; We avoid this cache , because various frame and device ; ; properties can change .", "label": "", "metadata": {}, "score": "62.495995"}
{"text": "LOCALE works as in ' make - face - bold ' et al . , but the ' ' inheriting- from - the - bold - face ' ' operations described there are not done because they do n't make sense in this context .", "label": "", "metadata": {}, "score": "62.51322"}
{"text": "LOCALE works as in ' make - face - bold ' et al . , but the ' ' inheriting- from - the - bold - face ' ' operations described there are not done because they do n't make sense in this context .", "label": "", "metadata": {}, "score": "62.51322"}
{"text": "You can redefine an existing user - defined specifier tag .However , you can not redefine the built - in specifier tags ( the device types and classes ) or the symbols nil , t , ' all , or ' global .", "label": "", "metadata": {}, "score": "62.543167"}
{"text": "Valid locale types are ' global , ' device , ' frame , ' window , and ' buffer .\\(Note , however , that in functions that accept either a locale or a locale type , ' global is considered an individual locale . )", "label": "", "metadata": {}, "score": "62.561832"}
{"text": "VARNAME .The above is a standard syntax for a variant of first - order logic .The application of a constant ( Const ) symbol to a sequence of terms is called a Uniterm ( Universal term ) ; it can play the role of a term or an atomic formula depending on the syntactic context in which the application occurs .", "label": "", "metadata": {}, "score": "62.56549"}
{"text": "The following symbols have predefined meanings : foreground The foreground color of the face .For valid instantiators , see ' color - specifier - p ' .background The background color of the face .For valid instantiators , see ' color - specifier - p ' .", "label": "", "metadata": {}, "score": "62.613007"}
{"text": "The following symbols have predefined meanings : foreground The foreground color of the face .For valid instantiators , see ' color - specifier - p ' .background The background color of the face .For valid instantiators , see ' color - specifier - p ' .", "label": "", "metadata": {}, "score": "62.613007"}
{"text": "Dialects may further specialize this signature .S has at most one signature for any given signature name .Here \u03b7 S denotes a signature with the name \u03b7 and the associated set of arrow expression S ; similarly \u03ba R is a signature named \u03ba with the set of expressions R .", "label": "", "metadata": {}, "score": "62.665215"}
{"text": "( color - instance - name ( face - background - instance face domain default no - fallback ) ) ) ( defun set - face - background ( face color & optional locale tag - set how - to - add ) \" Change the background color of FACE to COLOR in LOCALE .", "label": "", "metadata": {}, "score": "62.678772"}
{"text": "( color - instance - name ( face - background - instance face domain default no - fallback ) ) ) ( defun set - face - background ( face color & optional locale tag - set how - to - add ) \" Change the background color of FACE to COLOR in LOCALE .", "label": "", "metadata": {}, "score": "62.678772"}
{"text": "This section develops a RIF - BLD Rule Sublanguage by extending the RIF Condition Language , where conditions become rule bodies .RIF Phase I covers only Horn Rules and a number of extensions that do not increase the expressive power of the language .", "label": "", "metadata": {}, "score": "62.682102"}
{"text": "x , because ?x is a variable occurring in the class position , which is generally incompatible with the direct semantics of OWL DL ) .Note that option 1 might also require certain syntactical restrictions in the rules , e.g. because OWL DL makes a distinction between object and datatype properties .", "label": "", "metadata": {}, "score": "62.69751"}
{"text": "I am far from being an expert on Fillmore 's work and life .This post reflects my personal perspective and lessons I 've learned rather than a comprehensive or objective reference work .I may have been rather free with the narrative arc of his work .", "label": "", "metadata": {}, "score": "62.83512"}
{"text": "Constant symbols that belong to this symbol space are intended to be used in a way similar to RDF resources .The lexical space consists of all absolute IRIs as specified in RFC 3987 ; it is unrelated to the XML primitive type anyURI .", "label": "", "metadata": {}, "score": "62.835625"}
{"text": "If global is a cross - compartment wrapper , this method returns a Debugger .Object instance referring to the wrapper 's referent .If global is a Debugger .Object instance belonging to this Debugger instance , this method returns global itself .", "label": "", "metadata": {}, "score": "62.835697"}
{"text": "Example 1 ( A RIF condition in and outside of a rule ) RIF condition : Exists ?Y ( condition ( ?X ?Y ) )RIF Horn rule : Forall ?X ( then_part ( ?X ) : - Exists ?", "label": "", "metadata": {}, "score": "62.839645"}
{"text": "In contrast , abc^^xsd : long is ill - formed , as it does not have a correct lexical part .A compliant RIF - BLD interpreter must reject ill - formed symbols .Symbols with undefined symbol spaces .RIF allows symbols of the form LITERAL^^SYMSPACE where SYMSPACE is not one of the pre - defined RIF symbol spaces .", "label": "", "metadata": {}, "score": "62.861122"}
{"text": "( interactive ( face - interactive \" foreground \" ) ) ( set - face - property face ' foreground color locale tag - set how - to - add ) ) ( defun face - background ( face & optional locale tag - set exact - p ) \" Return the background color of FACE in LOCALE , or nil if it is unspecified .", "label": "", "metadata": {}, "score": "63.007328"}
{"text": "( interactive ( face - interactive \" foreground \" ) ) ( set - face - property face ' foreground color locale tag - set how - to - add ) ) ( defun face - background ( face & optional locale tag - set exact - p ) \" Return the background color of FACE in LOCALE , or nil if it is unspecified .", "label": "", "metadata": {}, "score": "63.007328"}
{"text": "Ref(SettableBoxScript , & frame [ index ] ) .Ref(FinalBoxScript , & frame [ index ] ) .Note that \" & name \" on a FastField variable returns a Slot object that points directly into the middle of the frame in order to point at the variable 's storage .", "label": "", "metadata": {}, "score": "63.02398"}
{"text": "See ' set - face - property ' for the semantics of the LOCALE , TAG - SET , and HOW - TO - ADD arguments . \"( interactive ( face - interactive \" strikethru - p \" \" strikethru - d \" ) ) ( set - face - property face ' strikethru strikethru - p locale tag - set how - to - add ) ) ( defun face - highlight - p ( face & optional domain default no - fallback ) \" Return t if FACE is highlighted in DOMAIN ( TTY domains only ) .", "label": "", "metadata": {}, "score": "63.03661"}
{"text": "See ' set - face - property ' for the semantics of the LOCALE , TAG - SET , and HOW - TO - ADD arguments . \"( interactive ( face - interactive \" strikethru - p \" \" strikethru - d \" ) ) ( set - face - property face ' strikethru strikethru - p locale tag - set how - to - add ) ) ( defun face - highlight - p ( face & optional domain default no - fallback ) \" Return t if FACE is highlighted in DOMAIN ( TTY domains only ) .", "label": "", "metadata": {}, "score": "63.03661"}
{"text": "If there is only one instantiator , its value is nil , and its tag is ' any , a one - element list containing nil will be returned rather than just nil , to distinguish this case from there being no instantiators at all .", "label": "", "metadata": {}, "score": "63.05762"}
{"text": "For instance , the value space of xsd : long is defined to be a subset of xsd : decimal .The requirements imposed by the XML Schema specification may have interesting consequences for the mappings from the lexical space to the value space .", "label": "", "metadata": {}, "score": "63.072445"}
{"text": "When using a more limited garbage collector , an explicit FramedFieldSlot object should be allocated that points to the frame as a whole as well .BoxedFields .The state - array contains a reference to an arbitrary object expected to exhibit Slot behavior .", "label": "", "metadata": {}, "score": "63.124966"}
{"text": "Every handler method called while the debuggee is running in a given frame is given the same frame object .Similarly , walking the stack back to a previously accessed frame yields the same frame object as before .( If more than one Debugger instance is debugging the same code , each Debugger gets a separate Debugger .", "label": "", "metadata": {}, "score": "63.13887"}
{"text": "The Exists formula , where Var+ stands for the list of variables that are free in CONDITION , is an existential formula .It is the only kind of quantified formulas in RIF - BLD , but other dialects may add universal quantification .", "label": "", "metadata": {}, "score": "63.1734"}
{"text": "Name must be a string that is a valid ECMAScript identifier name .The result is a debuggee value .Store value as the value of the variable bound to name in this environment .Name must be a string that is a valid ECMAScript identifier name ; value must be a debuggee value .", "label": "", "metadata": {}, "score": "63.179367"}
{"text": "One example of where this function is useful is when you have a toolbar button whose ' active - p ' field is an expression to be evaluated .Calling ' set - specifier - dirty - flag ' on the toolbar specifier will force the ' active - p ' fields to be recomputed .", "label": "", "metadata": {}, "score": "63.18366"}
{"text": "If PIXMAP is a specifier object , LOCALE can be a locale , a locale type , ' all , or nil ; see ' copy - specifier ' for its semantics .Otherwise LOCALE specifies the locale under which the specified instantiator(s ) will be added , and defaults to ' global .", "label": "", "metadata": {}, "score": "63.26854"}
{"text": "If PIXMAP is a specifier object , LOCALE can be a locale , a locale type , ' all , or nil ; see ' copy - specifier ' for its semantics .Otherwise LOCALE specifies the locale under which the specified instantiator(s ) will be added , and defaults to ' global .", "label": "", "metadata": {}, "score": "63.26854"}
{"text": "This property must be either undefined or a function .If it is a function , SpiderMonkey calls it if the current frame is a generator frame whose execution has just been resumed .On newly created frames , this property 's value is undefined .", "label": "", "metadata": {}, "score": "63.294514"}
{"text": "Example 1 ( A RIF condition in and outside of a rule ) RIF condition : Exists ?Y ( condition ( ?X ?Y ) )RIF Horn rule : Forall ?X( then - part ( ?X ) : - Exists ?", "label": "", "metadata": {}, "score": "63.374928"}
{"text": "But I have no doubt that in the decades of language scholarship to come , it will be Fillmore and his ideas that will be the foundation upon which the edifice of linguistics will rest .May he rest in peace .", "label": "", "metadata": {}, "score": "63.40726"}
{"text": "Only direct children are included ; nested children can be reached by walking the tree .Set a breakpoint at the bytecode instruction at offset in this script , reporting hits to the hit method of handler .If offset is not a valid offset in this script , throw an error .", "label": "", "metadata": {}, "score": "63.411182"}
{"text": "The envisioned RIF dialects will extend the BLD rule language by generalizing the positive RIF conditions and by other means .class Ruleset property formula : list of RULE class RULE subclass Forall property declare : list of Var property formula : CLAUSE class CLAUSE subclass ATOMIC subclass Implies class Implies property if : CONDITION property then : ATOMIC .", "label": "", "metadata": {}, "score": "63.533363"}
{"text": "The mappings that constitute an interpretation , I , are as follows : .I C from Const to elements of D .I V from Var to elements of D .It is convenient to define a more general mapping , I , based on the mappings I C , I V , I F , and I R : .", "label": "", "metadata": {}, "score": "63.551918"}
{"text": "When a debugger in one compartment is debugging globals in another , many kinds of events in the debuggees may cause the debugger to call its handler methods .Conversely , a call to almost any method in this interface could cause the debugger to try to interact with a debuggee in some way .", "label": "", "metadata": {}, "score": "63.57674"}
{"text": "Garbage collection has no visible effect on Debugger .Environment instances .\" declarative \" , indicating that the environment is a declarative environment record .Function calls , calls to eval , let blocks , catch blocks , and the like create declarative environment records . \" object \" , indicating that the environment 's bindings are the properties of an object .", "label": "", "metadata": {}, "score": "63.66375"}
{"text": "If \u03c6 is a well - formed condition formula and ?V 1 , ... , ?V n are variables then Exists ?V 1 ... ?V n ( \u03c6 ) is a well - formed condition formula .Examples .", "label": "", "metadata": {}, "score": "63.66827"}
{"text": "Return an array L describing the relationship between bytecode instruction offsets and source code positions in this script .L is sparse , and indexed by source line number .If a source line number line has no code , then L has no line property .", "label": "", "metadata": {}, "score": "63.739864"}
{"text": "Such a set can thus be infinite , finite , or even empty .In RIF - BLD , signatures can have at most one arrow expression .Other dialects ( such as HiLog , for example ) may require polymorphic symbols and thus allow signatures with more than one arrow expression in them .", "label": "", "metadata": {}, "score": "63.835438"}
{"text": "RIF dialects that extend RIF - BLD will be specified in other documents by this working group .The condition sublanguage of RIF - BLD is intended to be a common basis for the dialects of RIF .First of all , it is used by RIF - BLD itself .", "label": "", "metadata": {}, "score": "63.856163"}
{"text": "If the optional FRAME argument is provided , change only in that frame ; otherwise change each frame . \"( while ( not ( find - face face ) )( setq face ( signal ' wrong - type - argument ( list ' facep face ) ) ) ) ( locate - file pixmap x - bitmap - file - path \" .", "label": "", "metadata": {}, "score": "63.925117"}
{"text": "If the optional FRAME argument is provided , change only in that frame ; otherwise change each frame . \"( while ( not ( find - face face ) )( setq face ( signal ' wrong - type - argument ( list ' facep face ) ) ) ) ( locate - file pixmap x - bitmap - file - path \" .", "label": "", "metadata": {}, "score": "63.925117"}
{"text": "b. Universal - existential form : Forall ? item ( reject^^rif : local ( ppl#John^^rif : iri ? item ) : - Exists ? deliverydate ? scheduledate ? diffduration ? diffdays ( And ( perishable^^rif : local ( ? item ) delivered^^rif : local ( ? item ? deliverydate ppl : John^^rif : iri ) scheduled^^rif : local ( ? item ? scheduledate ) fn : subtract - dateTimes - yielding - dayTimeDuration ( ? deliverydate ? scheduledate ? diffuration ) fn : get - days - from - dayTimeDuration ( ? diffduration ? diffdays ) op : numeric - greater - than ( ? diffdays 10 ) ) ) ) .", "label": "", "metadata": {}, "score": "64.03942"}
{"text": "For valid instantiators , see ' image - specifier - p ' .underline Underline all text covered by this face .For valid instantiators , see ' face - boolean - specifier - p ' .strikethru Draw a line through all text covered by this face .", "label": "", "metadata": {}, "score": "64.38877"}
{"text": "For valid instantiators , see ' image - specifier - p ' .underline Underline all text covered by this face .For valid instantiators , see ' face - boolean - specifier - p ' .strikethru Draw a line through all text covered by this face .", "label": "", "metadata": {}, "score": "64.38877"}
{"text": "Watchpoint handler calls are cross - compartment , intra - thread calls : the call takes place in the same thread that changed the property , and in handler 's method 's compartment ( typically the same as the debugger 's compartment ) .", "label": "", "metadata": {}, "score": "64.48799"}
{"text": "and all the symbol spaces that corresponds to the subtypes of xsd : decimal as specified in [ XML - SCHEMA2 ] .The lexical spaces of the above symbol spaces are defined in the document [ XML - SCHEMA2 ] .", "label": "", "metadata": {}, "score": "64.5001"}
{"text": "represents .the context where the constants that denote individual objects are allowed to appear .The name bool represents the context of atomic formulas .This set can be empty , finite , or countably infinite .In RIF 's basic logic dialect , this set will have at most one expression , but in more expressive dialects a signature can have more than one expression , and in this way they can support polymorphism .", "label": "", "metadata": {}, "score": "64.54198"}
{"text": "Object referring to it .The new object 's prototype is prototype , which must be an Debugger .Object instance .The new object 's properties are as given by properties , as if properties were passed to Debugger .Object.prototype.defineProperties , with the new Debugger .", "label": "", "metadata": {}, "score": "64.66374"}
{"text": "For valid instantiators , see ' font - specifier - p ' .display - table The display table of the face .This should be a vector of 256 elements . background - pixmap The pixmap displayed in the background of the face .", "label": "", "metadata": {}, "score": "64.75277"}
{"text": "For valid instantiators , see ' font - specifier - p ' .display - table The display table of the face .This should be a vector of 256 elements . background - pixmap The pixmap displayed in the background of the face .", "label": "", "metadata": {}, "score": "64.75277"}
{"text": "See that function for a description of exactly how the matching process works .GHOST_SPECIFIER_P ( sp ) ) ; if ( !If not , set a default so this never happens or correct it in the value_changed_in_window method .Unless you specify a caching instantiate method the instantiation that specifier_instance will do will always create a new copy .", "label": "", "metadata": {}, "score": "64.7765"}
{"text": "( face - property - instance face ' strikethru domain default no - fallback ) ) ( defun set - face - strikethru - p ( face strikethru - p & optional locale tag - set how - to - add ) \" Change whether FACE is strikethru - d ( i.e. struck through ) in LOCALE .", "label": "", "metadata": {}, "score": "64.97533"}
{"text": "( face - property - instance face ' strikethru domain default no - fallback ) ) ( defun set - face - strikethru - p ( face strikethru - p & optional locale tag - set how - to - add ) \" Change whether FACE is strikethru - d ( i.e. struck through ) in LOCALE .", "label": "", "metadata": {}, "score": "64.97533"}
{"text": "The returned instance will typically be a color - instance , font - instance , or pixmap - instance object , and you can query it using the appropriate object - specific functions .For example , you could use ' color - instance - rgb - components ' to find out the RGB ( red , green , and blue ) components of how the ' background property of the ' highlight face is displayed in a particular window .", "label": "", "metadata": {}, "score": "65.16313"}
{"text": "The returned instance will typically be a color - instance , font - instance , or pixmap - instance object , and you can query it using the appropriate object - specific functions .For example , you could use ' color - instance - rgb - components ' to find out the RGB ( red , green , and blue ) components of how the ' background property of the ' highlight face is displayed in a particular window .", "label": "", "metadata": {}, "score": "65.16313"}
{"text": "( error ' dark ) ) ) ) ( set - frame - property frame ' background - mode mode ) mode ) ) ( defun extract - custom - frame - properties ( frame ) \" Return a plist with the frame properties of FRAME used by custom .", "label": "", "metadata": {}, "score": "65.31732"}
{"text": "( error ' dark ) ) ) ) ( set - frame - property frame ' background - mode mode ) mode ) ) ( defun extract - custom - frame - properties ( frame ) \" Return a plist with the frame properties of FRAME used by custom .", "label": "", "metadata": {}, "score": "65.31732"}
{"text": "Frame instance , you can find the script the frame is executing , walk the stack to older frames , find the lexical environment in which the execution is taking place , and so on .For a given Debugger instance , SpiderMonkey creates only one Debugger .", "label": "", "metadata": {}, "score": "65.326126"}
{"text": "( add - spec - list - to - specifier sp ( list ( cons locale new - result ) ) ) ; ; tell map - specifier to keep going .If we 're ; ; inheriting from a standard face in this locale , frob the ; ; inheritance as appropriate .", "label": "", "metadata": {}, "score": "65.3291"}
{"text": "( add - spec - list - to - specifier sp ( list ( cons locale new - result ) ) ) ; ; tell map - specifier to keep going .If we 're ; ; inheriting from a standard face in this locale , frob the ; ; inheritance as appropriate .", "label": "", "metadata": {}, "score": "65.3291"}
{"text": "Sorted HiLog : Sorts in Higher - Order Logic Data Languages , W. Chen , M. Kifer .Sixth Intl .Conference on Database Theory , Prague , Czech Republic , January 1995 , Lecture Notes in Computer Science 893 , Springer Verlag , pp .", "label": "", "metadata": {}, "score": "65.36459"}
{"text": "XXX Note : the above after code needs a way to deal with coercion failure .This probably requires a change to the coercion protocol .Should we build a compiler capable of aggresive inlining of both code and data , we may no longer need to deslotify as aggresively or at all .", "label": "", "metadata": {}, "score": "65.51059"}
{"text": "( font - proportional - p ( face - font face ) domain charset ) ) ; ; Functions that used to be in cus - face .el , but logically go here .Set this to the symbol dark if your background color is dark , light if your background is light , or nil ( default ) if you want Emacs to examine the brightness for you .", "label": "", "metadata": {}, "score": "65.670845"}
{"text": "( font - proportional - p ( face - font face ) domain charset ) ) ; ; Functions that used to be in cus - face .el , but logically go here .Set this to the symbol dark if your background color is dark , light if your background is light , or nil ( default ) if you want Emacs to examine the brightness for you .", "label": "", "metadata": {}, "score": "65.670845"}
{"text": "Finally , most people who care about OWL DL find the semantics for the case of option 1 more natural .The working group might consider moving the definition of RIF - RDF combinations to that document as well .This section defines combinations of RIF rules with RDF graphs , taking into account the various ( normative ) entailment regimes defined by RDF .", "label": "", "metadata": {}, "score": "65.678825"}
{"text": "A datatype map is a mapping from URIs to datatypes .RIF has a fixed number of datatypes it supports .The datatype map of RIF , denoted with D RIF , is the mapping of datatype identifiers to datatypes as described in the section \" Symbol Spaces and Primitive Datatypes \" .", "label": "", "metadata": {}, "score": "65.71605"}
{"text": "All . logic - based .dialects are required to extend the RIF Basic Logic Dialect .From a theoretical perspective , RIF BLD corresponds to the language of definite Horn rules ( see Horn Logic ) with equality ( and with a standard first - order semantics ) .", "label": "", "metadata": {}, "score": "65.72095"}
{"text": "The order of the arguments in a slotted arrow expression is assumed to be immaterial , so any permutation of arguments is assumed to yield the same expression .By analogy with earlier definitions , if \u03ba is atomic then the expression is also a slotted Boolean expression .", "label": "", "metadata": {}, "score": "65.73546"}
{"text": "Any previous watchpoint handler on this property for this Debugger .Object instance is replaced .If handler is null , the property is no longer watched .Handler is as described for Debugger .Object.prototype.setObjectWatchpoint , except that it does not receive extensionsPrevented events .", "label": "", "metadata": {}, "score": "65.82353"}
{"text": "e. Had I known , . . .f. Am I tired !g. . . .as were the others h. Thus did the hen reward Beecher .Given such a commitment , the construction grammarian is required to develop an explicit system of representation , capable of encoding economically and without loss of generalization all the constructions ( or patterns ) of the language , from the most idiomatic to the most general .", "label": "", "metadata": {}, "score": "65.83335"}
{"text": "LITERAL must be an element in the lexical space of the symbol space .For instance , 1.2^^xsd : decimal and 1^^xsd : decimal are legal symbols because 1.2 and 1 are members of the lexical space of the XML Schema data type xsd : decimal .", "label": "", "metadata": {}, "score": "65.91525"}
{"text": "LITERAL must be an element in the lexical space of the symbol space .For instance , 1.2^^xsd : decimal and 1^^xsd : decimal are legal symbols because 1.2 and 1 are members of the lexical space of the XML Schema data type xsd : decimal .", "label": "", "metadata": {}, "score": "65.91525"}
{"text": "An OWL Full knowledge base can be seen as an external oracle , which is queried using special query atoms in the body .It should be noted at this point that most , if not all , currently available OWL Full reasoners are rule - based and implement a semantic ( and sometimes also syntactic ) subset .", "label": "", "metadata": {}, "score": "66.05172"}
{"text": "We will now define what it means for a set of rules to entail a RIF condition .Let S be a RIF ruleset and \u03c6 a closed RIF condition ( a condition with no free variables ) .Then we say that S entails \u03c6 , written as .", "label": "", "metadata": {}, "score": "66.056"}
{"text": "For example , role elements ( declare and formula ) are explicit within the Exists element .Following the examples of Java and RDF , we use capitalized names for class elements and names that start with lowercase for role elements .", "label": "", "metadata": {}, "score": "66.14836"}
{"text": "Primitive values are passed freely between debugger and debuggee ; copying or wrapping is handled transparently .Objects received from the debuggee ( including host objects like DOM elements ) are fronted in the debugger by Debugger .Object instances , which provide reflection - oriented methods for inspecting their referents ; see Debugger .", "label": "", "metadata": {}, "score": "66.17738"}
{"text": "Syntax such as xsd : string should be understood as a compact URI [ CURIE ] -- a macro that expands to a concatenation of the character sequence denoted by the prefix xsd and the string string .Constant symbols that belong to the various symbol spaces have special presentation syntax and semantics .", "label": "", "metadata": {}, "score": "66.321175"}
{"text": "( defun init - global - faces ( ) ; ; Look for global face resources .( loop for face in ( face - list ) do ( init - face - from - resources face ' global ) ) ; ; Further X frobbing .", "label": "", "metadata": {}, "score": "66.334885"}
{"text": "( defun init - global - faces ( ) ; ; Look for global face resources .( loop for face in ( face - list ) do ( init - face - from - resources face ' global ) ) ; ; Further X frobbing .", "label": "", "metadata": {}, "score": "66.334885"}
{"text": "For both 1a and 1b , the implementor is more - or - less on his own .However , these choices are probably the only ones which fulfill the requirements for the Interchanging Rule Extensions to OWL use case .An OWL DL knowledge base can be seen as an external oracle , which is queried using special query atoms in the body .", "label": "", "metadata": {}, "score": "66.40158"}
{"text": "Regardless of things , do the TTY ; ; frobbing .; ; yuck --The LOCALE argument to make - face - bold is not actually a locale , ; ; but is a \" locale , locale - type , or nil for all \" .", "label": "", "metadata": {}, "score": "66.771706"}
{"text": "Regardless of things , do the TTY ; ; frobbing .; ; yuck --The LOCALE argument to make - face - bold is not actually a locale , ; ; but is a \" locale , locale - type , or nil for all \" .", "label": "", "metadata": {}, "score": "66.771706"}
{"text": "Return true if the referent is extensible \u2014 that is , if it can have new properties defined on it .( This function behaves like the standard Object.isExtensible function , except that the object inspected is implicit and in a different compartment from the caller . )", "label": "", "metadata": {}, "score": "66.938545"}
{"text": "The document RIF Use Cases and Requirements includes a use case \" Negotiating eBusiness Contracts Across Rule Platforms \" , which discusses a business rule slightly modified here : .The prefix op is used for a yet - to - be - determined IRI , which will be used for RIF builtin predicates .", "label": "", "metadata": {}, "score": "66.96156"}
{"text": "As the debuggee runs , the Debugger interface calls various debugger - provided handler functions to report the debuggee 's behavior .Some of these calls can return a value indicating how the debuggee 's execution should continue ; these are called resumption values .", "label": "", "metadata": {}, "score": "67.20714"}
{"text": "( interactive ( face - interactive \" background \" ) ) ( set - face - property face ' background color locale tag - set how - to - add ) ) ( defun face - background - pixmap ( face & optional locale tag - set exact - p ) \" Return the background pixmap of FACE in LOCALE , or nil if it is unspecified .", "label": "", "metadata": {}, "score": "67.29247"}
{"text": "( interactive ( face - interactive \" background \" ) ) ( set - face - property face ' background color locale tag - set how - to - add ) ) ( defun face - background - pixmap ( face & optional locale tag - set exact - p ) \" Return the background pixmap of FACE in LOCALE , or nil if it is unspecified .", "label": "", "metadata": {}, "score": "67.29247"}
{"text": "This may be extended as more types are added .The symbol space rif : iri is intended to be used in a way similar to RDF resources .The . domain . value . space .of the symbol space rif : iri can be any set and no a priori equalities among the members of the type rif : iri are assumed .", "label": "", "metadata": {}, "score": "67.50157"}
{"text": "These two components will be explained in Section Model Theory for RIF 's Basic Condition Language .We would like to point out , however , that symbol spaces in RIF include spaces , such as xsd : long , whose value space is fixed as well as spaces like rif : iri and rif : local whose value spaces are not fixed .", "label": "", "metadata": {}, "score": "67.51851"}
{"text": "Frame instance representing the currently executing stack frame .Breakpoint handler method calls are cross - compartment , intra - thread calls : the call takes place in the same thread that hit the breakpoint , and in the compartment containing the handler function ( typically the debugger 's compartment ) .", "label": "", "metadata": {}, "score": "67.55084"}
{"text": "Add the global object designated by global to the set of global objects this Debugger instance is debugging .Return this Debugger 's Debugger .Object instance referring to global 's referent .The global designated by global must be in a different compartment than this Debugger instance itself .", "label": "", "metadata": {}, "score": "67.62497"}
{"text": "Given a Debugger .Object instance d and an object o , the call d.makeDebuggeeValue(o ) returns a Debugger .Object instance that presents o as it would be seen by code in d 's compartment .If the referent is a function that is debuggee code , return the JavaScript source code for a function definition equivalent to the referent function in its effect and result , as a string .", "label": "", "metadata": {}, "score": "67.83298"}
{"text": "t ) ( [ italic ] .[ default ] ) ( [ bold - italic ] .[ bold ] ) ) ) ) ; ; Why do the following two functions lose so badly in so many ; ; circumstances ?", "label": "", "metadata": {}, "score": "67.97494"}
{"text": "t ) ( [ italic ] .[ default ] ) ( [ bold - italic ] .[ bold ] ) ) ) ) ; ; Why do the following two functions lose so badly in so many ; ; circumstances ?", "label": "", "metadata": {}, "score": "67.97494"}
{"text": "Presentation .EBNF Syntax , as between ' ? ' and VARNAME in ' ? 'VARNAME , there must be no whitespace character in the defined language .Constant symbols can have two forms : CONSTNAME and \" CONSTNAME\"^^TYPENAME .The second form is more general .", "label": "", "metadata": {}, "score": "68.00725"}
{"text": "In contrast , \" abc\"^^xsd : long is ill - formed , as it does not have a correct lexical form .A compliant RIF interpreter must reject such symbols .Symbols with undefined symbol spaces .RIF allows symbols of the form \" ... \" ^^label where label is not one of the previously defined standard symbol spaces ( such as xsd : long , rif : local , etc . ) .", "label": "", "metadata": {}, "score": "68.03354"}
{"text": "( Note that Debugger .Object instances referring to functions also have a decompile method , whose result includes the function header and parameter names , so it is probably better to write f.decompile ( ) than to write f.getFunctionScript ( ) .", "label": "", "metadata": {}, "score": "68.228676"}
{"text": "Complex terms ( defined below ) are not symbols and so they can have signatures only as terms .A term t ( t 1 ... t n ) is a well - formed term with signature \u03c3 iff .t is a well - formed term with signature \u03c3 0 ; .", "label": "", "metadata": {}, "score": "68.289734"}
{"text": "Environment instance representing the referent as a variable environment for evaluating code .If the referent is not a global object , throw a TypeError .Set a watchpoint on all the referent 's own properties , reporting events by calling handler 's methods .", "label": "", "metadata": {}, "score": "68.39044"}
{"text": "If LOCALE is a locale , only specs in that locale will be returned .If LOCALE is a locale type , all specs in all locales of that type will be returned .If LOCALE is nil , all specs will be returned .", "label": "", "metadata": {}, "score": "68.6509"}
{"text": "Production1 ... ?ProductionN , ?Production1 , ?TokenTable ) ... abs2con4 g ( ?ProductionN , ?TokenTable ) abs2con4 g ( ? RightExpression , ? RightExpression , ?( ' CONSTNAME ' ) ' , ?TokenTable)TYPENAME ) ?", "label": "", "metadata": {}, "score": "68.77221"}
{"text": "Example : \" 123\"^^xsd : long .Long integers also have a short notation , which does not require the \" ... \" ^^xsd : long wrapper . quotes . and .the . type . label .^^xsd : long . can . be . omitted .", "label": "", "metadata": {}, "score": "68.88733"}
{"text": "( let ( ( init - face - from - resources nil ) ) ( make - face name doc - string temporary ) ) ) ( defun init - face - from - resources ( face & optional locale ) \" Initialize FACE from the resource database .", "label": "", "metadata": {}, "score": "68.92613"}
{"text": "( let ( ( init - face - from - resources nil ) ) ( make - face name doc - string temporary ) ) ) ( defun init - face - from - resources ( face & optional locale ) \" Initialize FACE from the resource database .", "label": "", "metadata": {}, "score": "68.92613"}
{"text": "Your event handling methods run in the compartment to which they belong , typically the debugger 's compartment .The compartment system mediates the debugger 's and debuggee 's access to each other 's objects .The Debugger interface does not itself support cross - thread or multi - threaded debugging .", "label": "", "metadata": {}, "score": "69.30282"}
{"text": "A C++ local thin - pointer points at storage for the Fat Pointer holding the variable 's value .We need not consider BoxedLocals declared \" : final \" , as final local variable usage will always be FastLocal usage .C++ .", "label": "", "metadata": {}, "score": "69.31644"}
{"text": "The same symbol space is allowed to have more than one identifier ( but different symbol spaces can not share an identifier ) .To simplify the language , this document will often use symbol space identifiers to refer to the actual symbol spaces ( for instance , we may say \" symbol space xsd : string \" instead of \" symbol space identified by xsd : string \") .", "label": "", "metadata": {}, "score": "69.50434"}
{"text": "( init - other - random - faces device ) ) ) ( defun init - frame - faces ( frame ) ( when init - face - from - resources ; ; First , add any frame - local face resources .", "label": "", "metadata": {}, "score": "69.5084"}
{"text": "( init - other - random - faces device ) ) ) ( defun init - frame - faces ( frame ) ( when init - face - from - resources ; ; First , add any frame - local face resources .", "label": "", "metadata": {}, "score": "69.5084"}
{"text": "Environment instances as needed as the debugger inspects stack frames and function objects ; calling Debugger .Environment as a function or constructor raises a TypeError exception .( If more than one Debugger instance is debugging the same code , each Debugger gets a separate Debugger .", "label": "", "metadata": {}, "score": "69.53621"}
{"text": "This happens very early , before creating ; ; the first non - stream device .( set - face - background ' text - cursor ' ( ( ( x default ) .\" Red3 \" ) ( ( mswindows default ) .", "label": "", "metadata": {}, "score": "69.587524"}
{"text": "This happens very early , before creating ; ; the first non - stream device .( set - face - background ' text - cursor ' ( ( ( x default ) .\" Red3 \" ) ( ( mswindows default ) .", "label": "", "metadata": {}, "score": "69.587524"}
{"text": "If \u03ba above is atomic then the signature is called a Boolean expression .A set S of signatures is coherent iff .S has at most one signature for any given signature name .Here \u03b7 S denotes a signature with the name \u03b7 and the associated set of arrow expression S ; similarly \u03ba R is a signature named \u03ba with the set of expressions R .", "label": "", "metadata": {}, "score": "69.606"}
{"text": "( An alternative design here would be : onException(status , frame , value ) where status is one of the strings \" throw \" , \" unwind \" , \" catch \" , \" finally \" , \" rethrow \" .JS_SaveExceptionState would trigger a \" finally \" event , JS_RestoreExceptionState would trigger a \" rethrow \" , JS_ClearPendingException would trigger a \" catch \" ; not sure what JS_DropExceptionState or a return / throw from a finally block should do . ) ' '", "label": "", "metadata": {}, "score": "69.692276"}
{"text": "need .requires .us .These sets of symbols are described in more detail later . subclass Var property name : VARNAME subclass Uniterm .The length of the list of Var of the declare property ( role ) of the Exists class is assumed to be 1 or more .", "label": "", "metadata": {}, "score": "69.74721"}
{"text": "For instance , 1.2^^xsd : decimal and 1.20^^xsd : decimal are two legal constants in RIF because 1.2 and 1.20 belong to the lexical space of xsd : decimal .However , these two constants are interpreted by the same element of the value space of the xsd : decimal type .", "label": "", "metadata": {}, "score": "69.7477"}
{"text": "I enjoyed his lectures but was really too star struck to take advantage of the opportunity .But I saw enough of him to understand why he is remembered with deep affection and admiration by all of his colleagues and students whose ranks form a veritable who 's who of linguists to pay attention to .", "label": "", "metadata": {}, "score": "69.787865"}
{"text": "I only started studying linguistics in 1991 which is when Case for Case was already considered a classic .Particularly in Prague where function was so important .But even after all those years , it is still worth reading for any minimalist out there .", "label": "", "metadata": {}, "score": "69.97609"}
{"text": "Frame instance 's onPop handler method , if present , passing a yield resumption value ; however , the Debugger .Frame instance remains live .If multiple Debugger instances each have Debugger .Frame instances for a given stack frame with onPop handlers set , their handlers are run in an unspecified order .", "label": "", "metadata": {}, "score": "70.06818"}
{"text": "Equality terms .Classification terms .There are two kinds of classification terms : class membership terms ( or just membership terms ) and subclass terms .t#s is a membership term if t and s are arbitrary terms .t##s is a subclass term if t and s are arbitrary terms .", "label": "", "metadata": {}, "score": "70.53136"}
{"text": "Frame instances . )Invoke the debuggee code as appropriate for the given invocation function , with the \" debugger \" frame as its continuation .For example , Debugger .Frame.prototype.eval pushes an \" eval \" frame for code it runs , whereas Debugger .", "label": "", "metadata": {}, "score": "70.569855"}
{"text": "George Lakoff used it as one of the key inspirations to his idealized cognitive models in Women , Fire , and Dangerous things which is where this site can trace its roots .As I have said before , I essentially think about metaphors as a special kinds of frames .", "label": "", "metadata": {}, "score": "70.653564"}
{"text": "; ; You should have received a copy of the GNU General Public License ; ; along with XEmacs ; see the file COPYING .If not , write to the ; ; Free Software Foundation , Inc. , 59 Temple Place - Suite 330 , ; ; Boston , MA 02111 - 1307 , USA . ; ; ; Synched up with : Not synched with FSF .", "label": "", "metadata": {}, "score": "70.74053"}
{"text": "If the referent is a proxy whose handler object was allocated by debuggee code , this is its handler object \u2014 the object whose methods are invoked to implement accesses of the proxy 's properties .If the referent is not a proxy whose handler object was allocated by debuggee code , this is null .", "label": "", "metadata": {}, "score": "70.953926"}
{"text": "\" paleturquoise \" ) ( ( mswindows default color ) .\" green \" ) ) ' global ) ; ; Define some logical color names to be used when reading the pixmap files .; ; XEmacs is distributed in the hope that it will be useful , but ; ; WITHOUT ANY WARRANTY ; without even the implied warranty of ; ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE .", "label": "", "metadata": {}, "score": "71.01525"}
{"text": "So there seem to be both ecumenical and hegemonic sentiments in the air .For my part , I 'd like to cast my vote for another unitary candidate ( if only in the hope of keeping problem numbers tractable ) , one that might likewise subsume many of the rest as special cases .", "label": "", "metadata": {}, "score": "71.026596"}
{"text": "( let ( ( sp ( face - property face property ) ) ) ( if ( valid - specifier - domain - p locale ) ; ; this is easy .Otherwise , something like ; ; ( make - face - larger ' modeline ) ; ; wo n't do anything at all if the modeline simply ; ; inherits its font from ' default .", "label": "", "metadata": {}, "score": "71.09581"}
{"text": "( let ( ( sp ( face - property face property ) ) ) ( if ( valid - specifier - domain - p locale ) ; ; this is easy .Otherwise , something like ; ; ( make - face - larger ' modeline ) ; ; wo n't do anything at all if the modeline simply ; ; inherits its font from ' default .", "label": "", "metadata": {}, "score": "71.09581"}
{"text": "When a debugger calls an invocation function to run debuggee code , that code 's continuation is the debugger , not the next debuggee code frame .Pushing a \" debugger \" frame makes this continuation explicit , and makes it easier to find the extent of the stack created for the invocation .", "label": "", "metadata": {}, "score": "71.11134"}
{"text": "( not ( face - equal face ' default domain ) ) ) ; moved from x - faces . el ( defun try - font - name ( name & optional device ) ; ; yes , name really should be here twice .", "label": "", "metadata": {}, "score": "71.29813"}
{"text": "( not ( face - equal face ' default domain ) ) ) ; moved from x - faces . el ( defun try - font - name ( name & optional device ) ; ; yes , name really should be here twice .", "label": "", "metadata": {}, "score": "71.29813"}
{"text": "Classical negation : If \u03c6 is a well - formed formula then Neg \u03c6 is a well - formed formula .Default negation : If \u03c6 is a well - formed formula then Naf \u03c6 is a well - formed formula .", "label": "", "metadata": {}, "score": "71.319336"}
{"text": "The Debugger interface constructs Debugger .Script objects as scripts of debuggee code are uncovered by the debugger : via the onNewScript handler method ; via Debugger .Frame 's script properties ; via the functionScript method of Debugger .Object instances ; and so on .", "label": "", "metadata": {}, "score": "71.343605"}
{"text": "For other methods , if their normal operation would cause debuggee code to run , they throw an instance of the Debugger .DebuggeeWouldRun exception .A Debugger .DebuggeeWouldRun exception may have a cause property , providing more detailed information on why the debuggee would have run .", "label": "", "metadata": {}, "score": "71.34806"}
{"text": "data . datatype .xsd : decimal .On the other hand , \" a+2\"^^xsd : decimal is not a legal symbol , since a+2 is not part of the lexical space of the XML .data . datatype .xsd : decimal .", "label": "", "metadata": {}, "score": "71.46916"}
{"text": "FastLocals .A C++ local Fat Pointer variable is used to hold the value of the variable . name .name .# not applicable .//not applicable .& name .//not applicable -- would be Boxed . new FinalSlot ( name ) .", "label": "", "metadata": {}, "score": "71.60462"}
{"text": "An invocation function is any function in this interface that allows the debugger to invoke code in the debuggee : Debugger .Object.prototype.call , Debugger .Frame.prototype.eval , and so on .Let older be the youngest visible frame on the stack , or null if there is no such frame .", "label": "", "metadata": {}, "score": "71.83579"}
{"text": "So signal ; ; an error to indicate this . ; ; Otherwise map frob - face - property-1 over each device .( mapcar ( lambda ( arg ) ( when ( and arg ( not ( member arg new - result ) ) )", "label": "", "metadata": {}, "score": "71.88169"}
{"text": "So signal ; ; an error to indicate this . ; ; Otherwise map frob - face - property-1 over each device .( mapcar ( lambda ( arg ) ( when ( and arg ( not ( member arg new - result ) ) )", "label": "", "metadata": {}, "score": "71.88169"}
{"text": "these .IRIs . will . be . used . as . type . names .In . this .version of the RIF BLD document , we define the following symbol spaces , where the prefix xsd refers to the XML Schema URI and rif is the prefix for the RIF language .", "label": "", "metadata": {}, "score": "71.92058"}
{"text": "Debugger .Object instances protect their referents from the garbage collector ; as long as the Debugger .Object instance is live , the referent remains live .This means that garbage collection has no visible effect on Debugger .Object instances .", "label": "", "metadata": {}, "score": "71.97089"}
{"text": "Also , according to this definition the signature of a symbol can be different from the signature of the same symbol when it is viewed as a term .Furthermore , a symbol always has just one signature ( which might have many arrow expressions in it ) , but a term can have several signatures .", "label": "", "metadata": {}, "score": "71.981346"}
{"text": "See ' make - integer - specifier ' for a description of possible integer instantiators .See ' make - natnum - specifier ' for a description of possible natnum instantiators .EQ ( instantiator , Qt ) & & !See ' make - boolean - specifier ' for a description of possible boolean instantiators .", "label": "", "metadata": {}, "score": "72.17062"}
{"text": "We should use the custom mechanism for ; ; most of this stuff .Currently we do n't do it , because Custom ; ; does n't use specifiers ( yet . )FSF does it the Right Way . ; ; For instance , the definition of ' bold ' should be something like ; ; ( defface bold ( ( t ( : bold t ) ) ) \" Bold text . \" ) -- and ' : bold t ' should ; ; make sure that everything works properly .", "label": "", "metadata": {}, "score": "72.29562"}
{"text": "We should use the custom mechanism for ; ; most of this stuff .Currently we do n't do it , because Custom ; ; does n't use specifiers ( yet . )FSF does it the Right Way . ; ; For instance , the definition of ' bold ' should be something like ; ; ( defface bold ( ( t ( : bold t ) ) ) \" Bold text . \" ) -- and ' : bold t ' should ; ; make sure that everything works properly .", "label": "", "metadata": {}, "score": "72.29562"}
{"text": "If the referent is not callable , throw a TypeError .Code is a string .All extant handler methods , breakpoints , watchpoints , and so on remain active during the call .If the referent is not a global object , throw a TypeError exception .", "label": "", "metadata": {}, "score": "72.306366"}
{"text": "For windows , however , it 's trickier because dead objects can be converted to live ones again if the dead object is in a window configuration .Therefore , for windows , \" no longer in use \" corresponds to when the window object is garbage - collected .", "label": "", "metadata": {}, "score": "72.52021"}
{"text": "Other documents may supersede this document .Please Comment By ASAP .Working Group participants please send comments as soon as possible , for a 30 October publication decision .Small changes may be made along the way .No Endorsement .", "label": "", "metadata": {}, "score": "72.64261"}
{"text": "Buyer ( purchase^^rif : local ( ?Buyer ?Seller book^^rif : local ( ?Author bks : LeRif^^rif : iri ) curr : USD^^rif : iri ( 49^^xsd : integer ) ) ?The first step in defining a model - theoretic semantics for a logic - based language is to define the notion of a semantic structure , also known as an interpretation .", "label": "", "metadata": {}, "score": "72.72266"}
{"text": "Fillmore was more than a linguist 's linguist , he was a linguist who mattered ( and matters ) to anyone who wanted ( and wants ) to understand how language works beyond a few minimalist soundbites .Sadly it is possible to meet graduates with linguistics degrees who never heard of Jakobson or Fillmore .", "label": "", "metadata": {}, "score": "72.83469"}
{"text": "( face - property face ' doc - string ) ) ( defun set - face - doc - string ( face doc - string ) \" Change the documentation string of FACE to DOC - STRING . \"( interactive ( face - interactive \" doc - string \" ) ) ( set - face - property face ' doc - string doc - string ) ) ( defun face - font - name ( face & optional domain charset ) \" Return the font name of FACE in DOMAIN , or nil if it is unspecified .", "label": "", "metadata": {}, "score": "73.187904"}
{"text": "( face - property face ' doc - string ) ) ( defun set - face - doc - string ( face doc - string ) \" Change the documentation string of FACE to DOC - STRING . \"( interactive ( face - interactive \" doc - string \" ) ) ( set - face - property face ' doc - string doc - string ) ) ( defun face - font - name ( face & optional domain charset ) \" Return the font name of FACE in DOMAIN , or nil if it is unspecified .", "label": "", "metadata": {}, "score": "73.187904"}
{"text": "PIXMAP should be a string , the name of a file of pixmap data .The directories listed in the ' x - bitmap - file - path ' variable are searched .Alternatively , PIXMAP may be a list of the form ( WIDTH HEIGHT DATA ) where WIDTH and HEIGHT are the size in pixels , and DATA is a string , containing the raw bits of the bitmap .", "label": "", "metadata": {}, "score": "73.22002"}
{"text": "PIXMAP should be a string , the name of a file of pixmap data .The directories listed in the ' x - bitmap - file - path ' variable are searched .Alternatively , PIXMAP may be a list of the form ( WIDTH HEIGHT DATA ) where WIDTH and HEIGHT are the size in pixels , and DATA is a string , containing the raw bits of the bitmap .", "label": "", "metadata": {}, "score": "73.22002"}
{"text": "( + ( face - ascent face domain charset ) ( face - descent face domain charset ) ) ) ( defun face - proportional - p ( face & optional domain charset ) \" Return t if FACE is proportional in DOMAIN .", "label": "", "metadata": {}, "score": "73.49329"}
{"text": "( + ( face - ascent face domain charset ) ( face - descent face domain charset ) ) ) ( defun face - proportional - p ( face & optional domain charset ) \" Return t if FACE is proportional in DOMAIN .", "label": "", "metadata": {}, "score": "73.49329"}
{"text": "IS is a mapping from the RDF URI references in V into ( IR union IP ) , .LV is the set of literal values , which is a subset of IR , and includes all plain literals in V .", "label": "", "metadata": {}, "score": "73.550415"}
{"text": "The lexical - to - value mapping of rif : text , L rif : text , maps each symbol string@lang in the lexical space of rif : text to ( string , lower - case(lang ) ) , where lower - case(lang ) is lang written in all - lowercase letters .", "label": "", "metadata": {}, "score": "73.74544"}
{"text": "highlight Highlight all text covered by this face .Only used by faces on TTY devices .For valid instantiators , see ' face - boolean - specifier - p ' .dim Dim all text covered by this face .Only used by faces on TTY devices .", "label": "", "metadata": {}, "score": "74.085556"}
{"text": "highlight Highlight all text covered by this face .Only used by faces on TTY devices .For valid instantiators , see ' face - boolean - specifier - p ' .dim Dim all text covered by this face .Only used by faces on TTY devices .", "label": "", "metadata": {}, "score": "74.085556"}
{"text": "Grammatical constructions and linguistic generalizations : the What 's X doing Y ? construction .Language , 75(1 ) , pp.1 - 33 .Copyright ( C ) 1995 , 1996 Ben Wing .Copyright ( C ) 1995 Sun Microsystems , Inc.", "label": "", "metadata": {}, "score": "74.127106"}
{"text": "This is probably out of scope for this working group .Realistically speaking , RIF can define compatibility with OWL Full in the following ways : .Since OWL Full is an extension of RDF , the most straightforward way is to define the combination of RIF and OWL Full as an extension of the combination of RIF and RDF , i.e. based on correspondence of models .", "label": "", "metadata": {}, "score": "74.185196"}
{"text": "In order to specify OWL compatibility the working group needs to make a number of decisions , outlined below .OWL specifies three increasingly expressive species , namely Lite , DL , and Full .OWL Lite is a syntactic subset of DL , but the semantics is the same .", "label": "", "metadata": {}, "score": "74.340836"}
{"text": "Fremove_specifier ( ) always calls recompute_cached_specifier_everywhere ( ) ( # # # # but should be smarter about this ) .For all but windows , \" no longer in use \" corresponds exactly to when the object is deleted ( non - deleted objects are always held permanently in special lists , and deleted objects are never on these lists and never reusable ) .", "label": "", "metadata": {}, "score": "74.84561"}
{"text": "( face - complain - about - font ' bold - italic device ) ) ) ) ) ) ; ; Set the text - cursor colors unless already specified .( defun set - face - stipple ( face pixmap & optional frame ) \" Change the stipple pixmap of FACE to PIXMAP .", "label": "", "metadata": {}, "score": "74.97498"}
{"text": "( face - complain - about - font ' bold - italic device ) ) ) ) ) ) ; ; Set the text - cursor colors unless already specified .( defun set - face - stipple ( face pixmap & optional frame ) \" Change the stipple pixmap of FACE to PIXMAP .", "label": "", "metadata": {}, "score": "74.97498"}
{"text": "t ) ) ) ) ( defun make - face - bold - italic ( face & optional locale ) \" Make FACE bold and italic in LOCALE , if possible .This will attempt to make the font bold - italic for X locales and will set the highlight and underline flags for TTY locales .", "label": "", "metadata": {}, "score": "75.0529"}
{"text": "t ) ) ) ) ( defun make - face - bold - italic ( face & optional locale ) \" Make FACE bold and italic in LOCALE , if possible .This will attempt to make the font bold - italic for X locales and will set the highlight and underline flags for TTY locales .", "label": "", "metadata": {}, "score": "75.0529"}
{"text": "( defun init - device - faces ( device ) ; ; First , add any device - local face resources .( when init - face - from - resources ( loop for face in ( face - list ) do ( init - face - from - resources face device ) ) ; ; Then do any device - specific initialization .", "label": "", "metadata": {}, "score": "75.14932"}
{"text": "( defun init - device - faces ( device ) ; ; First , add any device - local face resources .( when init - face - from - resources ( loop for face in ( face - list ) do ( init - face - from - resources face device ) ) ; ; Then do any device - specific initialization .", "label": "", "metadata": {}, "score": "75.14932"}
{"text": "See the GNU ; ; General Public License for more details .; ; You should have received a copy of the GNU General Public License ; ; along with XEmacs ; see the file COPYING .If not , write to the ; ; Free Software Foundation , Inc. , 59 Temple Place - Suite 330 , ; ; Boston , MA 02111 - 1307 , USA . ; ; ; Synched up with : Not synched with FSF .", "label": "", "metadata": {}, "score": "75.19772"}
{"text": "blinking Blink all text covered by this face .Only used by faces on TTY devices .For valid instantiators , see ' face - boolean - specifier - p ' .reverse Reverse the foreground and background colors .Only used by faces on TTY devices .", "label": "", "metadata": {}, "score": "75.20521"}
{"text": "blinking Blink all text covered by this face .Only used by faces on TTY devices .For valid instantiators , see ' face - boolean - specifier - p ' .reverse Reverse the foreground and background colors .Only used by faces on TTY devices .", "label": "", "metadata": {}, "score": "75.20521"}
{"text": "Script instance .If the referent is a function proxy or not debuggee code , this is undefined .If the referent is a function that is debuggee code , a Debugger .Environment instance representing the lexical environment enclosing the function when it was created .", "label": "", "metadata": {}, "score": "75.49208"}
{"text": "There is no well - formed sentence in natural language ( including \" colorless green ideas sleep furiously \" ) that we can not \" gloss , \" as long as all its terms are grounded in thoughts that are about what the words are about .", "label": "", "metadata": {}, "score": "75.58356"}
{"text": "( interactive ( face - interactive \" background - pixmap \" ) ) ( set - face - property face ' background - pixmap pixmap locale tag - set how - to - add ) ) ( defun face - display - table ( face & optional locale tag - set exact - p ) \" Return the display table of FACE in LOCALE .", "label": "", "metadata": {}, "score": "75.6246"}
{"text": "( interactive ( face - interactive \" background - pixmap \" ) ) ( set - face - property face ' background - pixmap pixmap locale tag - set how - to - add ) ) ( defun face - display - table ( face & optional locale tag - set exact - p ) \" Return the display table of FACE in LOCALE .", "label": "", "metadata": {}, "score": "75.6246"}
{"text": "OWL Full and RDF have the same syntax .Note , however , that the RDF - compatible semantics of OWL DL is defined for arbitrary RDF graphs , not just OWL DL ontologies .The correspondence between URI references and literals in OWL and constant symbols in RIF can and should be defined in the same way as in RDF Compatibility .", "label": "", "metadata": {}, "score": "75.8851"}
{"text": "If you want to add code to do stuff like this , use the create - device - hook .\" ; ; try to make ' bold look different from the default on this device .; ; If that does n't work at all , then issue a warning . ; ; It 's unreasonable to expect to be able to make a font italic all ; ; the time .", "label": "", "metadata": {}, "score": "76.1859"}
{"text": "If you want to add code to do stuff like this , use the create - device - hook .\" ; ; try to make ' bold look different from the default on this device .; ; If that does n't work at all , then issue a warning . ; ; It 's unreasonable to expect to be able to make a font italic all ; ; the time .", "label": "", "metadata": {}, "score": "76.1859"}
{"text": "If the referent is not a function proxy whose handler object was allocated by debuggee code , this is null .If the referent is a function proxy whose handler object was allocated by debuggee code , its construction trap function \u2014 the function called when the function proxy is called via a new expression .", "label": "", "metadata": {}, "score": "76.2776"}
{"text": "remove - locale - typeRemove all specifications for all locales of the same type as LOCALE ( this includes LOCALE itself ) before adding the new spec . 'remove - allRemove all specifications from the specifier before adding the new spec .", "label": "", "metadata": {}, "score": "76.637314"}
{"text": "PSYCOLOQUY 3(60 ) frame - problem.2 .This interface is partly implemented in Firefox Nightly builds .Some parts are not implemented , some APIs may yet change , and anything marked \" ( future plan ) \" is a long way off .", "label": "", "metadata": {}, "score": "77.17964"}
{"text": "\" gray53 \" ) ) ' global ) ( set - face - background - pixmap ' highlight ' ( ( ( x default mono ) . \"gray1 \" ) ( ( mswindows default mono ) . \"gray1 \" ) ) ' global ) ( set - face - background ' zmacs - region ' ( ( ( x default color ) . \"", "label": "", "metadata": {}, "score": "77.2562"}
{"text": "\" gray53 \" ) ) ' global ) ( set - face - background - pixmap ' highlight ' ( ( ( x default mono ) . \"gray1 \" ) ( ( mswindows default mono ) . \"gray1 \" ) ) ' global ) ( set - face - background ' zmacs - region ' ( ( ( x default color ) . \"", "label": "", "metadata": {}, "score": "77.2562"}
{"text": "If it is a function , SpiderMonkey calls it when execution in this frame makes a small amount of progress , passing no arguments and providing this Debugger .Frame instance as the thisvalue .If multiple Debugger instances each have Debugger .", "label": "", "metadata": {}, "score": "77.35532"}
{"text": "Object.prototype.defineProperty , giving the newly added property 's attributes .The existing property named name on the referent is being changed from those given by oldDescriptor to those given by newDescriptor .This handler method is only called when attributes of the property other than its value are being changed ; if only the value is changing , SpiderMonkey calls the handler 's set method .", "label": "", "metadata": {}, "score": "77.63364"}
{"text": "^^xsd : decimal . can . be . omitted .Example : 123.45 .The type xsd : decimal is a supertype of xsd : long .xsd : string .This corresponds to the XML data type xsd : string .", "label": "", "metadata": {}, "score": "77.97691"}
{"text": "The debuggee will only resume execution when you return from the handler method that brought control to the debugger originally .SpiderMonkey supports generator - iterator objects , which produce a series of values by repeatedly suspending the execution of a function or expression .", "label": "", "metadata": {}, "score": "78.09894"}
{"text": "If implementation restrictions prevent SpiderMonkey from extending this frame 's environment as requested , this call throws an Error exception .Like eval , but evaluate code in the environment of this frame , extended with bindings from the object bindings .", "label": "", "metadata": {}, "score": "78.58628"}
{"text": "The section RIF - OWL Compatibility provides a number of starting points for compatibility with OWL .The section RIF - RDF Compatibility provides a concrete specification of RDF compatibility .In future versions , these two sections may be moved into a separate deliverable about RDF and OWL compatibility .", "label": "", "metadata": {}, "score": "78.60814"}
{"text": "[ italic ] ) ) ) ) ( defun make - face - unitalic ( face & optional locale ) \" Make FACE non - italic in LOCALE , if possible .This will attempt to make the font non - italic for X locales and will unset the underline flag for TTY locales .", "label": "", "metadata": {}, "score": "78.61639"}
{"text": "[ italic ] ) ) ) ) ( defun make - face - unitalic ( face & optional locale ) \" Make FACE non - italic in LOCALE , if possible .This will attempt to make the font non - italic for X locales and will unset the underline flag for TTY locales .", "label": "", "metadata": {}, "score": "78.61639"}
{"text": "In the next version of this document we will introduce a syntax for defining prefixes for compact URIs and will also expand on the syntax for the symbols that can be used to denote RIF 's primitive data types .xsd : long .", "label": "", "metadata": {}, "score": "78.8917"}
{"text": "In my post on why Chomsky is not really a linguist at all I listed a few .Sadly , one of these linguists died yesterday .It was Charles J Fillmore who was a towering figure among linguists without writing a single book .", "label": "", "metadata": {}, "score": "78.97368"}
{"text": "emacs files .( define - obsolete - variable - alias ' custom - background - mode ' frame - background - mode ) ( defun get - frame - background - mode ( frame ) \" Detect background mode for FRAME .", "label": "", "metadata": {}, "score": "79.35633"}
{"text": "emacs files .( define - obsolete - variable - alias ' custom - background - mode ' frame - background - mode ) ( defun get - frame - background - mode ( frame ) \" Detect background mode for FRAME .", "label": "", "metadata": {}, "score": "79.35633"}
{"text": "rif : iri ( for internationalized resource identifiers or IRI s ) .Constant symbols that belong to this symbol space are intended to be used in a way similar to RDF resources [ RDF - SCHEMA ] .The lexical space consists of all absolute IRIs as specified in [ RFC-3987 ] ; it is unrelated to the XML primitive type anyURI .", "label": "", "metadata": {}, "score": "79.5701"}
{"text": "If implementation restrictions prevent SpiderMonkey from extending this frame 's environment as requested , this call throws an Error exception .Note that this does not resume the debuggee 's execution ; it merely adjusts the debuggee 's state to what it would be if this frame 's execution had completed .", "label": "", "metadata": {}, "score": "79.849884"}
{"text": "The OWL semantics specification also defines an RDF - compatible semantics for OWL DL , but the direct semantics is normative .The OWL Full semantics does not directly extend the RDF - compatible OWL DL semantics ; however , every OWL DL entailment is an OWL Full entailment .", "label": "", "metadata": {}, "score": "79.91016"}
{"text": "; ; ; ; The default , modeline , left - margin , right - margin , text - cursor , ; ; and pointer faces are created in C. ( make - face ' bold \" Bold text . \" ) ( make - face ' italic \" Italic text . \" ) ( make - face ' bold - italic \" Bold - italic text . \" ) ( make - face ' underline \" Underlined text . \" ) ( or ( face - differs - from - default - p ' underline ) ( set - face - underline - p ' underline t ' global ' ( default ) ) ) ( make - face ' zmacs - region \" Used on highlightes region between point and mark . \" ) ( make - face ' isearch \" Used on region matched by isearch . \" ) ( make - face ' list - mode - item - selected \" Face for the selected list item in list - mode . \" ) ( make - face ' highlight \" Highlight face . \" ) ( make - face ' primary - selection \" Primary selection face . \" ) ( make - face ' secondary - selection \" Secondary selection face . \" ) ; ; Several useful color faces .", "label": "", "metadata": {}, "score": "80.858475"}
{"text": "; ; ; ; The default , modeline , left - margin , right - margin , text - cursor , ; ; and pointer faces are created in C. ( make - face ' bold \" Bold text . \" ) ( make - face ' italic \" Italic text . \" ) ( make - face ' bold - italic \" Bold - italic text . \" ) ( make - face ' underline \" Underlined text . \" ) ( or ( face - differs - from - default - p ' underline ) ( set - face - underline - p ' underline t ' global ' ( default ) ) ) ( make - face ' zmacs - region \" Used on highlightes region between point and mark . \" ) ( make - face ' isearch \" Used on region matched by isearch . \" ) ( make - face ' list - mode - item - selected \" Face for the selected list item in list - mode . \" ) ( make - face ' highlight \" Highlight face . \" ) ( make - face ' primary - selection \" Primary selection face . \" ) ( make - face ' secondary - selection \" Secondary selection face . \" ) ; ; Several useful color faces .", "label": "", "metadata": {}, "score": "80.858475"}
{"text": "See ' make - face - bold ' for the semantics of the LOCALE argument and for more specifics on exactly how this function works . \" t ) ( [ bold ] .[ default ] ) ( [ italic ] .", "label": "", "metadata": {}, "score": "80.883224"}
{"text": "See ' make - face - bold ' for the semantics of the LOCALE argument and for more specifics on exactly how this function works . \" t ) ( [ bold ] .[ default ] ) ( [ italic ] .", "label": "", "metadata": {}, "score": "80.883224"}
{"text": "gray1 \" ) ( ( mswindows default mono ) . \"gray1 \" ) ) ' global ) ( set - face - background ' isearch ' ( ( ( x default color ) .\" paleturquoise \" ) ( ( x default color ) .", "label": "", "metadata": {}, "score": "80.97306"}
{"text": "gray1 \" ) ( ( mswindows default mono ) . \"gray1 \" ) ) ' global ) ( set - face - background ' isearch ' ( ( ( x default color ) .\" paleturquoise \" ) ( ( x default color ) .", "label": "", "metadata": {}, "score": "80.97306"}
{"text": "-hniksic ; ; In a Solaris Japanese environment , there just are n't any italic ; ; fonts - period .So we first try to make the font bold before ; ; complaining .( unless ( face - differs - from - default - p ' bold - italic device ) ( make - face - bold - italic ' bold - italic device ) ; ; if we could n't get a bold - italic version , try just bold .", "label": "", "metadata": {}, "score": "81.424355"}
{"text": "-hniksic ; ; In a Solaris Japanese environment , there just are n't any italic ; ; fonts - period .So we first try to make the font bold before ; ; complaining .( unless ( face - differs - from - default - p ' bold - italic device ) ( make - face - bold - italic ' bold - italic device ) ; ; if we could n't get a bold - italic version , try just bold .", "label": "", "metadata": {}, "score": "81.424355"}
{"text": "For example , in Firefox , code in privileged compartments sees content DOM element objects without redefinitions or extensions made to that object 's properties by content code .( In Firefox terminology , privileged code sees the element through an \" xray wrapper \" . )", "label": "", "metadata": {}, "score": "81.4796"}
{"text": "See the GNU General Public License for more details .You should have received a copy of the GNU General Public License along with XEmacs ; see the file COPYING .If not , write to the Free Software Foundation , Inc. , 59 Temple Place - Suite 330 , Boston , MA 02111 - 1307 , USA .", "label": "", "metadata": {}, "score": "81.54417"}
{"text": "[ default background ] ) ( ( mswindows default mono ) .[ default background ] ) ) ' global ) ( set - face - background ' primary - selection ' ( ( ( x default color ) . \"gray65 \" ) ( ( x default grayscale ) . \"", "label": "", "metadata": {}, "score": "81.8445"}
{"text": "[ default background ] ) ( ( mswindows default mono ) .[ default background ] ) ) ' global ) ( set - face - background ' primary - selection ' ( ( ( x default color ) . \"gray65 \" ) ( ( x default grayscale ) . \"", "label": "", "metadata": {}, "score": "81.8445"}
{"text": "This will already be the case for RDF and RDFS entailment , because IP is required to be a subset of IR .However , in simple entailment IP is not required to be a subset of IR .Another possibility would be to additionally require IR to be a superset of D \\IP , although it is at this point is not entirely clear what this would buy us .", "label": "", "metadata": {}, "score": "82.93913"}
{"text": "XEmacs is free software ; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation ; either version 2 , or ( at your option ) any later version .", "label": "", "metadata": {}, "score": "83.72704"}
{"text": "; ; Basically , because italic is not a globally meaningful concept , ; ; the use of the italic face should really be oboleted .; ; I disagree with above .In many languages , the concept of capital ; ; letters is just as alien , and yet we use them .", "label": "", "metadata": {}, "score": "84.72116"}
{"text": "; ; Basically , because italic is not a globally meaningful concept , ; ; the use of the italic face should really be oboleted .; ; I disagree with above .In many languages , the concept of capital ; ; letters is just as alien , and yet we use them .", "label": "", "metadata": {}, "score": "84.72116"}
{"text": "\" [ italic ] ) ( [ bold ] .[ bold - italic ] ) ( [ italic ] .[ bold - italic ] ) ( [ bold - italic ] .t ) ) ) ) ( defun make - face - unbold ( face & optional locale ) \" Make FACE non - bold in LOCALE , if possible .", "label": "", "metadata": {}, "score": "85.222435"}
{"text": "\" [ italic ] ) ( [ bold ] .[ bold - italic ] ) ( [ italic ] .[ bold - italic ] ) ( [ bold - italic ] .t ) ) ) ) ( defun make - face - unbold ( face & optional locale ) \" Make FACE non - bold in LOCALE , if possible .", "label": "", "metadata": {}, "score": "85.222435"}
{"text": "Environment instance represents . )If implementation restrictions prevent SpiderMonkey from extending this environment as requested , this call throws an Error exception .Like eval , but evaluate code in this environment , extended with bindings from the object bindings .", "label": "", "metadata": {}, "score": "85.70827"}
{"text": "; ; ; Commentary : ; ; This file is dumped with XEmacs .; ; face implementation # 2 ( used one face object per frame per face ) ; ; authored by Jamie Zawinski for 19.9 .; ; ; Some stuff in FSF 's faces.el is in our x - faces .", "label": "", "metadata": {}, "score": "86.694885"}
{"text": "; ; ; Commentary : ; ; This file is dumped with XEmacs .; ; face implementation # 2 ( used one face object per frame per face ) ; ; authored by Jamie Zawinski for 19.9 .; ; ; Some stuff in FSF 's faces.el is in our x - faces .", "label": "", "metadata": {}, "score": "86.694885"}
{"text": "Script instance for a given script .This allows the code using each Debugger instance to place whatever properties it likes on its Debugger .Script instances , without worrying about interfering with other debuggers . )Note that SpiderMonkey may use the same Debugger .", "label": "", "metadata": {}, "score": "86.819565"}
{"text": "When SpiderMonkey calls an onPop handler for a frame that is throwing an exception or being terminated , and the handler returns undefined , then SpiderMonkey proceeds with the exception or termination .That is , an undefined resumption value leaves the frame 's throwing and termination process undisturbed .", "label": "", "metadata": {}, "score": "87.29671"}
{"text": "xsd : dateTime .This type corresponds to the XML data type xsd : dateTime .Example : \" 2007 - 03 - 12T21:22:33.44 - 01:30\"^^xsd : dateTime .rif : iri .Symbols in this symbol space have the form \" XYZ\"^^rif : iri , where XYZ is an absolute IRI as specified in RFC 3987 .", "label": "", "metadata": {}, "score": "87.30139"}
{"text": "xsd : decimal .This corresponds to the XML data type xsd : decimal .Example : \" 123.45\"^^xsd : decimal .Decimals also have an alternative short notation , which does not require the \" ... \" ^^xsd : decimal wrapper . and .", "label": "", "metadata": {}, "score": "89.23039"}
{"text": "If uncaughtExceptionHook 's value is null , SpiderMonkey throws an exception to the debuggee whose message blames the debugger , and includes a textual description of debugger - exception .( This is not an ideal way to handle debugger bugs , but the hope here is that some sort of backstop , even if imperfect , will make life easier for debugger developers .", "label": "", "metadata": {}, "score": "90.22494"}
{"text": "\" green \" ) ( ( x default grayscale ) .\" gray53 \" ) ( ( mswindows default color ) .\" paleturquoise \" ) ( ( mswindows default color ) .\" green \" ) ( ( mswindows default grayscale ) .", "label": "", "metadata": {}, "score": "90.544426"}
{"text": "\" green \" ) ( ( x default grayscale ) .\" gray53 \" ) ( ( mswindows default color ) .\" paleturquoise \" ) ( ( mswindows default color ) .\" green \" ) ( ( mswindows default grayscale ) .", "label": "", "metadata": {}, "score": "90.544426"}
{"text": "gray65 \" ) ( ( mswindows default color ) . \"gray65 \" ) ( ( mswindows default grayscale ) . \"gray65 \" ) ) ' global ) ( set - face - background - pixmap ' zmacs - region ' ( ( ( x default mono ) . \" gray3 \" ) ( ( mswindows default mono ) . \" gray3 \" ) ) ' global ) ( set - face - background ' list - mode - item - selected ' ( ( ( x default color ) .", "label": "", "metadata": {}, "score": "90.77132"}
{"text": "gray65 \" ) ( ( mswindows default color ) . \"gray65 \" ) ( ( mswindows default grayscale ) . \"gray65 \" ) ) ' global ) ( set - face - background - pixmap ' zmacs - region ' ( ( ( x default mono ) . \" gray3 \" ) ( ( mswindows default mono ) . \" gray3 \" ) ) ' global ) ( set - face - background ' list - mode - item - selected ' ( ( ( x default color ) .", "label": "", "metadata": {}, "score": "90.77132"}
{"text": "gray65 \" ) ( ( mswindows default grayscale ) . \"gray65 \" ) ) ' global ) ( set - face - background - pixmap ' primary - selection ' ( ( ( x default mono ) . \" gray3 \" ) ( ( mswindows default mono ) . \" gray3 \" ) ) ' global ) ( set - face - background ' secondary - selection ' ( ( ( x default color ) .", "label": "", "metadata": {}, "score": "90.988205"}
{"text": "gray65 \" ) ( ( mswindows default grayscale ) . \"gray65 \" ) ) ' global ) ( set - face - background - pixmap ' primary - selection ' ( ( ( x default mono ) . \" gray3 \" ) ( ( mswindows default mono ) . \" gray3 \" ) ) ' global ) ( set - face - background ' secondary - selection ' ( ( ( x default color ) .", "label": "", "metadata": {}, "score": "90.988205"}
{"text": "\" [ bold ] ) ( [ bold ] .t ) ( [ italic ] .[ bold - italic ] ) ( [ bold - italic ] .t ) ) ) ) ( defun make - face - italic ( face & optional locale ) \" Make FACE italic in LOCALE , if possible .", "label": "", "metadata": {}, "score": "91.29539"}
{"text": "\" [ bold ] ) ( [ bold ] .t ) ( [ italic ] .[ bold - italic ] ) ( [ bold - italic ] .t ) ) ) ) ( defun make - face - italic ( face & optional locale ) \" Make FACE italic in LOCALE , if possible .", "label": "", "metadata": {}, "score": "91.29539"}
{"text": "See ' make - face - bold ' for the semantics of the LOCALE argument and for more specifics on exactly how this function works .\" [ italic ] ) ( [ bold ] .[ bold - italic ] ) ( [ italic ] .", "label": "", "metadata": {}, "score": "91.84761"}
{"text": "See ' make - face - bold ' for the semantics of the LOCALE argument and for more specifics on exactly how this function works .\" [ italic ] ) ( [ bold ] .[ bold - italic ] ) ( [ italic ] .", "label": "", "metadata": {}, "score": "91.84761"}
{"text": "Need to ; ; separate out the font elements as separate face properties ! ; ; WE DEMAND LEXICAL SCOPING ! ! ! ; ; WE DEMAND LEXICAL SCOPING ! ! ! ; ; WE DEMAND LEXICAL SCOPING ! ! ! ; ; WE DEMAND LEXICAL SCOPING ! ! ! ; ; WE DEMAND LEXICAL SCOPING ! ! ! ; ; WE DEMAND LEXICAL SCOPING ! ! ! ; ; WE DEMAND LEXICAL SCOPING ! ! ! ; ; WE DEMAND LEXICAL SCOPING ! ! ! ; ; WE DEMAND LEXICAL SCOPING ! ! ! ; ; WE DEMAND LEXICAL SCOPING ! ! ! ; ; WE DEMAND LEXICAL SCOPING ! ! ! ; ; WE DEMAND LEXICAL SCOPING ! ! ! ; ; WE DEMAND LEXICAL SCOPING ! ! ! ; ; WE DEMAND LEXICAL SCOPING ! ! ! ; ; WE DEMAND LEXICAL SCOPING ! ! !", "label": "", "metadata": {}, "score": "92.947754"}
{"text": "Need to ; ; separate out the font elements as separate face properties ! ; ; WE DEMAND LEXICAL SCOPING ! ! ! ; ; WE DEMAND LEXICAL SCOPING ! ! ! ; ; WE DEMAND LEXICAL SCOPING ! ! ! ; ; WE DEMAND LEXICAL SCOPING ! ! ! ; ; WE DEMAND LEXICAL SCOPING ! ! ! ; ; WE DEMAND LEXICAL SCOPING ! ! ! ; ; WE DEMAND LEXICAL SCOPING ! ! ! ; ; WE DEMAND LEXICAL SCOPING ! ! ! ; ; WE DEMAND LEXICAL SCOPING ! ! ! ; ; WE DEMAND LEXICAL SCOPING ! ! ! ; ; WE DEMAND LEXICAL SCOPING ! ! ! ; ; WE DEMAND LEXICAL SCOPING ! ! ! ; ; WE DEMAND LEXICAL SCOPING ! ! ! ; ; WE DEMAND LEXICAL SCOPING ! ! ! ; ; WE DEMAND LEXICAL SCOPING ! ! !", "label": "", "metadata": {}, "score": "92.947754"}
{"text": "Then flight ( NewYork Boston ) , closure ( flight ) ( NewYork Boston ) , parent ( John Mary ) , and closure ( parent ) ( John Mary ) would be well - formed formulas .Such formulas are allowed in languages like HiLog , which support predicate constructors like closure in the above example .", "label": "", "metadata": {}, "score": "93.35596"}
{"text": "Then flight(NewYork Boston ) , closure(flight)(NewYork Boston ) , parent(John Mary ) , and closure(parent)(John Mary ) would be well - formed formulas .Such formulas are allowed in languages like HiLog [ CKW93 ] , which support predicate constructors like closure in the above example .", "label": "", "metadata": {}, "score": "94.54506"}
{"text": "( unless ( face - differs - from - default - p ' bold - italic device ) ( make - face - unbold ' bold - italic device ) ( make - face - italic ' bold - italic device ) ( unless ( face - differs - from - default - p ' bold - italic device ) ; ; if that did n't work , try plain italic ; ; ( can this ever happen ? what the hell . )", "label": "", "metadata": {}, "score": "98.04983"}
{"text": "( unless ( face - differs - from - default - p ' bold - italic device ) ( make - face - unbold ' bold - italic device ) ( make - face - italic ' bold - italic device ) ( unless ( face - differs - from - default - p ' bold - italic device ) ; ; if that did n't work , try plain italic ; ; ( can this ever happen ? what the hell . )", "label": "", "metadata": {}, "score": "98.04983"}
{"text": "\" gray68 \" ) ( ( x default mono ) .[ default foreground ] ) ( ( mswindows default color ) .\" gray68 \" ) ( ( mswindows default grayscale ) .\" gray68 \" ) ( ( mswindows default mono ) .", "label": "", "metadata": {}, "score": "98.35417"}
{"text": "\" gray68 \" ) ( ( x default mono ) .[ default foreground ] ) ( ( mswindows default color ) .\" gray68 \" ) ( ( mswindows default grayscale ) .\" gray68 \" ) ( ( mswindows default mono ) .", "label": "", "metadata": {}, "score": "98.35417"}
{"text": "\" darkseagreen2 \" ) ( ( x default color ) .\" green \" ) ( ( x default grayscale ) .\" gray53 \" ) ( ( mswindows default color ) .\" darkseagreen2 \" ) ( ( mswindows default color ) .", "label": "", "metadata": {}, "score": "102.28815"}
{"text": "\" darkseagreen2 \" ) ( ( x default color ) .\" green \" ) ( ( x default grayscale ) .\" gray53 \" ) ( ( mswindows default color ) .\" darkseagreen2 \" ) ( ( mswindows default color ) .", "label": "", "metadata": {}, "score": "102.28815"}
{"text": "Either null or a function that SpiderMonkey calls when a call to a debug event handler , breakpoint handler , watchpoint handler , or similar function throws some exception , debugger - exception .Exceptions thrown in the debugger are not propagated to debuggee code ; instead , SpiderMonkey calls this function , passing debugger - exception as its sole argument and the Debugger instance as the this value .", "label": "", "metadata": {}, "score": "104.235794"}
{"text": "C++ . name : slotMakerExpr .call(&DoMakeSlot , specimen ) ; //check for null Outers.call(&DoDefineSlot , Ref ( \" name \") , initSlot ) ; .Unless stated otherwise , all text on this page which is either unattributed or by Mark S. Miller is hereby placed in the public domain .", "label": "", "metadata": {}, "score": "105.107086"}
