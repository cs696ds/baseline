{"text": "We show that the automatically induced latent variable grammars of Petrov et al .2006 vary widely in their underlying representations , depending on their EM initialization point .We use this to our advantage , combining multiple automatically learned grammars into an unweighted product model , which gives significantly improved performance over state - of - the - art individual grammars .", "label": "", "metadata": {}, "score": "34.16746"}
{"text": "In addition , our discriminative approach integrally admits features beyond local tree configurations .We present a multi - scale training method along with an efficient CKY - style dynamic program .On a variety of domains and languages , this method produces the best published parsing accuracies with the smallest reported grammars .", "label": "", "metadata": {}, "score": "37.18965"}
{"text": "Yet what is striking about these results is both the relative infrequency of constructions which demonstrate this complexity and the increase in computational power required to account for them .For example , the constructions which are necessarily at least context - free ( such as center embedding ) seem fairly uncommon in comparison with constructions which could be fairly characterized as finite state ; the constructions which are necessarily trans - context - free are even fewer .", "label": "", "metadata": {}, "score": "37.32455"}
{"text": "Steven Sam Feb 26 ' 10 at 7:48 .Yes , these are studied .For 1 : Just as a every groupoid can be decomposed up to natural equivalence as a collection of components with one isomorphism class of group per component , a representation of same is equivalent to one representation per component .", "label": "", "metadata": {}, "score": "38.067963"}
{"text": "First , we present a novel coarse - to - fine method in which a grammar 's own hierarchical projections are used for incremental pruning , including a method for efficiently computing projections of a grammar without a treebank .In our experiments , hierarchical pruning greatly accelerates parsing with no loss in empirical accuracy .", "label": "", "metadata": {}, "score": "38.923145"}
{"text": "In this case , we can not only take advance of generic XML knowledge but also of knowledge that is specific to the type of documents being encoded .The following two sections describe the differences between the built - in grammars and the schema - informed grammars .", "label": "", "metadata": {}, "score": "39.442177"}
{"text": "Nonetheless , the resulting grammars encode many linguistically interpretable patterns and give the best published parsing accuracies on three German treebanks .We demonstrate that log - linear grammars with latent variables can be practically trained using discriminative methods .Central to efficient discriminative training is a hierarchical pruning procedure which allows feature expectations to be efficiently approximated in a gradient - based procedure .", "label": "", "metadata": {}, "score": "40.683445"}
{"text": "It also becomes a subtle issue as to what exactly a representation is supposed to be . -Chris Schommer - Pries Feb 26 ' 10 at 18:03 .For example in topological case any space is a groupoid ( with just identity morphisms ) .", "label": "", "metadata": {}, "score": "40.69609"}
{"text": "But I feel like it might be helpful to think of representation of groupoids for the following reasons : .When one talk about local systems , thinking of it as \" representation of the fundamental groupoid \" seems more natural than talking about \" representation of the fundamental group \" .", "label": "", "metadata": {}, "score": "40.7678"}
{"text": "Finally , note that I am talking about describing the language fully .That is not to say that under certain conditions a regular expression can not describe a subset of a natural language nor that regular expressions can not approximate a natural language in limited contexts .", "label": "", "metadata": {}, "score": "40.902016"}
{"text": "In particular , we introduce set - valued features to encode the predicted morphological properties and part - of - speech confusion sets of the words being parsed .We also investigate the use of joint parsing and part - of - speech tagging in the neural paradigm .", "label": "", "metadata": {}, "score": "41.158813"}
{"text": "We highlight the use of this resource via two experiments , including one that reports competitive accuracies for unsupervised grammar induction without gold standard part - of - speech tags .We present an online learning algorithm for training structured prediction models with extrinsic loss functions .", "label": "", "metadata": {}, "score": "41.455017"}
{"text": "Any comments on this fact ? -Marek Mitros Jun 29 ' 12 at 20:43 .A finite group representation is always unitary , and you can construct the corresponding invariant form ; this amounts to some linear algebra .Whether it is orthogonal , is completely determined by its character .", "label": "", "metadata": {}, "score": "41.563103"}
{"text": "Starting from a mono - phone model , we learn increasingly refined models that capture phone internal structures , as well as context - dependent variations in an automatic way .Our approaches reduces error rates compared to other baseline approaches , while streamlining the learning procedure .", "label": "", "metadata": {}, "score": "41.718536"}
{"text": "Our method does not assume any knowledge about the target language ( in particular no tagging dictionary is assumed ) , making it applicable to a wide array of resource - poor languages .We use graph - based label propagation for cross - lingual knowledge transfer and use the projected labels as features in an unsupervised model ( Berg - Kirkpatrick et al .", "label": "", "metadata": {}, "score": "41.723026"}
{"text": "To achieve these results we need to mitigate the lack of domain knowledge in the model by providing it with a large amount of automatically parsed data .We extend and improve upon recent work in structured training for neural network transition - based dependency parsing .", "label": "", "metadata": {}, "score": "41.994095"}
{"text": "Second , how can we efficiently infer optimal structures within them ?Hierarchical coarse - to - fine methods address both questions .Coarse - to - fine approaches exploit a sequence of models which introduce complexity gradually .At the top of the sequence is a trivial model in which learning and inference are both cheap .", "label": "", "metadata": {}, "score": "42.67833"}
{"text": "Finally , we present multilingual experiments which show that parsing with hierarchical state - splitting is fast and accurate in multiple languages and domains , even without any language - specific tuning .This work describes systems for detecting semantic categories present in news video .", "label": "", "metadata": {}, "score": "43.272606"}
{"text": "A mixture grammar fit with the EM algorithm shows improvement over a single PCFG , both in parsing accuracy and in test data likelihood .We argue that this improvement comes from the learning of specialized grammars that capture non - local correlations .", "label": "", "metadata": {}, "score": "43.90013"}
{"text": "For example , noun phrases might be split into subcategories for subjects and objects , singular and plural , and so on .This splitting process admits an efficient incremental inference scheme which reduces parsing times by orders of magnitude .Furthermore , it produces the best parsing accuracies across an array of languages , in a fully language - general fashion .", "label": "", "metadata": {}, "score": "44.03797"}
{"text": "We present an automatic approach to tree annotation in which basic nonterminal symbols are alternately split and merged to maximize the likelihood of a training treebank .Starting with a simple Xbar grammar , we learn a new grammar whose nonterminals are subsymbols of the original nonterminals .", "label": "", "metadata": {}, "score": "44.319237"}
{"text": "In practice , however , it is not the intent of this specification to require conforming implementations to adopt exotic or inefficient numeric representations for handling arbitrarily large EXI documents and grammars on specific platforms .XML Media Types , M. Murata , S. St .", "label": "", "metadata": {}, "score": "44.45948"}
{"text": "I will be using regular expressions , regular languages , and finite state automatas interchangeably .While this is not strictly true , it is sufficient for the scope of this answer .See here for more information .It is much easier to prove a language is not regular .", "label": "", "metadata": {}, "score": "44.66416"}
{"text": "Hopefully someone who knows the literature better than I can say more .Groupo\u00efds do n't add much in theory but they do make some statements much simpler and they are sometimes necessary to get some intuition .A typical example is the Van Kampen theorem .", "label": "", "metadata": {}, "score": "44.991383"}
{"text": "We present experiments with sequence models on part - of - speech tagging and named entity recognition tasks , and with syntactic parsers on dependency parsing and machine translation reordering tasks .Low - latency solutions for syntactic parsing are needed if parsing is to become an integral part of user - facing natural language applications .", "label": "", "metadata": {}, "score": "45.087494"}
{"text": "We also show that our techniques can be applied to full - scale parsing applications by demonstrating its effectiveness in learning state - split grammars .Treebank parsing can be seen as the search for an optimally refined grammar consistent with a coarse training treebank .", "label": "", "metadata": {}, "score": "45.271095"}
{"text": "We present a nonparametric Bayesian model of tree structures based on the hierarchical Dirichlet process ( HDP ) .Our HDP - PCFG model allows the complexity of the grammar to grow as more training data is available .In addition to presenting a fully Bayesian model for the PCFG , we also develop an efficient variational inference procedure .", "label": "", "metadata": {}, "score": "45.56942"}
{"text": "Because of the builtin redundancy of natural language , that was good enough even in 1995 to extract 95 % of the meaning from a text without any parsing at all . - jlawler Feb 1 ' 13 at 17:58 .I feel like the best answer would be if we merged ours together : technically natural languages are n't regular nor are they context - free but in practice a well designed regular language / context - free grammar is usually sufficient . - acattle Feb 1 ' 13 at 19:51 .", "label": "", "metadata": {}, "score": "45.722565"}
{"text": "Combining multiple grammars that were self - trained on disjoint sets of unlabeled data results in a final test accuracy of 92.5\\% on the WSJ test set and 89.6\\% on our Broadcast News test set .This work shows how to improve state - of - the - art monolingual natural language processing models using unannotated bilingual text .", "label": "", "metadata": {}, "score": "45.856026"}
{"text": "Grammars with self - embedding are not regular languages , the problem being that further expansions of A by the same rule creates unbounded communication between the left and right , i.e. alpha^n A beta^N. In the other direction , Chomsky proved ( the original paper is hard to find , see Harrison 's book for the proof ) that CFGs without self - embedding rules are regular ( see this paper for a constructive proof ) .", "label": "", "metadata": {}, "score": "45.90727"}
{"text": "The figure above illustrates the situation after coding the entire XML instance .This growth effect applies to all string table partitions and makes the format very compact for small documents .Note : .This section describes EXI String Tables at a conceptual level .", "label": "", "metadata": {}, "score": "46.072987"}
{"text": "As an example to exercise the process to produce schema - informed element grammars , consider the following XML Schema fragment declaring two complex - typed elements , and : .Example H-1 .Example XML Schema fragment .See section 8.5.4.1.5 Particles for the rules used to generate grammars for particles .", "label": "", "metadata": {}, "score": "46.09098"}
{"text": "Our generative self - trained grammars reach F scores of 91.6 on the WSJ test set and surpass even discriminative reranking systems without self - training .Additionally , we show that multiple self - trained grammars can be combined in a product model to achieve even higher accuracy .", "label": "", "metadata": {}, "score": "46.436584"}
{"text": "Unlike previous work on projecting syntactic resources , we show that simple methods for introducing multiple source languages can significantly improve the overall quality of the resulting parsers .The projected parsers from our system result in state - of - the - art performance when compared to previously studied unsupervised and projected parsing systems across eight different languages .", "label": "", "metadata": {}, "score": "46.440346"}
{"text": "This is so as to make the grammar presentation as concise as possible , yet preserving the variety of event types that are actually used in the example XML document .In the example encodings , whitespaces that are originally present in the example XML document are omitted , which is intentional .", "label": "", "metadata": {}, "score": "46.56562"}
{"text": "Our best results show a 26-fold speedup compared to a sequential C implementation .We present a simple method for transferring dependency parsers from source languages with labeled training data to target languages without labeled training data .We first demonstrate that delexicalized parsers can be directly transferred between languages , producing significantly higher accuracies than unsupervised parsers .", "label": "", "metadata": {}, "score": "46.771774"}
{"text": "Unlike previous work , our final model does not require any additional resources at run - time .Compared to a state - of - the - art approach , we achieve more than 20 % relative error reduction .Additionally , we annotate a corpus of search queries with part - of - speech tags , providing a resource for future work on syntactic query analysis .", "label": "", "metadata": {}, "score": "46.807793"}
{"text": "The resulting grammars are extremely compact com- pared to other high - performance parsers , yet the parser gives the best published accuracies on several languages , as well as the best generative parsing numbers in English .In addi- tion , we give an associated coarse - to - fine inference scheme which vastly improves inference time with no loss in test set accuracy .", "label": "", "metadata": {}, "score": "46.822002"}
{"text": "2.1.3.2Schema - informed Grammar .EXI grammars can be further improved if schema information is known statically .Schema information can be interpreted in two different ways or encoding modes : strict and non - strict .In strict mode , the instances being encoded must be valid with respect to the schema ; any deviation from the schema will result in an encoding error .", "label": "", "metadata": {}, "score": "46.855877"}
{"text": "Specifically , an ini- tial hypothesis lattice is constrcuted using local features .Candidate sentences are then assigned syntactic language model scores .These global syntactic scores are combined with local low - level scores in a log - linear model .", "label": "", "metadata": {}, "score": "46.88504"}
{"text": "This process can produce a grammar that has more than one production with the same non - terminal on the left - hand side and the same terminal symbol on the right - hand side .Therefore , the second step focuses on eliminating such productions .", "label": "", "metadata": {}, "score": "46.95047"}
{"text": "If M is compact , an injective immersion is an embedding , but if M is not compact then injective immersions need not be embeddings ; compare to continuous bijections versus homeomorphisms .I wish I could give an example of a non - compace imbedding / embedding , or continuous bijections versus homeomorphisms , but though I understand the two ideas , roughly , I am not sure what conditions make them conflict ...", "label": "", "metadata": {}, "score": "46.96689"}
{"text": "An undecidable property of context - free grammars is whether they generate all words over the alphabet .That implies that converting a context - free grammar into a linear grammar ( if possible ) should be difficult , since it is easy to decide whether a linear grammar ( which is the same as an NFA ) generates all words over the alphabet .", "label": "", "metadata": {}, "score": "47.14487"}
{"text": "All newly created built - in element grammars are global element grammars .[ Definition : ] A global element grammar is a grammar describing the content of an element that has global scope ( i.e. a global element ) .Each built - in element grammar created while processing an EXI stream is added to the set of global element grammars .", "label": "", "metadata": {}, "score": "47.267273"}
{"text": "We present methods to control the lexicon size when learning a Combinatory Categorial Grammar semantic parser .Existing methods incrementally expand the lexicon by greedily adding entries , considering a single training datapoint at a time .We propose using corpus - level statistics for lexicon learning decisions .", "label": "", "metadata": {}, "score": "47.298767"}
{"text": "It does n't make any difference for natural languages , anyway ; unlike mathematics , linguistics has data , so nothing can ever be proved the way it can in math . - jlawler Feb 6 ' 13 at 18:20 .Most languages ( excluding highly polysynthetic ones ) generally have a finite set of morphological word forms .", "label": "", "metadata": {}, "score": "47.35256"}
{"text": "There 's something I do n't understand here .One can embed the free group on two generators in the group $ SO(3)$ of rotations in three dimensions , which is as compact as it gets .So according to what you are saying , $ SO(3)$ would not be amenable , whence $ L^2(SO(3))$ would not contain all irreps ( even weakly ) , contradicting Peter - Weyl .", "label": "", "metadata": {}, "score": "47.43306"}
{"text": "More specifically , it describes the concept of an EXI stream and how it is generated using EXI grammars , as well as the implications on structure and content ordering in an EXI stream when compression is enabled .As a practical application of the concepts from the first part , the second part presents a complete bit - level description of an EXI document .", "label": "", "metadata": {}, "score": "47.55065"}
{"text": "The reason the usual statement of the theorem is equivalent to this one is that any groupo\u00efd is equivalent to a disjoint sum of groups .But equivalent does not mean equal ; isomorphic does not mean canonicaly isomorphic .A statement about groupo\u00efds translate into a statement about groups up to conjugacy and this kind of subtlety can get very tricky ( and/or interesting ) in practice .", "label": "", "metadata": {}, "score": "47.577972"}
{"text": "In particular , EXI grammars can take advantage of the fact that , on any given grammar , certain XML items are more popular than others .For example , by simple inspection of documents in the wild , it is easy to verify that attributes occur more frequently than processing instructions and should therefore receive shorter event codes .", "label": "", "metadata": {}, "score": "47.806747"}
{"text": "Because each refinement introduces only limited complexity , both learning and inference can be done in an incremental fashion .In this dissertation , we describe several coarse - to - fine systems .In the domain of syntactic parsing , complexity is in the grammar .", "label": "", "metadata": {}, "score": "47.836185"}
{"text": "You can read about this in his paper : .Tannaka duality for proper Lie groupoids , Journal of Pure and Applied Algebra .There is also an arxiv version of this .Even more , here is a link to his thesis which should provide even more detail : .", "label": "", "metadata": {}, "score": "47.925724"}
{"text": "The built - in EXI grammars accept any XML document or fragment and may be augmented with productions derived from schemas or other sources of information about what is likely to occur in a set of XML documents .When schemas are used , EXI also supports a user - customizable set of Datatype Representations for efficiently representing typed values .", "label": "", "metadata": {}, "score": "47.93724"}
{"text": "Although it makes reference to a proprietary software ( the xfst tool ) , there are open source alternatives that work very analogously .Is it really true that most languages have a finite set of morphological word forms ?If you have in mind inflectional morphology then sure , maybe , but derivational morphology rocks the boat a bit .", "label": "", "metadata": {}, "score": "48.282722"}
{"text": "There is no best answer , anyway .That 's the point , if there is any , to the stack exchange model . - jlawler Feb 1 ' 13 at 20:06 .Example of circumfix : .Natural Languages as Regular Languages .", "label": "", "metadata": {}, "score": "48.342266"}
{"text": "Previous sentence segmentation systems have typically been very local , using low - level prosodic and lexical features to independently decide whether or not to segment at each word boundary position .In this work , we leverage global syntactic information from a syn- tactic parser , which is better able to capture long distance depen- dencies .", "label": "", "metadata": {}, "score": "48.38754"}
{"text": "Unlike built - in XML grammars , schema - informed grammars are static and do not evolve , which permits the reuse of schema - informed grammars across the processing of multiple EXI streams .This is a single outstanding difference between the two grammar systems .", "label": "", "metadata": {}, "score": "48.536396"}
{"text": "Every groupoid is equivalent to a disjoint union of groups .In fact the inclusion of the sub-2-category of disjoint unions of groups into all groupoids is an equivalence .Hence the representation theory of groupoids reduces to that of groups .", "label": "", "metadata": {}, "score": "48.562866"}
{"text": "The following sections describe the grammars used to inform the EXI encoding .Note : .The grammar semantics in this specification are written for clarity and generality .They do not prescribe a particular implementation approach . 8.1 Grammar Notation .", "label": "", "metadata": {}, "score": "48.69033"}
{"text": "In reality , given that XML is not a regular language , a single grammar can not be used to represent an entire XML event stream .Instead , an EXI encoder uses a stack of grammars , one for each element content model ( just like an XML Schema validator would ) .", "label": "", "metadata": {}, "score": "48.9022"}
{"text": "And Mackey 's work directly influenced that of Connes . -Ronnie Brown Sep 18 ' 11 at 20:14 .The \" classical \" definition of a representation of a Lie groupoid is rather similar to that of a Lie group .", "label": "", "metadata": {}, "score": "48.997818"}
{"text": "On the other side of the spectrum , what about algebraic solvable groups ?Hi @Charles , thanks a lot for your comment .And then because of the inner product one may define an orthogonal complement which \" seems \" to imply indeed that $ M$ may be viewed as a direct summand ! -", "label": "", "metadata": {}, "score": "49.02281"}
{"text": "This is a non - normative document intended to provide an easily readable technical background on the Efficient XML Interchange ( EXI ) format .It is oriented towards quickly understanding how the EXI format can be used in practice and how options can be set to achieve specific needs .", "label": "", "metadata": {}, "score": "49.13117"}
{"text": "Unlike existing preordering models , we train feature - rich discriminative classifiers that directly predict the target - side word order .Our approach combines the strengths of lexical reordering and syntactic preordering models by performing long - distance reorderings using the structure of the parse tree , while utilizing a discriminative model with a rich set of features , including lexical features .", "label": "", "metadata": {}, "score": "49.17161"}
{"text": "Natural Languages as Context - free Grammars .Here is where the thoroughness of my answer takes a drop as I am less familiar with examining and proving context - free grammars .However , I was able to find a few articles which address the issue of natural languages as context - free grammars ( usually to the negative ) .", "label": "", "metadata": {}, "score": "49.501793"}
{"text": "Note that this space has a natural structure of a $ G$-module through left action .The direct sum here should be understood in the sense of Schauder basis with respect to the topology induced by $ \\langle\\ , \\ \\rangle$. Now here is a set of natural questions : .", "label": "", "metadata": {}, "score": "49.596863"}
{"text": "For example , if our groupoid is compact ( and topological ) what kind of representations shall one consider ?Continuous representations over continuous fields of Hilbert spaces ?In what sense continuous ?Or if it is smooth , it would be natural to consider smooth representations ( in some appropriate sense ) .", "label": "", "metadata": {}, "score": "49.747456"}
{"text": "If an attacker is able to substitute another schema in place of the intended one , the semantics of the EXI document could be changed in some ways .As an example , EXI is sensitive to the order of the values in an enumeration .", "label": "", "metadata": {}, "score": "49.751423"}
{"text": "The algorithm uses a similarity graph to encourage similar n - grams to have similar POS tags .We demonstrate the efficacy of our approach on a domain adaptation task , where we assume that we have access to large amounts of unlabeled data from the target domain , but no additional labeled data .", "label": "", "metadata": {}, "score": "49.841446"}
{"text": "We describe experiments on learning latent variable grammars for various German treebanks , using a language - agnostic statistical approach .In our method , a minimal initial grammar is hierarchically refined using an adaptive split - and - merge EM procedure , giving compact , accurate grammars .", "label": "", "metadata": {}, "score": "49.89722"}
{"text": "More efficient algorithms likely exist for generating these EXI grammars and EXI implementations are free to use any algorithm that produces grammars and event codes that generate EXI encodings that match those produced by the grammars described here .An example is provided in the appendix ( see H Schema - informed Grammar Examples ) that demonstrates the process described in this section to generate a complete schema - informed element grammar from an element declaration in a schema . 8.5.4.1", "label": "", "metadata": {}, "score": "50.023922"}
{"text": "The model is formally a latent variable CRF grammar over trees , learned by iteratively splitting grammar productions ( not categories ) .Different regions of the grammar are refined to different degrees , yielding grammars which are three orders of magnitude smaller than the single - scale baseline and 20 times smaller than the split - and - merge grammars of Petrov et al .", "label": "", "metadata": {}, "score": "50.05176"}
{"text": "Topology 41 ( 2002 ) , no .4 , 807 - 834 ) clearly separates the role of general locally compact groupoids , and of those associated with coarse metric spaces , and helps you get a clearer understanding of the situation . -", "label": "", "metadata": {}, "score": "50.309338"}
{"text": "Built - in element grammars are initially generic and are progressively refined as the specific content for the associated element is learned .All built - in element grammars are global element grammar s and can be uniquely identified by the qname of the global element they describe .", "label": "", "metadata": {}, "score": "50.32141"}
{"text": "This paper gives a full list of finite simple groups lying inside exceptional Lie groups .London Math .Soc . , ( 3 ) 74 ( 1997 ) , 105 - 150 . -Nick Gill Jun 13 ' 12 at 12:55 .", "label": "", "metadata": {}, "score": "50.586014"}
{"text": "In the algebraic setting , what is a representation of a scheme ?These do n't have clear answers , yet .-Chris Schommer - Pries Feb 26 ' 10 at 18:50 .Maybe I did n't say my question clearly .", "label": "", "metadata": {}, "score": "51.234844"}
{"text": "There are several restrictions peculiar to schema - informed element and type grammars created with strict option value true in the ability to represent a small number of uncommon element information item formulations yet valid to the schemas .This is a consequence of intentional grammar simplification aimed to make the grammars compact enough for and the amount of footprint necessary to process the grammars amenable even to extremely resource - deprived devices .", "label": "", "metadata": {}, "score": "51.27974"}
{"text": "If there is no general rule , could you please show me how to convert this CFG to a RLG ?When you substantially change the question , or if you add other questions ( like in this case ) , you should either clearly mark the edit , or if existing answers become invalid , you should create a separate question .", "label": "", "metadata": {}, "score": "51.32377"}
{"text": "The story becomes much richer in the Lie category , because then you should ask for the representation to be smooth .The story has not been completely told , and even the parts that have been told I do n't know well .", "label": "", "metadata": {}, "score": "51.373135"}
{"text": "Our first- , second- , and third - order models achieve accuracies comparable to those of their unpruned counterparts , while exploring only a fraction of the search space .We observe speed - ups of up to two orders of magnitude compared to exhaustive search .", "label": "", "metadata": {}, "score": "51.650665"}
{"text": "Using a relatively simple algorithm , which is amenable to fast and compact implementation , and a small set of datatype representations , it reliably produces efficient encodings of XML event streams .The grammar production system and format definition of EXI are presented .", "label": "", "metadata": {}, "score": "51.678627"}
{"text": "Add the production created in step 1 to the grammar . 8.5 Schema - informed Grammars .This section describes the schema - informed grammars used by EXI when schema information is available to describe the contents of the EXI stream .", "label": "", "metadata": {}, "score": "51.795692"}
{"text": "Proto - grammars are specified in a modular , constructive fashion .XML Schema components such as terms , particles , attribute uses are transformed each into a distinct proto - grammar , leveraging proto - grammars of their sub - components .", "label": "", "metadata": {}, "score": "51.920288"}
{"text": "Participants were to build a single parsing system that is robust to domain changes and can handle noisy text that is commonly encountered on the web .There was a constituency and a dependency parsing track and 11 sites submitted a total of 20 systems .", "label": "", "metadata": {}, "score": "52.041286"}
{"text": "This is a draft document and may be updated , replaced or obsoleted by other documents at any time .It is inappropriate to cite this document as other than work in progress .The intended audience of this document includes users and developers with basic understanding of XML and XML Schema .", "label": "", "metadata": {}, "score": "52.101936"}
{"text": "The built - in XML grammars are dynamic and continuously evolve to reflect knowledge learned while processing an EXI stream .New built - in element grammars are created to describe the content of newly encountered elements and new grammar productions are added to refine existing built - in grammars .", "label": "", "metadata": {}, "score": "52.185005"}
{"text": "Our research further demonstrates the breadth of the applicability of neural network methods to dependency parsing , as well as the ease with which new features can be added to neural parsing models .We present structured perceptron training for neural network transition - based dependency parsing .", "label": "", "metadata": {}, "score": "52.206573"}
{"text": "4 Answers 4 .The general belief of most linguists was expressed here in 1998 this way : . the complexity and power required to analyze linguistic data is discontinuous in its distribution .Coarsely put , we have seen over and over that the simplest tools have the broadest coverage , and more and more complexity is required to expand the coverage less and less .", "label": "", "metadata": {}, "score": "52.214767"}
{"text": "While processing a schema - informed grammar , built - in grammars may be created to represent schema deviations or elements that match wildcards declared in the schema .Even though these built - in grammars occur in the context of a schema - informed stream , they are still dynamic and evolve to represent content learned while processing the EXI stream as is described in 8.4 Built - in XML Grammars .", "label": "", "metadata": {}, "score": "52.334812"}
{"text": "Across various hierarchical encoding schemes and for multiple language pairs , we show speed - ups of up to 50 times over single - pass decoding while improving BLEU score .Moreover , our entire decoding cascade for trigram language models is faster than the corresponding bigram pass alone of a bigram - to - trigram decoder .", "label": "", "metadata": {}, "score": "52.46656"}
{"text": "This capability is called a Datatype Representation Map .Note : .This feature is relevant only to simple types in the schema .EXI does not provide a way for applications to infuse custom representations of structured data bound to complex types into the format .", "label": "", "metadata": {}, "score": "52.495625"}
{"text": "To manage this complexity , we translate into target language clusterings of increasing vocabulary size .This approach gives dramatic speed - ups while additionally increasing final translation quality .The intersection of tree transducer - based translation models with n - gram language models results in huge dynamic programs for machine translation decoding .", "label": "", "metadata": {}, "score": "52.50677"}
{"text": "We present several models to this end ; in particular a partially observed conditional random field model , where coupled token and type constraints provide a partial signal for training .Averaged across eight previously studied Indo - European languages , our model achieves a 25 % relative error reduction over the prior state of the art .", "label": "", "metadata": {}, "score": "52.752937"}
{"text": "Built - In Grammar .EXI uses a set of built - in grammars to encode XML documents and XML fragments when no schema information is available .There are built - in grammars to encode documents , fragments and elements .", "label": "", "metadata": {}, "score": "53.22539"}
{"text": "Efficient XML Interchange by Example provides a detailed , bit - level description of a schema - less example .Status of this Document .This section describes the status of this document at the time of its publication .Other documents may supersede this document .", "label": "", "metadata": {}, "score": "53.241005"}
{"text": "Does this make sense ? -Alessandro Sisto Jan 26 ' 11 at 21:22 .The embedding $ N \\to S^j$ lifts to a map of double covers by covering space theory .The map of double covers is automatically an embedding . -", "label": "", "metadata": {}, "score": "53.375694"}
{"text": "Naturally , XML items that are discarded at encoding time ( due to a particular setting of the fidelity options ) can not be reconstructed at decoding time .The next section deals with the EXI Body and discusses in more detail the effects of enabling and disabling fidelity options .", "label": "", "metadata": {}, "score": "53.50232"}
{"text": "They are in GL(27 , C ) .I am looking really for embedding of $ ^2F_4(2)'$ in $ E_6 $ compact Lie group .I tried to guess the embedding but no luck so far .I have come to idea that if I have this group generators in U(27 ) then I will find them in $ E_6 $ really .", "label": "", "metadata": {}, "score": "53.518097"}
{"text": "( see F.1 Content Coding ) .Added a non - terminal TypeEmpty ur - type , 1 to the complex ur - type grammar TypeEmpty ur - type , and defined the content index of the TypeEmpty ur - type grammar .", "label": "", "metadata": {}, "score": "53.56459"}
{"text": "On full - scale treebank parsing experiments , the discriminative latent models outperform both the comparable generative latent models as well as the discriminative non - latent baselines .We present a maximally streamlined approach to learning HMM - based acoustic models for automatic speech recognition .", "label": "", "metadata": {}, "score": "53.582794"}
{"text": "This section describes the process for augmenting the normalized grammars when the value of the strict option is true .For each normalized element grammar Element i , apply the following procedures .If a grammar can be found for the target - type type using the encoded target - type representation , evaluate the element contents using the grammar for target - type type instead of RightHandSide .", "label": "", "metadata": {}, "score": "53.606766"}
{"text": "State - of - the - art natural language processing models are anything but compact .Syntactic parsers have huge grammars , machine translation systems have huge transfer tables , and so on across a range of tasks .With such complexity come two challenges .", "label": "", "metadata": {}, "score": "53.613358"}
{"text": "Specialized approaches optimized for specific use cases should be avoided .Minimal : .To reach the broadest set of small , mobile and embedded applications , simple , elegant approaches are preferred to large , analytical or complex ones .Efficient : .", "label": "", "metadata": {}, "score": "53.695873"}
{"text": "- Amritanshu Prasad Dec 23 ' 10 at 4:55 Syntactic parsing is a fundamental problem in computational linguistics and natural language processing .Traditional approaches to parsing are highly complex and problem specific .Recently , Sutskever et al .( 2014 ) presented a task - agnostic method for learning to map input sequences to output sequences that achieved strong results on a large scale machine translation problem .", "label": "", "metadata": {}, "score": "53.724117"}
{"text": "Fragment grammars are more lenient than document grammars ; for example , they allow multiple top - level elements to be encoded as siblings .For more information on these grammars , the reader is referred to Built - in XML Grammars .", "label": "", "metadata": {}, "score": "53.725548"}
{"text": "This ' universal ' treebank is made freely available in order to facilitate research on multilingual dependency parsing .We consider the construction of part - of - speech taggers for resource - poor languages .Recently , manually constructed tag dictionaries from Wiktionary and dictionaries projected via bitext have been used as type constraints to overcome the scarcity of annotated data in this setting .", "label": "", "metadata": {}, "score": "53.833157"}
{"text": "It would benefit your answer to get your scientific language right . \"A pumping lemma is any x , y , and z ... \" .No , the pumping lemma for regular languages is a lemma which states that all regular languages have a certain property . - dainichi Feb 5 ' 13 at 10:25 .", "label": "", "metadata": {}, "score": "53.91241"}
{"text": "-- Bayer et al , \" Theoretical and Computational Linguistics : Toward a Mutual Understanding \" , p.224 .That 's in terms of syntax , mind you , not morphology .But to the extent one considers morphology as a sort of phonological syntax , the same principles apply , provided one can distinguish and mark exceptions .", "label": "", "metadata": {}, "score": "53.991787"}
{"text": "Assuming you want your general method to be computable , the answer is no .If a ( computable ) general conversion method existed , you could use it to construct a computable bound on the blowup between CFGs and right - linear grammars , which would contradict the non - existence of such a bound .", "label": "", "metadata": {}, "score": "54.015648"}
{"text": "It gives a thoery of groupo\u00efds and their represenations in fibered categories .I 'm certainly not a fan of groupoids , but I agree with the statement that they can make statements and sometimes proofs much simpler .Consider for example G. Yu 's result that finitely generated groups coarsely embedding into Hilbert space , satisfy the Novikov conjecture ( see Guoliang Yu , The coarse Baum - Connes conjecture for spaces which admit a uniform embedding into Hilbert space .", "label": "", "metadata": {}, "score": "54.17888"}
{"text": "Despite its simplicity , a product of eight automatically learned grammars improves parsing accuracy from 90.2 % to 91.8 % on English , and from 80.3 % to 84.5 % on German .Pruning can massively accelerate the computation of feature expectations in large models .", "label": "", "metadata": {}, "score": "54.215794"}
{"text": "Otherwise , the value of the nil is schema - invalid and can not be represented when the value of the strict option is true .If the value of nil is true , evaluate the element contents using the grammar TypeEmpty k defined above rather than RightHandSide .", "label": "", "metadata": {}, "score": "54.22872"}
{"text": "So theory say that embedding exists but in practice we do n't know how to obtain matrices in U(27 ) generating this group .Regards , Marek - Marek Mitros Jun 13 ' 12 at 15:45 .No more answers ?Can somebody explain why representation theory does not give embedding of finite group into O(n ) orthogonal Lie group ?", "label": "", "metadata": {}, "score": "54.26231"}
{"text": "To provide a more operational view of an EXI processor , we will opt for the use of FA to explain how grammars work .The following figure shows a stack of grammars in which the top - level grammar accepts \" note \" elements .", "label": "", "metadata": {}, "score": "54.392025"}
{"text": "Given this fixed network representation , we learn a final layer using the structured perceptron with beam - search decoding .On the Penn Treebank , our parser reaches 94.26 % unlabeled and 92.41 % labeled attachment accuracy , which to our knowledge is the best accuracy on Stanford Dependencies to date .", "label": "", "metadata": {}, "score": "54.556984"}
{"text": "To understand how a given event code approximates the likelihood a given production will match , it is useful to visualize the event codes for a set of production rules that have the same non - terminal symbol on the left - hand side as a tree .", "label": "", "metadata": {}, "score": "54.620888"}
{"text": "So this reduces your question to the study of order $ 2 $ elements of the orthogonal group .- Ryan Budney Jan 26 ' 11 at 18:32 .So I believe the answer to your question is yes .A linear involution of Euclidean space does not have to be an antipodal map but it fixes a subspace , and it 's the antipodal map on the orthogonal subspace .", "label": "", "metadata": {}, "score": "54.666172"}
{"text": "Though it is not required , the uses of non - terminals Term_product 0,1 and Term_product 1,1 are each replaced by Term_product 1,0 and Term_product 1,0 , which produces the following simplified proto - grammars .Note that some productions that were present in the proto - grammars have been removed in the normalized grammars .", "label": "", "metadata": {}, "score": "54.77899"}
{"text": "We apply our method to train parsers that excel when used as part of a reordering component in a statistical machine translation system .We use a corpus of weakly - labeled reference reorderings to guide parser training .Our best parsers contribute significant improvements in subjective translation quality while their intrinsic attachment scores typically regress .", "label": "", "metadata": {}, "score": "54.839035"}
{"text": "The annotations are produced automatically with statistical models that are specifically adapted to historical text .The corpus will facilitate the study of linguistic trends , especially those related to the evolution of syntax .Syntactic analysis of search queries is important for a variety of information- retrieval tasks ; however , the lack of annotated data makes training query analysis models difficult .", "label": "", "metadata": {}, "score": "54.985756"}
{"text": "Our methods result in state - of - the - art performance on the task of executing sequences of natural language instructions , achieving up to 25 % error reduction , with lexicons that are up to 70 % smaller and are qualitatively less noisy .", "label": "", "metadata": {}, "score": "55.083057"}
{"text": "Those restrictions need to be given heed to in the process of making a decision to choose the right strict option value that works best for each use case .It is not possible to use xsi : type and xsi : nil attributes together on the same element .", "label": "", "metadata": {}, "score": "55.17504"}
{"text": "The criteria EXI compression uses to define and combine channels is intentionally simple to facilitate implementation , reduce processing overhead , and avoid the need to encode channel ordering or grouping information in the format .The figure below presents a schematic view of the steps involved in EXI compression .", "label": "", "metadata": {}, "score": "55.484093"}
{"text": "Here they use Hilbert bundles to define representations .I think in the finite case that groupoids give a nice take on induced representations .If you have a subgroup H of a group G , then G has a covering groupoid corresponding to H. It is the category of elements for the action of G on G / H. The covering groupoid is naturally equivalent to H and so has the same representation theory as H. Now the category of representations of the covering groupoid is the module category of the corresponding category algebra since there are finitely many vertices .", "label": "", "metadata": {}, "score": "55.59415"}
{"text": "We shall never forget and will always appreciate his presence in us , and great contribution that is omnipresent in every aspect of our work throughout .It could generate regular language , which means it can be converted to a right linear grammar .", "label": "", "metadata": {}, "score": "55.605186"}
{"text": "Schema - informed grammars accept all XML documents and fragments regardless of whether and how closely they match the schema .The EXI stream encoder encodes individual events using schema - informed grammars where they are available and falls back to the built - in XML grammars where they are not .", "label": "", "metadata": {}, "score": "55.61906"}
{"text": "Standard inference can be used at test time .Our approach is able to scale to very large problems and yields significantly improved target domain accuracy .It is well known that parsing accuracies drop significantly on out - of - domain data .", "label": "", "metadata": {}, "score": "55.65238"}
{"text": "With 100 K unlabeled and 2 K labeled questions , uptraining is able to improve parsing accuracy to 84 % , closing the gap between in - domain and out - of - domain performance .We study self - training with products of latent variable grammars in this paper .", "label": "", "metadata": {}, "score": "55.703983"}
{"text": "You are right but you slightly evaded the question ;) A more interesting questions is the following : how to construct an NFA from a CFG provided you know that the CFG generates a regular language . -Dan Feb 6 ' 13 at 15:53 .", "label": "", "metadata": {}, "score": "55.862907"}
{"text": "Despite the much simplified training process , our acoustic model achieves state - of - the - art results on phone classification ( where it outperforms almost all other methods ) and competitive performance on phone recognition ( where it outperforms standard CD triphone / subphone / GMM approaches ) .", "label": "", "metadata": {}, "score": "55.869713"}
{"text": "It simultaneously improves performance and significantly reduces bandwidth requirements without compromising efficient use of other resources such as battery life , code size , processing power , and memory .EXI uses a grammar - driven approach that achieves very efficient encodings using a straightforward encoding algorithm and a small set of datatype representations .", "label": "", "metadata": {}, "score": "55.886494"}
{"text": "In our method the first , monolingual view consists of supervised predictors learned separately for each language .The second , bilingual view consists of log - linear predictors learned over both languages on bilingual text .Our training procedure estimates the parameters of the bilingual model using the output of the monolingual model , and we show how to combine the two models to account for dependence between views .", "label": "", "metadata": {}, "score": "55.904427"}
{"text": "This section walks through the coding of the Notebook Example explaining the concepts previously introduced in a step - by - step approach . 3.1 Notation .The table below shows the notations that are used in the description of EXI encoding in subsequent sections .", "label": "", "metadata": {}, "score": "55.950096"}
{"text": "The formula for such reflection can be found in Atsuyma paper .I am hoping to find 1755 points in EIII in which reflections would be 2A conjugacy class in $ ^2F_4(2)'$. Motivation The motivation for my research is following .Daniel Allcock has written to me that \" There seems to be a friendship between $ ^3D_4(2)$ and $ Co_0 $ even though neither contains the other \" .", "label": "", "metadata": {}, "score": "56.130867"}
{"text": "This document is the specification of the Efficient XML Interchange ( EXI ) format .EXI is a very compact representation for the Extensible Markup Language ( XML )Information Set that is intended to simultaneously optimize performance and the utilization of computational resources .", "label": "", "metadata": {}, "score": "56.289116"}
{"text": "To facilitate future research in unsupervised induction of syntactic structure and to standardize best - practices , we propose a tagset that consists of twelve universal part - of - speech categories .In addition to the tagset , we develop a mapping from 25 different treebank tagsets to this universal set .", "label": "", "metadata": {}, "score": "56.346703"}
{"text": "Clarified that a channel of which all the events have zero - byte representations has a zero - byte representation and is not explicitly represented in a compressed stream .( see 9.3 Compressed Streams ) .Fixed an error in ElementFragment grammar to make sure the grammar when strict option value set to false , after undeclared productions are added , do not end up making AT terminals available following the first occurrence of SE or CH events .", "label": "", "metadata": {}, "score": "56.398987"}
{"text": "A set of one or more grammar productions that share the same left - hand side non - terminal symbol are often presented together annotated with event codes that specify how events matching the terminal symbols of the associated productions are represented in the EXI stream as follows : .", "label": "", "metadata": {}, "score": "56.421707"}
{"text": "Stated differently , the EXI format describes a learning mechanism to further improve efficiency when no schema information is available statically .Newly learned productions are assigned short event codes , improving compactness for every subsequent use of those productions .In addition , by adding new productions to the grammar , certain data associated with an event only needs to be encoded once .", "label": "", "metadata": {}, "score": "56.73127"}
{"text": "The following tables illustrate this principle via an example .In the first table , where productions are not separated according to their popularity , a 4-bit code is needed to represent each entry .In the second table , on the other hand , code lengths vary from 2 bits to 6 bits after productions are group based on their likelihood to occur .", "label": "", "metadata": {}, "score": "56.8819"}
{"text": "We show that dependency parsers have more difficulty parsing questions than constituency parsers .In particular , deterministic shift - reduce dependency parsers , which are of highest interest for practical applications because of their linear running time , drop to 60 % labeled accuracy on a question test set .", "label": "", "metadata": {}, "score": "56.941475"}
{"text": "Mapping of the comment information item properties and the EXI event types .Property .EXI event types .[ content ] . text content item of CM .[ parent ] .Computed based on the last SE event encountered that did not get a matching EE event , or the SD event .", "label": "", "metadata": {}, "score": "57.01264"}
{"text": "Math . 139 ( 2000 ) , no . 1 , 201 - 240 ) : the original proof is really technical and hard to grasp .( Continued in the next comment ) - Alain Valette Jun 26 ' 11 at 5:37 .", "label": "", "metadata": {}, "score": "57.17122"}
{"text": "We present a novel approach which employs a randomized sequence of pruning masks .Formally , we apply auxiliary variable MCMC sampling to generate this sequence of masks , thereby gaining theoretical guarantees about convergence .Because each mask is generally able to skip large portions of an underlying dynamic program , our approach is particularly compelling for high - degree algorithms .", "label": "", "metadata": {}, "score": "57.187546"}
{"text": "At the top level , the XML Schema regular expression syntax is summarized by the following production excerpted here from [ XML Schema Datatypes ] .Note the notation used for the numbers that tag the productions .\" XSD : \" is prefixed to the original numeric tags to make it easier to discern them as belonging to XML Schema specification .", "label": "", "metadata": {}, "score": "57.265537"}
{"text": "Those readers who prefer a step - by - step introduction to the EXI format design and features are suggested to start with the non - normative [ EXI Primer ] . 1.1History and Design .EXI is the result of extensive work carried out by the W3C 's XML Binary Characterization ( XBC ) and Efficient XML Interchange ( EXI ) Working Groups .", "label": "", "metadata": {}, "score": "57.29358"}
{"text": "As used in the XML Information Set specification , the Infoset property names are shown in square brackets , [ thus ] .Note : .As has been prescribed in section 2 .Design Principles , EXI is designed to be compatible with the XML Information Set .", "label": "", "metadata": {}, "score": "57.32863"}
{"text": "EXI is made agnostic about [ character encoding scheme ] and [ version ] properties as they are in XML Information Set , and considers them to be the properties of XML serializers in use .EXI forgoes [ standalone ] property because simply having no references to any external markup declarations practically serves the purpose with less complexity .", "label": "", "metadata": {}, "score": "57.39115"}
{"text": "Qiaochu : Thinking of a groupoid representation as a quiver representation means forcing a bunch of the linear maps to be isomorphisms .This eliminates a lot of the interesting behavior of quiver representations , and would n't make use of the fact that we have a bunch of invertible linear maps .", "label": "", "metadata": {}, "score": "57.474174"}
{"text": "There is a theory of representation of groupoids , that runs parallel to the classical theory of locally compact groups .A locally compact Hausdorff group $ G$ always has a left ( as well as a right ) invariant measure .", "label": "", "metadata": {}, "score": "57.570778"}
{"text": "A representation for $ G$ is simply a Lie groupoid homomorphism $ G \\to Gl(V)$.It should be noted that this notion of representation is somehow \" too strict \" .Giorgio Trentinaglia argues that one should instead replace smooth vector bundles with more general objects , which he calls \" smooth Euclidean fields \" .", "label": "", "metadata": {}, "score": "57.58963"}
{"text": "Yuhao Huang Feb 27 ' 10 at 2:44 .A representation just means an equivariant vector bundle , or more general sheaf , ie sheaf on the quotient stack .( this is te obvious generalization of representations of a group ) - David Ben - Zvi Feb 27 ' 10 at 4:09 .", "label": "", "metadata": {}, "score": "57.68452"}
{"text": "Meanwhile , Graphics Processor Units ( GPUs ) have become widely available , offering the opportunity to alleviate this bottleneck by exploiting the fine - grained data parallelism found in the CKY algorithm .In this paper , we explore the design space of parallelizing the dynamic programming computations carried out by the CKY algorithm .", "label": "", "metadata": {}, "score": "57.68531"}
{"text": "This specification does not dictate the syntax or semantics of other values specified in this field .An example schemaId scheme is the use of URI that is apt for globally identifying schema resources on the Web .The parties involved in the exchange are free to agree on the scheme of schemaId field that is appropriate for their use to uniquely identify the schema information .", "label": "", "metadata": {}, "score": "57.71888"}
{"text": "Clarified the preamble text of 8.5 Schema - informed Grammars by adding a mention that the section describes only the process for deriving schema - informed grammars from XML Schemas .Clarified that the number of values used to dichotomize the compressed stream representation only includes values in value channels but not those occasional values of xsi : type and xsi : nil in the structure channel .", "label": "", "metadata": {}, "score": "57.726242"}
{"text": "Editorial note .The integration of a magic cookie is under consideration by the EXI WG .A magic cookie would allow distinguishing an EXI document from formats other than XML or from future character encodings .The Presence Bit for EXI Options follows the distinguishing bits .", "label": "", "metadata": {}, "score": "57.760956"}
{"text": "Otherwise , if it is not for certain if a receiver understands the particular user - defined datatype representations , the sender should never attempt to send documents that use user - defined datatype representations to that recipient .EXI Grammars .", "label": "", "metadata": {}, "score": "57.860657"}
{"text": "Each value that would have otherwise been represented by one of these datatypes is instead represented as a String with the associated restricted character set , regardless of the actual pattern facets , if any , specified in the definitions of the schema datatypes .", "label": "", "metadata": {}, "score": "57.861347"}
{"text": "The new grammar accepts any set of symbols accepted by its left operand followed by any set of symbols accepted by its right operand .Given a left operand Grammar L and a right operand Grammar R , the following operation .", "label": "", "metadata": {}, "score": "57.96958"}
{"text": "If all such attributes have the same schema type name , their value is represented using that type .Otherwise , their value is represented as a String .The variable m in the grammar above represents the number of unique element qnames declared in the schema .", "label": "", "metadata": {}, "score": "58.127403"}
{"text": "Let $ G$ be a locally compact group and let $ \\mu$ be a left Haar measure .I do n't know so much about unitary representations of groups but for the sake of convenience let us make the following definition : .", "label": "", "metadata": {}, "score": "58.15265"}
{"text": "However as soon as you go to something non - compact this might not be true .In fact , there is a much weaker notion known as weak containment of representation .and it is known that $ L^2(G)$ weakly contains all irreducible reps if and only if $ G$ is amenable .", "label": "", "metadata": {}, "score": "58.209488"}
{"text": "Assign each string value a compact identifier in the sorted order , with the initial identifier number 0 assigned to the first string value , incremented by 1 before each subsequent assignment .E Deriving Set of Characters from XML Schema Regular Expressions .", "label": "", "metadata": {}, "score": "58.272556"}
{"text": "Pattern facets constrain the set of valid values to those that lexically match the specified regular expression .This section describes the rules for deriving the set of characters allowed in a string value that conforms to a given regular expression in an XML Schema .", "label": "", "metadata": {}, "score": "58.34858"}
{"text": "When xsi : type and/or xsi : nil attributes appear in an element where schema - informed grammars are in effect , they MUST occur before any other AT events of the same element , with xsi : type placed before xsi : nil when they both occur .", "label": "", "metadata": {}, "score": "58.391182"}
{"text": "Computed based on the last SE event encountered that did not get a matching EE event . B.7Comment Information item .A comment information item maps to a Comment ( CM ) event with each of its properties subject to further mapping as shown in the following table .", "label": "", "metadata": {}, "score": "58.391785"}
{"text": "Note , in particular among other cases , that this practice applies to the use of xsi : type attributes in EXI streams when Preserve.lexicalValues fidelity option is set to true .By default , datatypes derived from the XML Schema datatypes above are also represented according to the associated built - in EXI datatype representation .", "label": "", "metadata": {}, "score": "58.395267"}
{"text": "Format 1.0 for further details .Hereinafter , the presentation assumes that the reader is familiar with the basic concepts of XML and the way XML Schema can be used to describe and enforce constraints on XML document families .The document is comprised of two major parts .", "label": "", "metadata": {}, "score": "58.42413"}
{"text": "Also , EXI supports user - defined datatype representations , and such representations , if present in a document and purportedly understood by a processor , can be a security weakness .Definitions of these representations are expected to be external , often application- or industry - specific , so any definition needs to be analyzed carefully from the security perspective before being adopted .", "label": "", "metadata": {}, "score": "58.447197"}
{"text": "Fair enough ; an infinite number of derivational suffixes or a suffix like \" -ki \" can be modeled by a regular language , though , even if the set is infinite .The embedding example with the anti - missile is more interesting ; it 's true that this can not be modeled by regular languages .", "label": "", "metadata": {}, "score": "58.456623"}
{"text": "Implementations must take care to avoid creating an empty DEFLATE stream when all the channels that would have otherwise been organized into a compressed stream are implicit .E.g. , this can occur if the final block contains only zero - length EE and ED events .", "label": "", "metadata": {}, "score": "58.46035"}
{"text": "Is there any new phenomenon , compare with the representation of groups ?( Either brand new things or pitfalls for those who too familiar with representations of groups ) .Does this point of view simplified any proof of theorems in representation of groups ?", "label": "", "metadata": {}, "score": "58.58687"}
{"text": "Latent variable grammars take an observed ( coarse ) treebank and induce more fine - grained grammar categories , that are better suited for modeling the syntax of natural languages .Estimation can be done in a generative or a discriminative framework , and results in the best published parsing accuracies over a wide range of syntactically divergent languages and domains .", "label": "", "metadata": {}, "score": "58.65901"}
{"text": "When the value of the \" schemaId \" element is empty , no user defined schema information is used for processing the EXI body ; however , the built - in XML schema types are available for use in the EXI body .", "label": "", "metadata": {}, "score": "58.855164"}
{"text": "If the target datatype definition is a definition for a built - in datatype XS2 , there is no restricted character set for the string value .Otherwise , determine the set of characters for each immediate pattern facet of the target datatype definition according to section E Deriving Set of Characters from XML Schema Regular Expressions .", "label": "", "metadata": {}, "score": "59.115776"}
{"text": "Content Representation .2.2.1 Built - In Types .EXI uses built - in types to represent so called content value items in an efficient manner .In other words , all attribute and character values are encoded according to its type information .", "label": "", "metadata": {}, "score": "59.37996"}
{"text": "Examples of such unrepresented lexical constructs of XML include white space outside the document element , white space within tags , the kind of quotation marks ( single or double ) used to quote attribute values , and the boundaries of CDATA marked sections .", "label": "", "metadata": {}, "score": "59.40148"}
{"text": "Then combine the sequence of grammars using the grammar concatenation operator defined in section 8.5.4.1.1 Grammar Concatenation Operator as follows : .8.5.4.1.8.2 Choice Model Groups .If the value of n is 0 , add the following productions to the grammar ParticleTerm i .", "label": "", "metadata": {}, "score": "59.490097"}
{"text": "This is a restricted form of Greibach normal form [ Greibach Normal Form ] .EXI proto - grammars are derived from XML Schema in a straight - forward manner and can easily be normalized with simple algorithm ( see 8.5.4.2 EXI Normalized Grammars ) .", "label": "", "metadata": {}, "score": "59.49317"}
{"text": "See 8.5.1 Schema - informed Document Grammar for the process used for generating the grammar productions below from the schema .At the point in an EXI stream where the above grammar productions are in effect , the event code of Start Element \" A \" ( i.e. SE(\"A \" ) ) is 0 .", "label": "", "metadata": {}, "score": "59.530655"}
{"text": "Basic Concepts .EXI achieves broad generality , flexibility , and performance , by unifying concepts from formal language theory and information theory into a single , relatively simple algorithm .The algorithm uses a grammar to determine what is likely to occur at any given point in an XML document and encodes the most likely alternatives in fewer bits .", "label": "", "metadata": {}, "score": "59.532204"}
{"text": "The design of the format presented here , is largely based on the results of the measurements carried out by the group to evaluate the performance characteristics ( mainly of processing efficiency and compactness ) of various existing formats .The EXI format is based on Efficient XML [ Efficient XML ] , including for example the basis heuristic grammar approach , compression algorithm , and resulting entropy encoding .", "label": "", "metadata": {}, "score": "59.59702"}
{"text": "Expanded productions equivalent to the productions used above .Each production rule in the EXI grammar includes an event code value that approximates the likelihood the associated production rule will be matched over the other productions with the same left - hand - side non - terminal symbol .", "label": "", "metadata": {}, "score": "59.614098"}
{"text": "Event code trees are shallow and contain at most three levels .In addition , the length of each event code in the event code tree is assigned statically without analyzing the data .This classification provides some of the benefits of a Huffman tree without the cost . 8.3", "label": "", "metadata": {}, "score": "59.61577"}
{"text": "Some of it is harder ; and agreement phenomena slide right over into syntax again .Finally , I 've been informed by Jerry Sadock , an expert on West Greenlandic Eskimo languages , that polysynthetic Eskimo has recursive morphology ; it works very simply through noun incorporation , since complement clauses are nouns .", "label": "", "metadata": {}, "score": "59.6505"}
{"text": "This document not only specifies the EXI format , but also defines errors that EXI processors are required to detect and behave upon .The primary goal of this document is to define the EXI format completely without leaving ambiguity so as to make it feasible for implementations to interoperate .", "label": "", "metadata": {}, "score": "59.693344"}
{"text": "As discussed in section 6.3 Fidelity Options , applications MAY provide a set of fidelity options to specify the XML features they require .EXI processors MUST use these fidelity options to prune the productions of which the terminal symbols represent the events that are not required from the grammars , improving compactness and processing efficiency .", "label": "", "metadata": {}, "score": "59.70142"}
{"text": "EXI uses the same simple procedure described above , to encode well - formed documents , document fragments , schema - valid information items , schema - invalid information items , information items partially described by schemas and information items with no schema at all .", "label": "", "metadata": {}, "score": "59.717945"}
{"text": "Marek , could you define EIII ?Just to be sure I understand what you 're asking : Are you looking for irreducible embeddings ?If so the ATLAS says there are only two into GL(27,C ) and if these do n't work ( as you say ) , then you have no chance .", "label": "", "metadata": {}, "score": "59.736855"}
{"text": "Note : .The content index of grammars Type ur - type and TypeEmpty ur - type are both 1 ( one ) .8.5.4.1.4 Attribute Uses .Add the following grammar productions to Attribute i : .Representing Event Content ) .", "label": "", "metadata": {}, "score": "59.81307"}
{"text": "Primary acoustic , speech , and vision systems were trained to discriminate instances of the categories .Higher - level systems exploited correlations among the categories , incorporated sequential context , and combined the joint evidence from the three information sources .", "label": "", "metadata": {}, "score": "59.81556"}
{"text": "In the Klein bottle example , at the self - intersection , any point of intersection has two distinct tangent planes , hence this map is injective .So , an immersion is an embedding , i.e. an isomorphic ( homeomorphic ) copy , at each point , and vice versa , though the entire image may not be a homeomorphic copy .", "label": "", "metadata": {}, "score": "59.84591"}
{"text": "The following content items are encoded using a string table : .When a string value is found in the string table , the value is encoded using the compact identifier and no changes are made to the string table as a result .", "label": "", "metadata": {}, "score": "59.90496"}
{"text": "Yes indeed , thanks @Richard .Hugo , you should take a look at Godement 's Seminarie Bourbaki Expose \" Introduction aux travaux de Selberg \" ( 1957 ) where a proof of the Plancherel theorem for $ SL_2(\\mathbf R)$ is beautifully explained .", "label": "", "metadata": {}, "score": "59.948082"}
{"text": "The initial entries of local - name string table partitions has been split into two , where the second contains entries for the XSD - NS partition and gets appended to first only when XML Schemas are used .( see D.3 Initial Entries in Local - Name Partitions ) .", "label": "", "metadata": {}, "score": "59.95629"}
{"text": "- Dima Pasechnik Jun 30 ' 12 at 0:17 Could someone please explain what \" embedding \" means ?Are n't those 2 things 3D objects ?Also , I have some across the word \" immersion \" .What is the difference between \" immersion \" and \" embedding \" ? \" Immersion \" is usually synonymous with \" embedding \" , but used in certain fields more than in others . -", "label": "", "metadata": {}, "score": "60.01499"}
{"text": "When set to true , those productions that have NS , CM , PI , ER , and SC terminal symbols are omitted from the EXI grammars , and schema - informed element and type grammars are restricted to only permit items declared in the schemas .", "label": "", "metadata": {}, "score": "60.083557"}
{"text": "The best accuracies were in the 80 - 84\\% range for F1 and LAS ; even part - of - speech accuracies were just above 90\\% .Coarse - to - fine inference has been shown to be a robust approximate method for improving the efficiency of structured prediction models while preserving their accuracy .", "label": "", "metadata": {}, "score": "60.31766"}
{"text": "The process for augmenting the grammar is described in 8.5.4.4 Undeclared Productions .The content index of grammars ElementFragment and ElementFragmentTypeEmpty are both 1 ( one ) .8.5.4 Schema - informed Element and Type Grammars .Add additional productions to the normalized EXI grammar to represent events that may occur in the EXI stream , but are not described by the schema , such as comments , processing - instructions , schema - deviations , etc .", "label": "", "metadata": {}, "score": "60.432213"}
{"text": "When there are more than one item that represent the same value in the enumeration , such value can be represented using the ordinal position of any items that represent the value .Exceptions are for schema types derived from others by union and their subtypes , QName or Notation and types derived therefrom by restriction .", "label": "", "metadata": {}, "score": "60.47896"}
{"text": "( Just as modules on BG gives representations of G. )Studying when two representations give the \" same \" module will be interesting .Is n't a representation of a groupoid the same thing as a representation of the corresponding quiver ? -", "label": "", "metadata": {}, "score": "60.511574"}
{"text": "8.5.4.1.8.3 All Model Groups .Add the following production to the grammar ParticleTerm i .This grammar is intentionally simple and succinct , enabling high - performance , low - footprint implementations on a wide range of devices , including those with very limited memory resources .", "label": "", "metadata": {}, "score": "60.54803"}
{"text": "XML instances can be seen as a combination of structure and content information .The content information can be further divided in different sections according to the context ( surrounding structure as indicated by a QName ) .EXI treats XML instances this way and uses these implied partitions , so called channels , to provide blocked input to a standard compression algorithm .", "label": "", "metadata": {}, "score": "60.597347"}
{"text": "Flexible : .EXI must deal flexibly and efficiently with documents that contain arbitrary schema extensions or deviate from their schema .Documents that contain schema deviations should not cause encoding to fail .Interoperable : .EXI must integrate well with existing XML technologies , minimizing the changes required to those technologies .", "label": "", "metadata": {}, "score": "60.61099"}
{"text": "Due to the different table sizes a global compact identifier is less compact than a local compact identifier hit .Nevertheless global value hits avoid encoding string literals again .The number of bits needed to encode a compact identifier depends on the actual number of entries of the associated table at that time .", "label": "", "metadata": {}, "score": "60.644157"}
{"text": "8.5.4.1.2 Element Grammars .This section describes the process for creating an EXI element grammar from an XML Schema element declaration XS1 .The grammar Element i describing the content model of E i is created as follows .[ Definition : ] Type i is a grammar that fully reflects the type definition of T i , whereas [ Definition : ] TypeEmpty i is a grammar that regards only the attribute uses and attribute wildcards of T i , if any .", "label": "", "metadata": {}, "score": "60.65842"}
{"text": "H.3 Complete Grammar Examples .The normalized grammars NormG_ProductElement and NormG_OrderElement are augmented with undeclared productions to become complete grammars .See section 8.5.4.4 Undeclared Productions for the process to augment normalized grammars with productions for accepting terminal symbols not declared in schemas .", "label": "", "metadata": {}, "score": "60.69362"}
{"text": "It does this by mapping the stream of events to a lower entropy set of representative values and encoding those values using a set of simple variable length codes or an EXI compression algorithm .The result is a very simple , small algorithm that uniformly handles schema - less encoding , schema - informed encoding , schema deviations , and any combination thereof in EXI streams .", "label": "", "metadata": {}, "score": "60.70362"}
{"text": "The following design principles were used to guide the development of EXI and encourage consistent design decisions .They are listed here to provide insight into the EXI design rationale and to anchor discussions on desirable EXI traits .General : .", "label": "", "metadata": {}, "score": "60.790955"}
{"text": "In particular , pattern facets that contain one or more category escapes XS2 , category complement escapes XS2 or multi - character escapes XS2 other than \\s do not have restricted character sets .F Content Coding and Internet Media Type .", "label": "", "metadata": {}, "score": "60.984627"}
{"text": "See section 8.5.4.1.8.1 Sequence Model Groups for the rules used to generate grammars for sequence groups .See section 8.5.4.1.5 Particles for the rules used to generate grammars for particles .Note the subtle difference between the forms of the two grammars Use_sku and Use_color .", "label": "", "metadata": {}, "score": "60.98847"}
{"text": "7.3.2Partitions Optimized for Frequent use of Compact Identifiers .String table partitions that are expected to contain a relatively small number of entries used repeatedly throughout the document are optimized for the frequent use of compact identifiers .This includes the uri partition and all partitions containing prefix content items .", "label": "", "metadata": {}, "score": "61.014793"}
{"text": "Repeat this process until there are no more productions in the grammar G i of the form : . 8.5.4.3 Event Code Assignment .This section describes the process for assigning unique event codes to each production in a normalized EXI grammar .", "label": "", "metadata": {}, "score": "61.08152"}
{"text": "Examples of deviations are attributes whose actual values do not match the type defined in the schema or elements whose structure does not correspond to that in the schema .Instead of being dynamically extensible as the built - in grammars , schema - informed grammars are created statically based on the information in the available schema .", "label": "", "metadata": {}, "score": "61.117386"}
{"text": "For example , the eight event codes shown in the DocContent grammar above have values ranging from 0 to 5 for the first part .Six distinct values are needed to identify the first part of these event codes .When the value of the compression option is false and bit - packed alignment is used , n -bit unsigned integers are represented using n bits .", "label": "", "metadata": {}, "score": "61.13397"}
{"text": "EXI Normalized Grammars .This section describes the process for converting an EXI proto - grammar generated from an XML Schema in accordance with section 8.5.4.1 EXI Proto - Grammars into an EXI normalized grammar .Each production in an EXI normalized grammar has exactly one non - terminal symbol on the left - hand side and one terminal symbol on the right - hand side followed by at most one non - terminal symbol on the right - hand side .", "label": "", "metadata": {}, "score": "61.283974"}
{"text": "Schemas can provide one or more enumerated values for datatypes .When the Preserve.lexicalValues option is false , EXI exploits those pre - defined values when they are available to represent values of such datatypes in a more efficient manner than would have done otherwise without using pre - defined values .", "label": "", "metadata": {}, "score": "61.3267"}
{"text": "The datatype representation map feature of EXI requires coordination between the producer and consumer of an EXI document , and is not recommended except in controlled environments or using standardized datatype representations potentially defined in the future .EXI permits information necessary to decode a document to be omitted with the expectation that such information has been communicated out of band .", "label": "", "metadata": {}, "score": "61.404068"}
{"text": "Fidelity options are used to manage filters for certain XML items as shown in the following table .Productions of PI ( Processing Instruction ) events are preserved in grammars .Preserve.dtd .NS ( Namespace Declaration ) events and namespace prefixes are preserved .", "label": "", "metadata": {}, "score": "61.438652"}
{"text": "The W3C has change control over this specification .G Example Encoding ( Non - Normative ) .EXI Primer [ EXI Primer ] contains a section that explains the workings of EXI format using simple example documents .Those examples are intended to serve as a tool to confirm the understanding of the EXI format in action by going through encoding and decoding processes step by step .", "label": "", "metadata": {}, "score": "61.449783"}
{"text": "9.2 Channels .Events inside each block are multiplexed into channels .The first channel of each block is the structure channel described in Section 9.2.1 Structure Channel .The remaining channels in each block are value channels described in Section 9.2.2 Value Channels .", "label": "", "metadata": {}, "score": "61.48088"}
{"text": "Get the next event data to be encoded .If fidelity options ( see 6.3 Fidelity Options ) indicate this event type is not processed , go to step 1 .Under certain cirmcumstances , it is not strictly required that the xsi : type or xsi : nil attributes occur before other AT events of the same element .", "label": "", "metadata": {}, "score": "61.494225"}
{"text": "Across eight European languages , our approach results in an average absolute improvement of 10.4 % over a state - of - the - art baseline , and 16.7 % over vanilla hidden Markov models induced with the Expectation Maximization algorithm .", "label": "", "metadata": {}, "score": "61.54581"}
{"text": "The string table is organized into partitions so that the indices assigned to compact identifiers can stay relatively small .Smaller number of indices results in improved average compactness and the efficiency of table operations .Each partition has a separate set of compact identifiers and content items are assigned to specific partitions as described below .", "label": "", "metadata": {}, "score": "61.605885"}
{"text": "User defined meta - data may be added to an EXI Options document just prior to the alignment option .Encoding EXI Streams .The rules for encoding a series of events as an EXI stream are very simple and are driven by a declarative set of grammars that describes the structure of an EXI stream .", "label": "", "metadata": {}, "score": "61.613308"}
{"text": "Here is another article making a similar argument for Swiss German .Both these articles seem to take a similar approach to the regular language process above where they user the closure properties of context - free grammars to generate a subset of a natural language then prove that that subset is non - context - free thus proving the full natural language is also non - context free .", "label": "", "metadata": {}, "score": "61.645798"}
{"text": "The rules used to represent values of String depend on the content items to which the values belong .There are certain content items whose value representation involve the use of string tables while other content items are represented using the encoding rule described in 7.1.10 String without involvement of string tables .", "label": "", "metadata": {}, "score": "61.748287"}
{"text": "This section describes the process for augmenting the normalized grammars when the value of the strict option is false .For each normalized element grammar Element i , create a copy Element i , content2 of Element i , content where the index \" content \" is the content of the type of the element from which Element i was created .", "label": "", "metadata": {}, "score": "61.86094"}
{"text": "Our grammars automatically learn the kinds of linguistic distinctions exhibited in previous work on manual tree annotation .On the other hand , our grammars are much more compact and substantially more accurate than previous work on automatic annotation .Despite its simplicity , our best grammar achieves an F1 of 89.9 % on the Penn Treebank , higher than most fully lexicalized systems .", "label": "", "metadata": {}, "score": "61.932854"}
{"text": "Note that AT(\"category \" ) is accepted before AT(\"date \" ) even though their order is reversed in the schema .This is because attributes in schema - informed grammars must be lexicographically sorted first by local name and then by namespace URI .", "label": "", "metadata": {}, "score": "61.94326"}
{"text": "7.3 String Table .EXI uses a string table to assign \" compact identifiers \" to some string values .Occurrences of string values found in the string table are represented using the associated compact identifier rather than encoding the entire \" string literal \" .", "label": "", "metadata": {}, "score": "62.021584"}
{"text": "EXI uses four different string table partitions to reflect the different uses of strings in the XML Infoset : .The table below shows EXI content items used in section 2.1.2 EXI Body to describe the content of EXI events and their mapping to Built - in Datatypes .", "label": "", "metadata": {}, "score": "62.04127"}
{"text": "7.3.3 Partitions Optimized for Frequent use of String Literals .The remaining string table partitions are optimized for the frequent use of string literals .This includes all string table partitions containing local - names and all string table partitions containing value content items .", "label": "", "metadata": {}, "score": "62.05655"}
{"text": "Your question is typically answered in a 1st course on Lie groups .Take a compact manifold $ M$ with a compact Lie group action $ G \\times M \\to M$. Then there exists an embedding of $ M$ in some Euclidean space , and a representation of $ G$ on that Euclidean space such that the inclusion $ M \\to", "label": "", "metadata": {}, "score": "62.170666"}
{"text": "When schema information is available to describe the contents of an EXI stream , the following grammar describes the events that will occur in an EXI document .The variable n in the grammar above is the number of global elements declared in the schema .", "label": "", "metadata": {}, "score": "62.508232"}
{"text": "As specified in section 8.3 Pruning Unneeded Productions , EXI processors MUST use these fidelity options to prune productions that match the associated events from the grammars , improving compactness and processing efficiency .The table below lists the fidelity options supported by this version of the EXI specification and describes the effect setting these options has on the EXI stream .", "label": "", "metadata": {}, "score": "62.657524"}
{"text": "[ parent ] .Computed based on the last SE event encountered that did not get a matching EE event type .B.6 Character Information item .A character information item maps to the individual characters contained in a Characters ( CH ) event following a SE event that did not get a matching EE event .", "label": "", "metadata": {}, "score": "62.79619"}
{"text": "Removing these productions from the grammar tells EXI processors that comments and processing instructions will never occur in the EXI stream , which reduces the entropy of the stream allowing it to be encoded in fewer bits .Each time a production is removed from a grammar , the event codes of the other productions with the same non - terminal symbol on the left - hand side MUST be adjusted to keep them contiguous if its removal has left the remaining productions with non - contiguous event codes . 8.4 Built - in XML Grammars .", "label": "", "metadata": {}, "score": "62.82531"}
{"text": "When xsi : type and/or xsi : nil attributes appear in an element where schema - informed grammars are in effect , they MUST occur before any other attribute events of the same element , with xsi : type placed before xsi : nil when they both occur .", "label": "", "metadata": {}, "score": "62.89081"}
{"text": "As another example , the following \" datatypeRepresentationMap \" element indicates all values of the used - defined simple type geo : geometricSurface and the datatypes derived from it by restriction are represented using the user - defined datatype representation geo : geometricInterpolator : .", "label": "", "metadata": {}, "score": "62.91881"}
{"text": "We obtain improvements of up to 1.4 BLEU on language pairs in the WMT 2010 shared task .For languages from different families the improvements often exceed 2 BLEU .Many of these gains are also significant in human evaluations .We present a new collection of treebanks with homogeneous syntactic dependency annotation for six languages : German , English , Swedish , Spanish , French and Korean .", "label": "", "metadata": {}, "score": "62.938572"}
{"text": "What constitutes a context in this case is more formally defined by an EXI grammar production in the next section .2.1.3 EXI Grammars .EXI is a knowledge based encoding that uses a set of grammars to determine which events are most likely to occur at any given point in an EXI stream and encodes the most likely alternatives in fewer bits .", "label": "", "metadata": {}, "score": "63.012074"}
{"text": "8.4.1 Built - in Document Grammar .In the absence of schema information describing the content of the EXI stream , the following grammar describes the events that will occur in an EXI document .In the absence of schema information describing the contents of an EXI stream , the following grammar describes the events that may occur in an EXI fragment .", "label": "", "metadata": {}, "score": "63.040955"}
{"text": "Like XML , the namespace of a particular element may be specified by a namespace declaration preceding the element or a local namespace declaration following the element name .When the namespace is specified by a local namespace declaration , the local - element - ns flag of the associated NS event is set to true and the prefix of the element is set to the prefix of that NS event .", "label": "", "metadata": {}, "score": "63.24858"}
{"text": "They are omitted in the example encodings to make the encoding description more articulate by focusing on the primary data and structure without being distracted by the frequent occurrence of indentation whitespaces . 3.3 Encoding without a schema .This section describes the encoding of EXI stream body when the sample XML document is transcoded into an EXI document in the absence of any schemas . \" ...", "label": "", "metadata": {}, "score": "63.306946"}
{"text": "Like an element , an attribute may occur in a schema - invalid context , have a untyped ( e.g. , schema - invalid ) value or both .However , unlike an element whose occurrence and value are represented by separate SE and CH events , the occurrence and value of an attribute are represented by a single AT event .", "label": "", "metadata": {}, "score": "63.32621"}
{"text": "Fryie Apr 11 ' 14 at 9:01 .The set of existing forms is not the set of all possible forms . -Kaz Nov 10 ' 15 at 15:37 .Then what is the set of all possible forms ?We can build nice theoretical models about what 's possible in a language and it 's all useful and such , but in the end , language is so dynamic and ever - changing that it does not represent reality all that well .", "label": "", "metadata": {}, "score": "63.3643"}
{"text": "Fixed errors in Table 7 - 1 by removing unnecessary associations that were found to have been causing an interoperability problem .Relaxed the format constraint that had required xsi : type attribute to occur before all other attributes .It is now legitimate that other attributes occur before xsi : type so long as that xsi : type would not have caused grammar switch if it appeared as the first attribute .", "label": "", "metadata": {}, "score": "63.545147"}
{"text": "EXI streams or extended EXI streams generated using schemas of such schema language are still conformant .Except where required for interoperability with limited computing platforms ( e.g , mobile and embedded devices ) , this specification avoids placing arbitrary limits on the magnitude of specific numeric values required for implementation .", "label": "", "metadata": {}, "score": "63.567604"}
{"text": "Given this regular language , we have only three choices for y : .y is all As .y is all Bs .y is a mixture of As and Bs .More generically , if y is all As and the number of times y appears can be variable then it 's impossible to ensure that there for exactly one fewer B than As .", "label": "", "metadata": {}, "score": "63.591927"}
{"text": "The base URI of the element information item .[ parent ] .Computed based on the last SE event encountered that did not get a matching EE event if any , or computed based on the SD event . B.3Attribute Information Item .", "label": "", "metadata": {}, "score": "63.605038"}
{"text": "Applications may use self - contained elements to index portions of the EXI body for random access .The representation of event codes which identify the event type and start each event is described in 6.2 Representing Event Codes .Each item in the event content has a datatype representation associated with it as shown in the following table .", "label": "", "metadata": {}, "score": "63.891117"}
{"text": "When a string value is found in the global or \" local \" partition , it is represented using a compact identifier .When a string value is found in the global value partition , the String value may be represented as one ( 1 ) encoded as an Unsigned Integer ( see 7.1.6 Unsigned Integer ) followed by the compact identifier of the String value in the global value partition .", "label": "", "metadata": {}, "score": "64.07643"}
{"text": "Element and attribute values are grouped according to their qualified names while structure information like Event Codes is combined .To keep compression overhead at a minimum , smaller QName channels are combined while larger channels are compressed separately .The figure above uses grey buckets for structure information and colored buckets for content information .", "label": "", "metadata": {}, "score": "64.09784"}
{"text": "Indeed , proving this theory for groupoids is very hard and there are many issues to take care of .Groupoids behave differently than groups .For example , a locally compact Hausdorff groupoid need not carry an invariant continuous family of measures .", "label": "", "metadata": {}, "score": "64.10827"}
{"text": "Let me elaborate on my comment above .Suppose $ M$ is a manifold equipped with a smooth $ \\Bbb Z_2 $ action that is also free .Then there is an equivariant smooth embedding $ M \\to S^j$ , for some $ j$ , where we give the sphere the antipodal action .", "label": "", "metadata": {}, "score": "64.187294"}
{"text": "Let Type k and TypeEmpty k be the type grammars created from T k ( see section 8.5.4.1.3 Type Grammars ) .Add the following productions to Element i .When xsi : type and/or xsi : nil attributes appear in an element where schema - informed grammars are in effect , they MUST occur before any other attribute events of the same element , with xsi : type placed before xsi : nil when they both occur .", "label": "", "metadata": {}, "score": "64.2167"}
{"text": "Not all Lie groups admit discrete series , and even for those that do , most unitary irreps . are not discrete series . ) - Emerton Dec 23 ' 10 at 1:20 .2 Answers 2 .I 'm not quite sure if this is the answer that you looking for but anyway he we go .", "label": "", "metadata": {}, "score": "64.24809"}
{"text": "Table B-9 .Mapping of the unparsed entity information item properties to EXI event types .Computed based on text content item of DT .[ public identifier ] .Computed based on text content item of DT .[ declaration base URI ] .", "label": "", "metadata": {}, "score": "64.35295"}
{"text": "The development of the Efficient XML Interchange ( EXI ) format was guided by five design principles , namely , the format had to be general , minimal , efficient , flexible , and interoperable .The format satisfies these prerequisites , achieving generality , flexibility , and performance while at the same time keeping complexity in check .", "label": "", "metadata": {}, "score": "64.40901"}
{"text": "For datatype representations of other qnames , EXI does not provide nor suggest a method by which they are identified and shared between EXI Processors .This suggests that the use of user - defined ( i.e. custom ) datatype representations needs to be restrained by weighing alternatives and considering the consequences of each in pros and cons , in order to avoid unruly proliferation of documents that use such datatype representations .", "label": "", "metadata": {}, "score": "64.48811"}
{"text": "EXI can use additional computational resources to achieve higher compaction .Instead of compressing the entire stream EXI combines the knowledge of XML and the application of a standard compression algorithm .Homogeneous data is combined and fed separately to the compression engine .", "label": "", "metadata": {}, "score": "64.54438"}
{"text": "In addition , the table includes the grammar notation used to represent each event in this specification .Each event in an EXI stream participates in a mapping system that relates events to XML Information Items so that an EXI document or an EXI fragment as a whole serves to represent an XML Information Set .", "label": "", "metadata": {}, "score": "64.57707"}
{"text": "The bindings shown below are assumed , however , any prefixes can be used in practice if they are properly bound to the namespaces .In describing the layout of an EXI format construct , a pair of square brackets [ ] are used to surround the name of a field to denote that the occurrence of the field is optional in the structure of the part or component that contains the field .", "label": "", "metadata": {}, "score": "64.610886"}
{"text": "This section describes the process for creating an EXI type grammar from an XML Schema complex type definition XS1 .Each uri x is used to augment the uri partition of the String table .Section 7.3.1 String Table Partitions describes how these uri strings are put into String table for pre - population .", "label": "", "metadata": {}, "score": "64.76657"}
{"text": "Like Alessandro , I was worried about which double cover one would lift to , but I think Martin 's comment about bringing in the classifying space of $ Z/2Z$ cleared that up . -ARupinski Jan 26 ' 11 at 21:47 I am looking for matrix representation of Tits group $ ^2F_4(2)'$ of size 17 971 200 .", "label": "", "metadata": {}, "score": "64.79396"}
{"text": "In cases where prefixes are not relevant , such as in the grammar notation , they are not specified by this document .The forms of terminal symbols involving qname wildcards used in grammars and their definitions are described in the table below .", "label": "", "metadata": {}, "score": "64.89614"}
{"text": "Finally , the grammar for the element is created based on the grammars of its attribute uses and content model particle as follows .See section 8.5.4.1.3.2 Complex Type Grammars for the rules used to generate grammars for complex types .See section 8.5.4.1.5 Particles for the rules used to generate grammars for particles .", "label": "", "metadata": {}, "score": "65.120384"}
{"text": "Table B-3 .Mapping of the attribute information item properties to EXI event types .AT .[ normalized value ] .The value of AT .[ specified ] .True if the item maps to AT , otherwise false .", "label": "", "metadata": {}, "score": "65.23636"}
{"text": "Such EXI processors are typically used in controlled systems where the knowledge about the effective EXI Options is shared prior to the exchange of EXI streams .The mechanisms to communicate out - of - band EXI Options and their representation are implementation dependent .", "label": "", "metadata": {}, "score": "65.25401"}
{"text": "F m -1 represent these qnames sorted lexicographically , first by local - name , then by uri .If there is more than one element declared with the same qname , the qname is included only once .Otherwise , their content is evaluated according to the relaxed Element Fragment grammar described above .", "label": "", "metadata": {}, "score": "65.319534"}
{"text": "E ' . 'X ' . 'I ' .This four byte sequence is particular to EXI and specific enough to distinguish EXI streams from a broad range of data types currently used on the Web .5.2 Distinguishing Bits .", "label": "", "metadata": {}, "score": "65.399445"}
{"text": "Mapping of the character information item properties and the EXI event types .Property .EXI event types .[ character code ] .Each character in CH .[ element content whitespace ] .Computed based on [ parent ] and DT .", "label": "", "metadata": {}, "score": "65.45646"}
{"text": "APPL .Consideration of alternatives : . Person & email address to contact for further information : .World Wide Web Consortium .Intended usage : . COMMON .Restrictions on usage : . none .Author / Change controller : .", "label": "", "metadata": {}, "score": "65.5061"}
{"text": "The penalty for a recognition failure is often small : if two con- figurations are confused , they are often similar to each other , and the illusion works well enough , for instance , to drive a graphics animation of the moving hand .", "label": "", "metadata": {}, "score": "65.63254"}
{"text": "[ Definition : ] Type i is a global type grammar when T i is a named type .TypeEmpty i is used in place of Type i when the element instance that is being evaluated has a xsi : nil attribute with the value true .", "label": "", "metadata": {}, "score": "65.65261"}
{"text": "The following table lists the entries that are initially populated in uri partitions , where partition name URI denotes that they are entries in the uri partition .Additionally , when XML Schemas are used , the uri partition is also pre - populated with some of the namespace URIs used in the schemas .", "label": "", "metadata": {}, "score": "65.68916"}
{"text": "This section describes the process for creating the EXI proto - grammars from XML Schema declarations and definitions .EXI proto - grammars differ from normalized EXI grammars in that they may contain productions of the form : . where LeftHandSide and RightHandSide are both non - terminals .", "label": "", "metadata": {}, "score": "65.800674"}
{"text": "Event codes in an EXI grammar are assigned to productions in such a way that shorter event codes are used to represent more likely to occur productions .Conversely , longer event codes are used to represent less likely to occur productions .", "label": "", "metadata": {}, "score": "65.806564"}
{"text": "Attribute and Character content - values are assigned to this partition .The figure above illustrates that value content items can be referenced in two different ways , namely as \" global \" and \" local \" value .When a string value is neither found in the global nor in the local value section its string literal is encoded as String and the string value is added to both , the associated local and the global string index .", "label": "", "metadata": {}, "score": "65.9109"}
{"text": "We call this the event code tree for a given set of productions .An event code tree is similar to a Huffman tree [ Huffman Coding ] in that shorter paths are generally used for symbols that are considered more likely .", "label": "", "metadata": {}, "score": "65.92719"}
{"text": "Section 8.5 Schema - informed Grammars describes the system to derive schema - informed grammars from XML Schemas .[ Definition : ] The alignment option value bit - packed indicates that the event codes and associated content are packed in bits without any padding in - between .", "label": "", "metadata": {}, "score": "65.97902"}
{"text": "The structure of an EXI header is depicted in the following figure .Note that even though EXI is a bit aligned format , the header is padded to the next byte to support fast header interpretation .Table 2 - 2 .", "label": "", "metadata": {}, "score": "66.18617"}
{"text": "The content of the entire element is described by the first non - terminal Element i , 0 .The remaining non - terminals describe portions of the element content .Likewise , each type grammar Type i includes a sequence of n non - terminals Type i , j and the content of the entire type is described by the first non - terminal Type i , 0 .", "label": "", "metadata": {}, "score": "66.21889"}
{"text": "If I am right , then Turkish morphology is at least theoretically arbitrarily embedded .-Colin Fine Feb 5 ' 13 at 14:56 . -cyco130 Apr 10 ' 14 at 9:54 .This is the extra dimension you get in languages which do n't indicate word breaks in their orthography .", "label": "", "metadata": {}, "score": "66.259056"}
{"text": "Unlike the optional EXI cookie that MAY occur to precede this field , the presence of Distinguishing Bits is REQUIRED in the EXI header .It is used to distinguish EXI streams from text XML documents in the absence of an EXI cookie .", "label": "", "metadata": {}, "score": "66.331604"}
{"text": "The fidelity options introduced in Section 2.1.1 EXI Header may be used to prune EXI events like NS , CM , PI , DT ( DocType ) or ER ( Entity Reference ) .Grammar pruning simplifies the encoding and decoding process and also improves compactness by filtering out unused event types .", "label": "", "metadata": {}, "score": "66.377365"}
{"text": "- Tyler Lawson Feb 26 ' 10 at 13:21 .Further assumptions that $ X$ is quasi compact and quasi separated .And then we use the Beck 's theorem for comonad . -Shizhuo ZhangFeb 27 ' 10 at 10:31 .", "label": "", "metadata": {}, "score": "66.45087"}
{"text": "When a xsi : type attribute appears in an element where the built - in element grammar is in effect , it MUST occur before any other AT events of the same element unless it is known that xsi : type attribute will not impact grammar selection .", "label": "", "metadata": {}, "score": "66.53959"}
{"text": "Partitions containing value content items are optimized for frequent use of string literals and are initially empty .[ Definition : ] The variable globalID is a non - negative integer representing the compact identifier of the next item added to the global value partition .", "label": "", "metadata": {}, "score": "66.584885"}
{"text": "EXI is schema \" informed \" , meaning that it can utilize available schema information to improve compactness and performance , but does not depend on accurate , complete or current schemas to work .It supports arbitrary schema extensions and deviations and also works very effectively with partial schemas or in the absence of any schema .", "label": "", "metadata": {}, "score": "66.65101"}
{"text": "Just to say that YBL 's apparent statement of the van Kampen theorem involves products and needs to be modified !I got into groupoids in the 1960s through being annoyed that the usual van Kampen theorem as formulated by Crowell could not compute the fundamental group of a basic exmple in topology , the unit circle !", "label": "", "metadata": {}, "score": "66.67283"}
{"text": "Unless stated otherwise , when this specification indicates one type is derived from another type , it means the type is derived by extension or restriction , not by union or list .Similarly , when this specification uses the term type hierarchy , it is referring to the hierarchy of types derived from one another by extension or restriction .", "label": "", "metadata": {}, "score": "66.77286"}
{"text": "The datatype representation used for each value content item depends on the schema datatype XS2 if any that is in effect for that value .The String datatype representation ( see 7.1.10 String ) is used for values that do not have an associated schema datatype , can not be or are opted not to be represented by their associated datatype representations , or occur in mixed content .", "label": "", "metadata": {}, "score": "66.793076"}
{"text": "Published specification : .Efficient XML Interchange ( EXI )Format 1.0 , World Wide Web Consortium .Applications that use this media type : .No known applications currently use this media type .Additional information : .Magic number(s ) : .", "label": "", "metadata": {}, "score": "66.856674"}
{"text": "The content index of grammar Type i created from an XML Schema complex type definition is the index of the first non - terminal symbol of Content i within the context of Type i .When schemas are available to describe the body of an EXI stream , create grammars Type ur - type and TypeEmpty ur - type that are used to process the element contents of type xsd : anyType XS1", "label": "", "metadata": {}, "score": "66.95117"}
{"text": "Section 7.3 String Table describes the string table and how it is applied to different content items .7.1.10.1 Restricted Character Sets .If a string value is associated with a schema datatype XS2 derived from xsd : string and one or more of the datatypes in its datatype hierarchy has one or more pattern facets , there may be a restricted character set defined for the string value .", "label": "", "metadata": {}, "score": "67.00083"}
{"text": "The measurements results and analyses , are presented elsewhere [ EXI Measurements Note ] .The format described in this document is the specification so recommended .The functional requirements of the EXI format are those that were prepared by the XBC WG in their analysis of the desirable properties of a high performance representation for XML [ XBC Properties ] .", "label": "", "metadata": {}, "score": "67.1391"}
{"text": "ElementFragment is a grammar that accounts both element declarations and attribute declarations in the schemas , whereas ElementFragmentTypeEmpty is a grammar that regards only attribute declarations .The variable n in the grammar above represents the number of unique qnames given to explicitly declared attributes in the schema .", "label": "", "metadata": {}, "score": "67.18029"}
{"text": "You need to start by a map from $ N\\to \\mathbb R P^\\infty$ classifying the double cover $ M\\to N$. - Martin O Jan 26 ' 11 at 21:33 .Thanks Martin , I thought that the starting point was a \" random \" embedding . -", "label": "", "metadata": {}, "score": "67.254425"}
{"text": "The \" strict \" element MUST NOT appear in an EXI options document when one of \" dtd \" , \" prefixes \" , \" comments \" , \" pis \" or \" selfContained \" element is present in the same options document .", "label": "", "metadata": {}, "score": "67.32168"}
{"text": "SE .[ prefix ] .SE .[ children ] .[ attributes ] .[ namespace attributes ] .[ in - scope namespaces ] .The namespace information items computed using the [ namespace attributes ] properties of this information item and its ancestors .", "label": "", "metadata": {}, "score": "67.37085"}
{"text": "The associated semantics explain how the built - in fragment grammar evolves to more efficiently represent subsequent events in the EXI stream .All productions of the form LeftHandSide : SE ( qname ) RightHandSide that were previously added to the grammar upon the first occurrence of the element that has the qname qname are evaluated as follows when they are matched : .", "label": "", "metadata": {}, "score": "67.37917"}
{"text": "- pasquale zito Feb 26 ' 10 at 15:36 .Let me clarify .What I said is only true in the discrete setting , i.e. no topology at all .I was assuming that this was the case the original question was about .", "label": "", "metadata": {}, "score": "67.39559"}
{"text": "String Table .String tables are used in memory - sensitive areas allowing a compact representation of repeating string values .Re- occurring string values are represented using an associated compact identifier rather than encoding the string literally again .When a string value is found in the string table ( string table hit ) the value is encoded using a compact identifier .", "label": "", "metadata": {}, "score": "67.41547"}
{"text": "Encoding EXI Streams and 8.4.3 Built - in Element Grammar ) .Clarified that the derivation methods \" extension \" or \" restriction \" are indicated ( but not \" list \" or \" union \" ) when this specification mentions one type is derived from another or refers to the notion of type hierarchy .", "label": "", "metadata": {}, "score": "67.47591"}
{"text": "Both partitions are initially pre - populated with likely entries ( see figure below ) .The partitions are further subdivided in sections according to the associated namespace URI .In our notebook example no prefixes are used and the default namespace URI ( \" \" [ empty - string ] ) is in charge .", "label": "", "metadata": {}, "score": "67.492325"}
{"text": "While byte - alignment generally results in EXI streams of larger sizes compared with their bit - packed equivalents , byte - alignment may provide a help in some use cases that involve frequent copying of large arrays of scalar data directly out of the stream .", "label": "", "metadata": {}, "score": "67.50816"}
{"text": "More generally , suppose $ G$ is a finite group acting freely and smoothly on $ M$. Suppose $ V$ is a free orthogonal $ G$-representation .Then the above can be generalized to show that there is an equivariant smooth embedding from $ M$ into $ S(jV)$ where the latter is the unit sphere of $ j$-copies of $ V$ , $ j$ large .", "label": "", "metadata": {}, "score": "67.57381"}
{"text": "In this case , the unresolved prefix representation is not used and can be zero ( 0 ) or the compact identifier of any prefix in the associated partition .Note : .When N is one , the prefix is represented using zero bits ( i.e. omitted ) .", "label": "", "metadata": {}, "score": "67.70854"}
{"text": "Systems that use EXI streams as well as XML documents can reliably look at the Distinguishing Bits to determine whether to interpret a particular stream as XML or EXI .5.3 EXI Format Version .[ Definition : ] The fourth part in the EXI header is the EXI Format Version , which identifies the version of the EXI format being used .", "label": "", "metadata": {}, "score": "67.73299"}
{"text": "Section 9.2 Channels defines channels , their organization as well as how a group of channels correlate to its corresponding block of events .Section 9.3 Compressed Streams describes how some channels are combined as needed in preparation for applying compression algorithms on channels .", "label": "", "metadata": {}, "score": "67.742226"}
{"text": "8.5.4.1.5 Particles . indicating these instances of Term 0 may be omitted from the content model .Then , create the grammar for Particle i using the grammar concatenation operator defined in section 8.5.4.1.1 Grammar Concatenation Operator as follows : .Then , create the grammar for Particle i using the grammar concatenation operator defined in section 8.5.4.1.1 Grammar Concatenation Operator as follows : .", "label": "", "metadata": {}, "score": "67.74348"}
{"text": "The local - name portion of qname content items are assigned to partitions based on the namespace URI of the qname content item of which the local - name is a part .Partitions containing local - names are optimized for frequent use of string literals and the string table is pre - populated with entries as described in D.3 Initial Entries in Local - Name Partitions .", "label": "", "metadata": {}, "score": "67.74357"}
{"text": "This permits it to encapsulate an efficient alternative syntax and grammar for XML , while facilitating at least the potential for minimizing the impact on XML application interoperability . 1.2 Notational Conventions and Terminology .The key words MUST , MUST NOT , REQUIRED , SHALL , SHALL NOT , SHOULD , SHOULD NOT , RECOMMENDED , MAY , and OPTIONAL , when they appear EMPHASIZED in this document , are to be interpreted as described in RFC 2119 [ IETF RFC 2119 ] .", "label": "", "metadata": {}, "score": "67.76978"}
{"text": "The following table lists the mapping between XML Schema Types and Built - in Types in EXI .The datatype QName is used for structure coding only , such as qualified names for XML elements and attributes .The interested reader is referred to the EXI specification which describes in details the encoding rules for representing built - in EXI datatypes .", "label": "", "metadata": {}, "score": "67.77063"}
{"text": "The mechanism to determine whether channels are combined or compressed separately is guided by the number of value content items present in the EXI stream .The reader is referred to the EXI specification for further details .The notebook example falls in the first category and is encoded as a single compressed deflate stream containing first the structure channel , followed by the QName channels in the order they appear in the document ( date , category , subject , body ) .", "label": "", "metadata": {}, "score": "67.77748"}
{"text": "The Date - Time datatype representation is a sequence of values representing the individual components of the Date - Time .The following table specifies each of the possible date - time components along with how they are encoded .The variety of components that constitute a value and their appearance order depend on the XML Schema type associated with the value .", "label": "", "metadata": {}, "score": "67.82194"}
{"text": "Now the notion of \" occur in \" that you mention seems to be the notion of strong containment .So it now seems that you are asking when does the left regular rep ( $ L^2(G)$ ) strongly contain all irreducibles .", "label": "", "metadata": {}, "score": "67.86397"}
{"text": "EXI grammars are regular grammars in which productions are associated with event codes .An EXI encoder , driven by an XML event stream , matches grammar productions and uses their associated event codes to represent an XML document or XML fragment .", "label": "", "metadata": {}, "score": "67.89972"}
{"text": "By this is mean endow $ B(H)$ , the bounded operators on a hilbert space $ H$ with the topology of point - wise norm convergence .And only consider reps $ \\pi : G\\rightarrow B(H)$ that are continuous with this topology .", "label": "", "metadata": {}, "score": "67.94123"}
{"text": "Implementers are free to coordinate to achieve interoperability between different preview versions of the EXI format .Following the first bit of the version is a sequence of one or more 4-bit unsigned integers representing the version number .The version number is determined by summing this sequence of 4-bit unsigned values and adding 1 ( one ) .", "label": "", "metadata": {}, "score": "68.003174"}
{"text": "A document information item maps to a pair of Start Document ( SD ) and End Document ( ED ) events with each of its properties subject to further mapping as shown in the following table .Table B-1 .Mapping between the document information item properties to EXI event types .", "label": "", "metadata": {}, "score": "68.02043"}
{"text": "The set - of - chars for a charClass that constitutes an atom is the set of characters specified by the charClass expression XS2 .The set - of - chars for a regExp sub - expression enclosed in parenthesis that constitutes an atom is the set - of - chars for the regExp itself derived by recursively applying the rule defined above .", "label": "", "metadata": {}, "score": "68.11925"}
{"text": "As such , the first 15 version numbers are represented by 4 bits , the next 15 are represented by 8 bits , etc . .Given an EXI stream with its stream cursor positioned just past the first bit of the EXI format version field , the EXI format version number can be computed by going through the following steps with version number initially set to 1 .", "label": "", "metadata": {}, "score": "68.34621"}
{"text": "Given the sorted list of productions P 0 , P 1 , ... P n with the non - terminal G i , j on the left - hand side , assign event codes to each of the productions as follows : .", "label": "", "metadata": {}, "score": "68.45229"}
{"text": "Mapping of the notation information item properties to EXI event types .EXI event types .[ name ] .Computed based on text content item of DT .[ system identifier ] .Computed based on text content item of DT .", "label": "", "metadata": {}, "score": "68.522804"}
{"text": "[ system identifier ] .DT .[ public identifier ] .DT .[ children ] .Computed based on text content item of DT .[ parent ] .Computed based on the SD event .B.9 Unparsed Entity Information Item .", "label": "", "metadata": {}, "score": "68.638405"}
{"text": "Note : .EXI compression changes the order in which event codes and value s are read and written to and from an EXI stream .EXI processors must encode and decode value s in this revised order so order sensitive constructs like the string table ( see 7.3 String Table ) work properly .", "label": "", "metadata": {}, "score": "68.70498"}
{"text": "Even though EXI utilizes schema information to improve compactness and processing efficiency , it does not depend on accurate , complete or current schemas to work .2.1 EXI Streams .EXI streams are the basic structure of EXI documents .As shown below , an EXI stream consists of an EXI header followed by an EXI body .", "label": "", "metadata": {}, "score": "68.81639"}
{"text": "I think nobody questions that syntax can not be described by finite - state automata .-Fryie Feb 3 ' 13 at 2:32 . @Fryie Fair enough .Also , In morphologically rich languages like Korean , inflections and morphological grammatical markers can not be pumped indefinitely , thus failing pumping lemma . - acattle Feb 3 ' 13 at 5:16 .", "label": "", "metadata": {}, "score": "68.8988"}
{"text": "( see 6.3 Fidelity Options ) .The prefix string table partitions are made use of in the encoding of the prefix component of QName .( see 7.1.7 QName ) .Changed the default value of schemaId , datatypeRepresentationMap and [ user defined meta - data ] options to \" no default value \" in Table 5 - 1 .", "label": "", "metadata": {}, "score": "68.958664"}
{"text": "Otherwise , when the value of the alignment option is set to pre - compression , each compressed stream in a block is stored directly without the DEFLATE algorithm .Note : .Some EXI events have zero - byte representations and are not explicitly represented in the EXI stream .", "label": "", "metadata": {}, "score": "68.966194"}
{"text": "I.e. if no pumping lemma can be found for a given language it can not be regular but the existence of a valid pumping lemma does not prove the language is regular .Testing English for Irregularity .Remember that the intersection of two regular languages is also regular .", "label": "", "metadata": {}, "score": "69.11517"}
{"text": "Publication as a Proposed Recommendation does not imply endorsement by the W3C Membership .This is a draft document and may be updated , replaced or obsoleted by other documents at any time .It is inappropriate to cite this document as other than work in progress .", "label": "", "metadata": {}, "score": "69.163086"}
{"text": "Then create the grammar ParticleTerm i with the following grammar productions : .Each uri x is used to augment the uri partition of the String table .Section 7.3.1 String Table Partitions describes how these uri strings are put into String table for pre - population .", "label": "", "metadata": {}, "score": "69.17288"}
{"text": "The value \" 2007 - 09 - 12 \" appears twice in the date context .The second occurrence results in a local value hit and is respectively encoded as a 1 bit compact identifier .On the other side , if a string value is not found in the local section , but is found in the global section , the corresponding global compact identifier is used .", "label": "", "metadata": {}, "score": "69.230835"}
{"text": "When the value of compression option is true , or either byte - alignment or pre - compression alignment option is used , n -bit unsigned integers are represented using the minimum number of bytes required to store n bits .The second table below illustrates how the event codes of each event matched by the DocContent grammar above are represented in this case .", "label": "", "metadata": {}, "score": "69.307495"}
{"text": "For example , the EXI processor MAY reject such a stream outright or it MAY attempt to process the EXI body .Preview versions of the EXI format are useful for gaining implementation and deployment experience prior to finalizing a particular version of the EXI format .", "label": "", "metadata": {}, "score": "69.37263"}
{"text": "EXI event types .[ children ] .[ SE , EE ] .[ document element ] .[ SE , EE ] .[ notations ] .Computed based on text content item of DT to which each notation information set item maps .", "label": "", "metadata": {}, "score": "69.388824"}
{"text": "Appendix B Infoset Mapping describes the mapping system in detail .Section 6 .Encoding EXI Streams describes the algorithm used to encode events in the EXI stream .As indicated in the table above , there are some event types that carry content with their event instances while other event types function as markers without content .", "label": "", "metadata": {}, "score": "69.39549"}
{"text": "The Integer datatype representation supports signed integer numbers of arbitrary magnitude .The specific representation used depends on the facet XS2 values of the associated schema datatype XS2 as follows .Otherwise , if the associated schema datatype is derived from xsd : integer and the minInclusive XS2 or minExclusive XS2 facets specify a lower bound greater than or equal to zero ( 0 ) , the value is represented as an Unsigned Integer .", "label": "", "metadata": {}, "score": "69.41326"}
{"text": "Behavior Control : Finally we show how all these elements can be incorporated into a goal keeping robot .We develop simple behaviors that can be used in a layered architecture and enable the robot to block most balls that are being shot at the goal .", "label": "", "metadata": {}, "score": "69.45843"}
{"text": "If a global attribute definition exists for qname , let global - type be the datatype of the global attribute .If the attribute value can be represented using the datatype representation associated with global - type , it SHOULD be represented using the datatype representation associated with global - type ( see 7 .", "label": "", "metadata": {}, "score": "69.54555"}
{"text": "If a global attribute definition exists for qname , let global - type be the datatype of the global attribute .If the attribute value can be represented using the datatype representation associated with global - type , it SHOULD be represented using the datatype representation associated with global - type ( see 7 .", "label": "", "metadata": {}, "score": "69.54555"}
{"text": "The default value \" unbounded \" is assumed when the \" valueMaxLength \" element is absent in the EXI Options document .[ Definition : ] The user defined meta - data conveys auxiliary information that applications may use to facilitate interpretation of the EXI stream .", "label": "", "metadata": {}, "score": "69.60609"}
{"text": "The overhead introduced by the EXI options is comparatively small given that they are formally described using an XML schema and can therefore be encoded using EXI as well .The following table describes the EXI options that can be specified in the EXI header .", "label": "", "metadata": {}, "score": "69.65827"}
{"text": "When a string value is not found in the partitions containing local - names , its string literal is encoded as a String ( see 7.1.10 String ) with the length of the string incremented by one .After encoding the string value , it is added to the string table partition and assigned the next available compact identifier m .", "label": "", "metadata": {}, "score": "69.70311"}
{"text": "For example , the SOAP 1.2 specification [ SOAP 1.2 ] prohibits the use of XML processing instructions .In addition , there are many data - exchange use cases that do not require XML comments or DTDs .The preserve option in EXI Options comprises a set of fidelity options , each of which independently enables or disables the format 's capacity for the preservation ( or preservation level ) of a certain type of information item .", "label": "", "metadata": {}, "score": "69.721146"}
{"text": "Otherwise , URI and local - name components are encoded as Strings .If the QName is in no namespace , the URI is represented by a zero length String .If the given prefix exists in the associated prefix string table partition , it is represented using the compact identifier assigned by the partition .", "label": "", "metadata": {}, "score": "69.76548"}
{"text": "all productions with SE ( qname ) on the right - hand side sorted in schema order , followed by .any production with EE on the right - hand side , followed by .any production with CH on the right - hand side .", "label": "", "metadata": {}, "score": "69.84454"}
{"text": "( see 8.5.3 Schema - informed Element Fragment Grammar ) .In appendix section E Deriving Set of Characters from XML Schema Regular Expressions , the terms \" character set \" and \" charset \" have been rephrased as \" set of characters \" and \" set - of - chars \" , respectively .", "label": "", "metadata": {}, "score": "69.922165"}
{"text": "Multiply the value of the unsigned number represented by the 7 least significant bits of the octet by the current multiplier and add the result to the current value .The QName datatype representation is a sequence of values representing the URI , local - name and prefix components of the QName in that order , where the prefix component is present only when the Preserve.prefixes option is set to true .", "label": "", "metadata": {}, "score": "69.987885"}
{"text": "For example , an element with no schema information is encoded according to the XML grammar defined by the XML specification , while an element with schema information is encoded according to the more specific grammar defined by that schema .[ Definition : ] An event code is a sequence of 1 to 3 non - negative integers called parts used to identify each event in an EXI stream .", "label": "", "metadata": {}, "score": "70.27092"}
{"text": "The first octet after these , or the first octet of the whole content if they are not present , has its high two bits set to values 1 and 0 in that order .File extension(s ) : . exi .", "label": "", "metadata": {}, "score": "70.428024"}
{"text": "String tables are not represented in an EXI stream or exchanged between EXI processors .A string table can not be reused across multiple EXI streams ; therefore , EXI processors MUST use a string table that is equivalent to the one that would have been newly created and pre - populated with initial values for processing each EXI stream .", "label": "", "metadata": {}, "score": "70.44588"}
{"text": "F.2 Internet Media Type .A new media type registration \" application / exi \" described below is being proposed for community review , with the intent to eventually submit it to the IESG for review , approval , and registration with IANA . application .", "label": "", "metadata": {}, "score": "70.5072"}
{"text": "And the remaining compressed streams each contain only one channel , each having more than 100 values .The order of the value channels within the second compressed stream is defined by the order in which the first value in each channel occurs in the EXI event sequence .", "label": "", "metadata": {}, "score": "70.566414"}
{"text": "[ Definition : ] The alignment option value pre - compression indicates that all steps involved in compression ( see section 9 .EXI Compression ) are to be done with the exception of the final step of applying the DEFLATE algorithm .", "label": "", "metadata": {}, "score": "70.7409"}
{"text": "We present a new edition of the Google Books Ngram Corpus , which describes how often words and phrases were used over a period of five centuries , in eight languages ; it reflects 6 % of all books ever published .", "label": "", "metadata": {}, "score": "70.77524"}
{"text": "A QName is in error if its prefix can not be resolved by the rules below .If the prefix string table partition associated with the URI of the QName assigns the compact identifier m to a prefix value , select this prefix value as the candidate prefix value .", "label": "", "metadata": {}, "score": "70.79526"}
{"text": "Complex Ur - Type Grammar ) .Removed the paragraph that described the processor conformance defining the minimal value range required of blockSize option support .( see 10.2 EXI Processor Conformance ) .It was made clear that the datatypeRepresentationMap option does not take effect when the value of the Preserve.lexicalValues fidelity option is true .", "label": "", "metadata": {}, "score": "71.02359"}
{"text": "Note : .The content index of grammar TypeEmpty i is the index of its last non - terminal symbol .The grammar Type i is generated as follows .The value of each Characters event that has an [ untyped value ] is represented as a String ( see 7.1.10 String ) .", "label": "", "metadata": {}, "score": "71.0238"}
{"text": "So for the usual embedding of a Klein bottle into $ \\mathbb R^3 $ , at the circle of self - intersection , each sheet still retains its two dimensional character .So it is an immersion .If you were to instead map the Klein bottle into $ \\mathbb R^3 $ by mapping everything to a point , that would not be an immersion .", "label": "", "metadata": {}, "score": "71.07774"}
{"text": "Those additional notations facilitate concise representation of the EXI grammar system .[ Definition : ] In this document , the term qname is used to denote a QName XS2 .QName values are composed of an uri , a local - name and an optional prefix .", "label": "", "metadata": {}, "score": "71.15782"}
{"text": "The EXI stream encoder uses the grammar to map a stream of XML information items onto a smaller , lower entropy , stream of events .The EXI stream encoder then represents the stream of events using a set of simple variable length codes called event codes .", "label": "", "metadata": {}, "score": "71.19716"}
{"text": "The EXI grammar incorporates knowledge of the XML grammar and may be augmented and refined using schema information and fidelity options .The EXI grammar is formally specified in section 8 .EXI Grammars .The following table summarizes the EXI event types and associated event content that occur in an EXI stream .", "label": "", "metadata": {}, "score": "71.27691"}
{"text": "EXI processors MAY also provide implementation specific means for applications or users to specify alternate built - in EXI datatype representations or user - defined datatype representations for representing specific schema datatypes .As with the default EXI datatype representations , alternate datatype representations are used for the associated XML Schema types specified in the Datatype Representation Map and XML Schema datatypes derived from those datatypes .", "label": "", "metadata": {}, "score": "71.27964"}
{"text": "For example , a value of XML Schema datatype xsd : int is represented according to the same built - in EXI datatype representation as a value of XML Schema datatype xsd : integer .When the Preserve.lexicalValues option is true , all values are represented as Strings .", "label": "", "metadata": {}, "score": "71.28964"}
{"text": "Computed based on AT and DT .[ references ] .Computed based on [ attribute type ] and value of AT .[ owner element ] .Computed based on the last SE event encountered that did not get a matching EE event .", "label": "", "metadata": {}, "score": "71.318085"}
{"text": "The series of NS events associated with a particular element may include at most one NS event with its local - element - ns flag set to true .The uri of a NS event with its local - element - ns flag set to true MUST match the uri of the associated SE event .", "label": "", "metadata": {}, "score": "71.331985"}
{"text": "The value of each xsi : type attribute is stored in the structure channel .These attribute events are intrinsic to the grammar system thus are essential in processing the structure channel because their values affect the grammar to be used for processing the rest of the elements on which they appear .", "label": "", "metadata": {}, "score": "71.35921"}
{"text": "An alignment phase creates a byte - aligned representation of event codes and content items that is more amenable to compression algorithms compared to unaligned representations .Most compression algorithms operate on a series of bytes to identify redundancies in the octets .", "label": "", "metadata": {}, "score": "71.39231"}
{"text": "Distinguishing Bits .Presence Bit for EXI Options .EXI Format Version .EXI Options .[ Padding Bits ] .The EXI header , and hence every EXI document , starts with a pair of Distinguishing Bits that can be used to recognize an EXI document from a textual XML document .", "label": "", "metadata": {}, "score": "71.395966"}
{"text": "Representing Event Content .If a grammar can be found for the target - type type using the encoded target - type representation , evaluate the element contents using the grammar for target - type type instead of RightHandSide .The production of the form LeftHandSide : AT ( xsi : type ) RightHandSide that was previously added to the grammar upon the first occurrence of the xsi : type attribute is evaluated as follows when it is matched : .", "label": "", "metadata": {}, "score": "71.45373"}
{"text": "Representing Event Content describes how each of the types listed above are encoded in an EXI stream .Note : .The syntax and semantics of the NS event are designed to minimize the overhead required for representing namespace prefixes in EXI streams without introducing significant complexity .", "label": "", "metadata": {}, "score": "71.51062"}
{"text": "However , there are additional events that may occur in an EXI stream that are not described by the schema , for example events representing comments , processing - instructions , schema deviations , etc . .This section first describes the process for , in cases with strict option value set to false , augmenting the normalized element and type grammars with productions that describe events that may occur in the EXI stream , but are not explicitly declared in the schema .", "label": "", "metadata": {}, "score": "71.55039"}
{"text": "All string values in uri partition are unique .D.2 Initial Entries in Prefix Partitions .Additionally , when a schema is provided , the string table is also pre - populated with the local - name of each attribute , element and type explicitly declared in the schema , partitioned by namespace URI .", "label": "", "metadata": {}, "score": "71.584"}
{"text": "Computed based on text content item of DT to which each unparsed entity information set item maps .[ base URI ] .The base URI of the EXI stream .[ character encoding scheme ] .N / A .[ standalone ] .", "label": "", "metadata": {}, "score": "71.58557"}
{"text": "Namespace declarations are not available instream .The attributes xsi : schemaLocation and xsi : noNamespaceSchemaLocation can appear only when they match specific schema declarations ( i.e. , wildcards or ur - types ) .EXI Compression .The use of EXI compression increases compactness utilizing additional computational resources .", "label": "", "metadata": {}, "score": "71.72348"}
{"text": "( see 7.3.1 String Table Partitions ) .Clarified that mantissa or exponent values outside of the accepted range MUST NOT be used in the Float datatype representation .( see 7.1.4 Float ) .Clarified the criteria used to determine which values of xsi : nil attributes are included in the structure channel ( as opposed to value channels ) when EXI compression is used .", "label": "", "metadata": {}, "score": "71.752686"}
{"text": "Affixation can be very easily modeled via finite state automata without the need to explicitly enumerate each possible form , but full reduplication , stem alteration ( like suppletion and ablaut ) or templatic morphology ( as in the semitic languages ) require more work .", "label": "", "metadata": {}, "score": "71.77162"}
{"text": "The order of the value channels within the compressed stream is defined by the order in which the first value in each channel occurs in the EXI event sequence .If the value channels of the block contain more than 100 values , the first compressed stream contains only the structure channel .", "label": "", "metadata": {}, "score": "71.82932"}
{"text": "10.1 EXI Stream Conformance .[ Definition : ] A conformant EXI stream consists of a sequence of octets that follows the syntax of EXI stream that is defined in this document .[ Definition : ] EXI format provides a way to involve user - defined datatype representations in EXI streams processing , which is an extension point that , when used in conjunction with relevant datatype representations specifications external to this document , leads to the formulation of Extended EXI streams .", "label": "", "metadata": {}, "score": "71.88907"}
{"text": "The new Viewer adds three features for more powerful search : wildcards , morphological inflections , and capitalization .These additions allow the discovery of patterns that were previously difficult to find and further facilitate the study of linguistic trends in printed text .", "label": "", "metadata": {}, "score": "71.92886"}
{"text": "Each event code is represented by a sequence of 1 to 3 parts that uniquely identify an event .Event code parts are encoded in order starting with the first part followed by subsequent parts .Two event codes are siblings at the i -th part if and only if they share the same values in all preceding parts .", "label": "", "metadata": {}, "score": "71.93466"}
{"text": "Characters that are not in this set are represented by the n -bit Unsigned Integer N followed by the Unicode code point of the character represented as an Unsigned Integer .The figure below illustrates an overview of the process for determining and using restricted character sets described in this section .", "label": "", "metadata": {}, "score": "72.21312"}
{"text": "The qname of the first child element identifies the schema datatype that is not represented using the default built - in EXI datatype representation and the qname of the second child element identifies the alternate built - in EXI datatype representation or user - defined datatype representation used to represent that type .", "label": "", "metadata": {}, "score": "72.30541"}
{"text": "( see 5.4 EXI Options ) .The predicates used for AT and CH terminal symbols ( i.e. those previously denoted as [ schema - valid value ] and [ schema - invalid value ] ) have been changed to [ schema - typed value ] and [ untyped value ] to more accurately reflect the associated semantics .", "label": "", "metadata": {}, "score": "72.31063"}
{"text": "m represents the first two parts of the event code of the production in which the macro non - terminal LEFTHANDSIDE 1 appears on the right - hand side .Non - terminal macros are used in this specification for notational convenience only .", "label": "", "metadata": {}, "score": "72.39958"}
{"text": "In a schema - informed grammar , all productions of the form LeftHandSide : AT ( xsi : nil ) RightHandSide are evaluated as follows : .If nil is a valid Boolean , assign it the Boolean datatype representation ( see 7.1.2 Boolean ) and encode it according to section 7 .", "label": "", "metadata": {}, "score": "72.49001"}
{"text": "The table below shows these four kinds of AT terminal symbols along with the equivalent combinations of SE and CH terminal symbols for representing elements .Table 8 - 1 .Equivalent terminal symbols for different attribute and element representations .When a global attribute definition is available for qname , the attribute value is represented according to the datatype of the global attribute .", "label": "", "metadata": {}, "score": "72.49696"}
{"text": "EXI processors MUST support Unsigned Integer values less than 2147483648 .The Unsigned Integer datatype representation can be decoded by going through the following steps .Example 7 - 1 .Example algorithm for decoding an Unsigned Integer .Start with the initial value set to 0 and the initial multiplier set to 1 .", "label": "", "metadata": {}, "score": "72.790146"}
{"text": "EXI compression partitions the sequence of EXI events into a sequence of one or more non - overlapping blocks .Each block preceding the final block contains the minimum set of consecutive events that result in exactly blockSize values in its value channels ( see 9.2.2 Value Channels ) , where blockSize is the block size of the EXI stream ( see 5.4 EXI Options ) .", "label": "", "metadata": {}, "score": "72.84814"}
{"text": "Items listed in square brackets are included if and only if the value of its preceding presence indicator ( specified above ) is set to true .When the value of the compression option is false and the bit - packed alignment is used , the n -bit Unsigned Integer datatype representation is an unsigned binary integer using n bits .", "label": "", "metadata": {}, "score": "72.8829"}
{"text": "EXI compression splits a sequence of EXI events into a number of contiguous blocks of events .Events that belong to the same block are transformed into lower entropy groups of similar values called channels , which are individually well suited for standard compression algorithms .", "label": "", "metadata": {}, "score": "72.902374"}
{"text": "Required parameters : . none .Optional parameters : . none .Encoding considerations : . binary .Security considerations : .When used as an XML replacement in an application , EXI shares the same security concerns as XML , described in IETF RFC 3023 [ IETF RFC 3023 ] , section 10 .", "label": "", "metadata": {}, "score": "72.92486"}
{"text": "The order in which attributes are encoded may be different in schema - less and schema - informed modes , as is the exact content associated with each event .The actual number of bits used to represent each type of event , excluding its content , differs depending on context .", "label": "", "metadata": {}, "score": "72.96951"}
{"text": "Internet Engineering Task Force , January 2001 .ISO / IEC 10646 .ISO / IEC 10646 - 1:2000 .Information technology - Universal Multiple - Octet Coded Character Set ( UCS ) - Part 1 : Architecture and Basic Multilingual Plane and ISO / IEC 10646 - 2:2001 .", "label": "", "metadata": {}, "score": "73.11009"}
{"text": "This is a restricted form of Greibach normal form [ Greibach Normal Form ] .EXI proto - grammars differ from normalized EXI grammars in that they may contain productions of the form : . where LeftHandSide and RightHandSide are both non - terminals .", "label": "", "metadata": {}, "score": "73.177"}
{"text": "If the attribute value can be represented using the datatype representation associated with global - type , it SHOULD be represented using the datatype representation associated with global - type ( see 7 .Representing Event Content ) .Note : .", "label": "", "metadata": {}, "score": "73.33767"}
{"text": "If the attribute value can be represented using the datatype representation associated with global - type , it SHOULD be represented using the datatype representation associated with global - type ( see 7 .Representing Event Content ) .Note : .", "label": "", "metadata": {}, "score": "73.33767"}
{"text": "[ Definition : ] The selfContained option is a Boolean used to enable the use of self - contained elements in the EXI stream .Self - contained elements may be read independently from the rest of the EXI body , allowing them to be indexed for random access .", "label": "", "metadata": {}, "score": "73.360405"}
{"text": "The uri partition is optimized for frequent use of compact identifiers and is pre - populated with initial entries as described in D.1 Initial Entries in Uri Partition .Prefix content items are assigned to partitions based on their associated namespace URI .", "label": "", "metadata": {}, "score": "73.38324"}
{"text": "Yes No .A Encoding Examples .The WG has crafted a tutorial page EXI 1.0 Encoding Examples that explains the workings of EXI format using simple example documents .At the time of this writing , the page only shows a schema - less EXI encoding example .", "label": "", "metadata": {}, "score": "73.5836"}
{"text": "- algori Dec 23 ' 10 at 0:09 .Dear Hugo , See my answer here : mathoverflow.net/questions/37021/ ... .It provide a summary of unitary representation theory of reductive Lie groups , which is somewhat more complicated than what you have anticipated .", "label": "", "metadata": {}, "score": "73.69288"}
{"text": "Computers fail to track these in fast video , but sleight of hand fools humans as well : what happens too quickly we just can not see .We show a 3D tracker for these types of motions that relies on the recognition of familiar configurations in 2D images ( classification ) , and fills the gaps in - between ( interpolation ) .", "label": "", "metadata": {}, "score": "73.957245"}
{"text": "If there is more than one element declared with the same qname , the qname is included only once .Otherwise , their content is evaluated according to the relaxed Element Fragment grammar described in 8.5.3 Schema - informed Element Fragment Grammar .", "label": "", "metadata": {}, "score": "73.97176"}
{"text": "( see 6.3 Fidelity Options ) .Section 7.2 Enumerations now explicitly states that a value of an enumerated type can be represented using the ordinal position of any of the items in the enumeration that represent the value .Corrected 7.1.8 Date - Time by making the previous change about Hour , Minute and Second values apply similarly to TimeZone so as to represent all datetime numbers consistenty in base 2 .", "label": "", "metadata": {}, "score": "74.052"}
{"text": "EXI Compression regardless of the alignment option value .As mentioned above , the \" compression \" element MUST NOT appear in an EXI options document when the \" alignment \" element is present .[ Definition : ] The strict option is a Boolean used to increase compactness by using a strict interpretation of the schemas and omitting preservation of certain items , such as comments , processing instructions and namespace prefixes .", "label": "", "metadata": {}, "score": "74.1183"}
{"text": "An element information item maps to a pair of a Start Element ( SE ) event and the corresponding End Element ( EE ) event with each of its properties subject to further mapping as shown in the following table .Table B-2 .", "label": "", "metadata": {}, "score": "74.135796"}
{"text": "Concepts describes the structure of an EXI document and introduces the notions of EXI header , EXI body and EXI grammar which are fundamental to the understanding of the EXI format .Additional details about data type representation , compression , and their interaction with other format features are presented .", "label": "", "metadata": {}, "score": "74.13838"}
{"text": "[ version ] .Not available .[ all declarations processed ] .True if all declarations contained directly or indirectly in DT are processed , otherwise false , which is the processor quality as opposed to the information provided by the format .", "label": "", "metadata": {}, "score": "74.17908"}
{"text": "In the normalized grammars , terminal symbols AT and CH represent attribute and character events that can be represented by the EXI datatype representations associated with their schema datatypes ( see 7 .Representing Event Content ) .When the strict option is false , additional untyped AT and CH terminal symbols are added that can be used for representing attributes and character events that can not be represented by the associated EXI datatype representations ( e.g. , schema - invalid values ) .", "label": "", "metadata": {}, "score": "74.19898"}
{"text": "Computed based on text content item of DT .[ declaration base URI ] .The base URI of the notation information item .B.11 Namespace Information Item .An namespace information item maps to a Namespace Declaration ( NS ) event with each of its properties subject to further mapping as shown in the following table .", "label": "", "metadata": {}, "score": "74.318954"}
{"text": "- Ryan Budney Jan 26 ' 11 at 18:41 .You do n't have a fixed point on $ M$ , so the embedding misses the origin .- Ryan Budney Jan 26 ' 11 at 19:07 .Could n't one let $ N$ be the orbit space of $ \\Bbb Z_2 $ acting on $ M$ , then we can embed $ N$ in some $ \\Bbb RP^j$. Lastly we can lift this to an embedding of double covers to get a smooth embedding of $ M$ in $ S^j$ which is equivariant . -", "label": "", "metadata": {}, "score": "74.38664"}
{"text": "Ball Tracking :The reliable tracking of the ball is vital in robot soccer .Therefore a Kalman - filter based system for estimating the ball position and velocity in the presence of occlusions is developped . -Sensor Fusion : The robot perceives its environment through several independent sensors ( camera , odometer , etc . ) , which have different delays .", "label": "", "metadata": {}, "score": "74.46169"}
{"text": "They are encoded directly as a sequence of values , or if additional compression is desired , they are passed to the EXI compression algorithm , which replaces frequently occurring event patterns to further reduce size .The EXI events permitted at any given position in an EXI stream are determined by the EXI grammar .", "label": "", "metadata": {}, "score": "74.55932"}
{"text": "The preserve options shown in the table above is really a family of options that control what XML items are preserved and what XML items are ignored .These are collectively known as fidelity options .These options can be used to eliminate the associated overhead of communicating unused XML items .", "label": "", "metadata": {}, "score": "74.74366"}
{"text": "Jos\u00e9 Figueroa - O'Farrill Dec 23 ' 10 at 0:59 .Right , sorry .The statement is the the embedding must be closed .The embedding into $ SO(3)$ is not closed .-Owen Sizemore Dec 23 ' 10 at 2:03 .", "label": "", "metadata": {}, "score": "74.80275"}
{"text": "In this case , pre - compression just prepares the stream for later compression .[ Definition : ] The compression option is a Boolean used to increase compactness using additional computational resources .The default value \" false \" is assumed when the \" compression \" element is absent in the EXI Options document whereas its presence denotes the value \" true \" .", "label": "", "metadata": {}, "score": "75.04901"}
{"text": "A value of 0 indicates this is a final version and a value of 1 indicates this is a preview version .Final versions correspond to final , approved versions of the EXI format specification .An EXI processor that implements a final version of the EXI format specification is REQUIRED to process EXI streams that have a version field with its first bit set to 0 followed by a version number that corresponds to the version of the EXI specification the processor implements .", "label": "", "metadata": {}, "score": "75.05101"}
{"text": "See the comments under the question .Turkish has theoretically infinite inflectional forms due to \" -ki \" suffix .If you also consider derivational morphology , I expect most languages can add deverbal + denominal suffix pairs in a potentially infinite way . -", "label": "", "metadata": {}, "score": "75.057236"}
{"text": "[ Definition : ] A program module called an EXI processor , whether it is software or hardware , is used by application programs to encode their structured data into EXI streams and/or to decode EXI streams to make the structured data accessible .", "label": "", "metadata": {}, "score": "75.114456"}
{"text": "7.1.6 Unsigned Integer .The Unsigned Integer datatype representation supports unsigned integer numbers of arbitrary magnitude .It is represented as a sequence of octets terminated by an octet with its most significant bit set to 0 .The value of the unsigned integer is stored in the least significant 7 bits of the octets as a sequence of 7-bit bytes , with the least significant byte first .", "label": "", "metadata": {}, "score": "75.216"}
{"text": "Each branch of a regex is described by the following production : .The set - of - chars for each branch of a regex is the union of the set - of - chars for each piece of the branch .", "label": "", "metadata": {}, "score": "75.22928"}
{"text": "9.2.2 Value Channels .The values of the Attribute ( AT ) and Character ( CH ) events in each block are organized into separate channels based on the qname of the associated attribute or element .Each block contains exactly one channel for each distinct element or attribute qname that occurs in the block .", "label": "", "metadata": {}, "score": "75.76895"}
{"text": "Add the value that was just read to the version number .If the value is 15 , go to step 1 , otherwise ( i.e. the value being in the range of 0 - 14 ) , use the current value of the version number as the EXI version number .", "label": "", "metadata": {}, "score": "75.7693"}
{"text": "If the resulting value of globalID is equal to valuePartitionCapacity , its value is reset to zero ( 0 ) .7.4 Datatype Representation Map .By default , each typed value in an EXI stream is represented using its default built - in EXI datatype representation ( see Table 7 - 1 ) .", "label": "", "metadata": {}, "score": "75.85852"}
{"text": "The following two sections describe the EXI header and EXI body in more detail .2.1.1 EXI Header .The header communicates encoding properties that are needed to decode the EXI body .The default settings can be represented in a single byte .", "label": "", "metadata": {}, "score": "76.17713"}
{"text": "Fryie Nov 10 ' 15 at 17:36 So I have been mulling the following question over in my head for awhile now , and want to see if anyone else might have any ideas .Begin with $ M$ a manifold and suppose that $ M$ has an antipodal map $ \\alpha : M\\rightarrow M$ , i.e. $ \\forall m\\in M$ one has : .", "label": "", "metadata": {}, "score": "76.30184"}
{"text": "For instance the notebook sample assigns six local - name entries , such as notebook and date , to the empty URI namespace .Whenever the LocalName and/or URI portion of a qname occur again , the compact identifier is used instead .", "label": "", "metadata": {}, "score": "76.48782"}
{"text": "Header options fields valueMaxLength and valuePartitionCapacity have been added in EXI options to limit the length of a string and the total number of strings that are put into value partitions of a string table .The EXI Working Group would like to acknowledge the following former members of the group for their leadership , guidance and expertise they provided throughout their individual tenure in the WG .", "label": "", "metadata": {}, "score": "76.51997"}
{"text": "Only final versions are required to be processed by compliant processors .The leading bit is followed by one or more 4-bit sequences which are collectively interpreted as a format version number starting at 1 .For example , the 4-bit sequence 0000 is interpreted as version 1 and the two 4-bit sequences 1111 0001 is interpreted as 15 + 2 or version 17 .", "label": "", "metadata": {}, "score": "76.53694"}
{"text": "( See 8.2 Grammar Event Codes for more description of event codes . )The structure of an EXI stream is described by the EXI grammars , which are formally specified in section 8 .EXI Grammars .Each grammar defines which events are permitted to occur at any given point in the EXI stream and provides a pre - assigned event code for each one .", "label": "", "metadata": {}, "score": "76.63753"}
{"text": "Productions that use non - terminal macros on the right - hand side need to be expanded by macro substitution before such productions are interpreted .Therefore , ABigProduction 1 and ABigProduction 2 shown in the preceding example are equivalent to the following set of productions obtained by expanding the non - terminal macro symbol LEFTHANDSIDE 1 and evaluating the variable event codes .", "label": "", "metadata": {}, "score": "76.66348"}
{"text": "The definitions of user - defined datatype representations syntax are out of the scope of this document .[ Definition : ] An extended EXI stream is a conformant extended EXI stream if replacing value items represented using user - defined datatype representations with their intrinsic representations would make the stream a conformant EXI stream .", "label": "", "metadata": {}, "score": "76.70409"}
{"text": "B.5 Unexpanded Entity Reference Information item .An unexpanded entity reference information item maps to an Entity Reference ( ER ) event with each of its properties subject to further mapping as shown in the following table .Table B-5 .Mapping of the entity reference information item properties to the EXI event types .", "label": "", "metadata": {}, "score": "76.742325"}
{"text": "The length is represented as an Unsigned Integer ( see 7.1.6 Unsigned Integer ) .7.1.2 Boolean .In the absence of pattern facets in the schema datatype , the Boolean datatype representation is a n -bit unsigned integer ( 7.1.9 n - bit Unsigned Integer ) , where n is one ( 1 ) .", "label": "", "metadata": {}, "score": "76.8285"}
{"text": "Create a production of the form LeftHandSide : AT ( qname ) RightHandSide with an event code 0 and increment the first part of the event code of each production in the current grammar with the non - terminal LeftHandSide on the left - hand side .", "label": "", "metadata": {}, "score": "76.84514"}
{"text": "Compressed Streams .The channels in a block are further organized into compressed streams .Smaller channels are combined into the same compressed stream , while others are each compressed separately .Below are the rules applied within the scope of a block used to determine the channels to be combined together , the order of the compressed streams and the order amongst the channels that are combined into the same compressed stream .", "label": "", "metadata": {}, "score": "76.856064"}
{"text": "More generically , if y is a mixture of As and Bs ten as y repeats some B must occur before some A , which is banned by the regular language A n B n-1 died .Conclusion .Obviously , this only applies to English and I can not say that there is no natural language that can be fully expressed by a regular expression , but I highly doubt it .", "label": "", "metadata": {}, "score": "76.858"}
{"text": "The maximum size of the range used for determining the use of n -bit Unsigned Integer for representing values of xsd : integer was changed from 4095 to 4096 .( see Table 7 - 1 and 7.1.9 n - bit Unsigned Integer ) .", "label": "", "metadata": {}, "score": "76.91455"}
{"text": "Note : .The qnames exi : ieeeBinary32 and exi : ieeeBinary64 defined above are reserved for future use in Datatype Representation Maps to identify the 32-bit and 64-bit Binary Interchange Formats defined by the IEEE 754 - 2008 standard [ IEEE 754 - 2008 ] .", "label": "", "metadata": {}, "score": "77.10464"}
{"text": "@Arturo : \" Immersion \" just means that the derivative is injective on the tangent space at each point .The manifold is allowed to self - intersect .- Grumpy Parsnip Sep 28 ' 11 at 16:54 .So I 'm saying the two terms are NOT synonymous .", "label": "", "metadata": {}, "score": "77.120285"}
{"text": "[ name ] .ER .[ system identifier ] .Based on the availability of the internal DTD subset .[ public identifier ] .Based on the availability of the internal DTD subset .[ declaration base URI ] .", "label": "", "metadata": {}, "score": "77.16223"}
{"text": "preserve .A set of options that controls whether comments , processing instructions , etc . are preserved .schemaID .Most of the options are straightforward and act as boolean values to enable or disable a feature .They are represented using optional XML elements which are also encoded using EXI .", "label": "", "metadata": {}, "score": "77.20474"}
{"text": "[ target ] .PI .[ content ] .PI .[ base URI ] .The base URI of the processing information item .[ notation ] .Computed based on the availability of the internal DTD subset .[ parent ] .", "label": "", "metadata": {}, "score": "77.282715"}
{"text": "Datatypes that are derived from another by union and their subtypes are always represented as String regardless of the availability of enumerated values .Representation of values of which the datatype is one of QName , Notation or a datatype derived therefrom by restriction are also not affected by enumerated values if any .", "label": "", "metadata": {}, "score": "77.29326"}
{"text": "7.1.3 Decimal .The Decimal datatype representation is a Boolean sign ( see 7.1.2 Boolean ) followed by two Unsigned Integers ( see 7.1.6 Unsigned Integer ) .A sign value of zero ( 0 ) is used to represent positive Decimal values and a sign value of one ( 1 ) is used to represent negative Decimal values .", "label": "", "metadata": {}, "score": "77.44674"}
{"text": "The default value \" false \" is assumed when the \" selfContained \" element is absent from the EXI Options document whereas its presence denotes the value \" true \" .[ Definition : ] The schemaId option may be used to identify the schema information used for processing the EXI body .", "label": "", "metadata": {}, "score": "77.571556"}
{"text": "This section describes the status of this document at the time of its publication .Other documents may supersede this document .Changes since the previous publication based on feedback received during the review period and from implementers are listed in the Change Log .", "label": "", "metadata": {}, "score": "77.639435"}
{"text": "CM events can be preserved .Preserve.pis .PI events can be preserved .Preserve.dtd .DT and ER events can be preserved . Preserve.prefixes .NS events and namespace prefixes can be preserved .Preserve.lexicalValues .Lexical form of element and attribute values can be preserved in value content items .", "label": "", "metadata": {}, "score": "77.6416"}
{"text": "[ Definition : ] The EXI Options are represented as an EXI Options document , which is an XML document encoded using the EXI format described in this specification .This results in a very compact header format that can be read and written with very little additional software .", "label": "", "metadata": {}, "score": "77.67529"}
{"text": "The structure channel of each block defines the overall order and structure of the events in that block .It contains the event codes and associated content for each event in the block , except for Attribute ( AT ) and Character ( CH ) values , which are stored in the value channels .", "label": "", "metadata": {}, "score": "77.87565"}
{"text": "As stated earlier , transitions in red are extensions to the built - in element grammar based on knowledge acquired about the element \" note \" .Notice how AT(\"category \" ) , AT(\"date \" ) and SE(\"subject \" ) have been added out of the StartTag state while SE(body ) has been added out of the Element state .", "label": "", "metadata": {}, "score": "78.166306"}
{"text": "If there is no namespace in scope for the specified qname prefix , set the uri of target - type to empty ( \" \" ) and the localName to the full lexical value of the QName , including the prefix .", "label": "", "metadata": {}, "score": "78.350296"}
{"text": "The built - in element automaton has two distinguished states : StartTag and Element .The former accepts attribute and namespace events that must occur before any element content ; the latter accepts only element content which excludes attribute and namespace events .", "label": "", "metadata": {}, "score": "78.444336"}
{"text": "The second Unsigned Integer represents the fractional portion of the Decimal value with the digits in reverse order to preserve leading zeros .7.1.4 Float .The Float datatype representation is two consecutive Integers ( see 7.1.5 Integer ) .The first Integer represents the mantissa of the floating point number and the second Integer represents the base-10 exponent of the floating point number .", "label": "", "metadata": {}, "score": "78.83319"}
{"text": "The set - of - chars for each piece of a branch is the set - of - chars for the atom portion of the piece .The atom portion of a piece is described by the following production : .The set - of - chars for the atom is the set - of - chars for the Char , charClass or regExp that constitutes the atom .", "label": "", "metadata": {}, "score": "78.85772"}
{"text": "A sign value of zero ( 0 ) is used to represent positive integers and a sign value of one ( 1 ) is used to represent negative integers .For non - negative values , the Unsigned Integer holds the magnitude of the value .", "label": "", "metadata": {}, "score": "78.97902"}
{"text": "The rule previously applied to xsd : Integer datatype in that table is now described in section 7.1.5 Integer .EXI Cookie was introduced in the EXI header in order to provide a facility to distinguish EXI streams from a broader range of document types used on the Web .", "label": "", "metadata": {}, "score": "79.11081"}
{"text": "No two productions with the same non - terminal symbol on the left - hand side are permitted to have the same event code .8.1.2 Variable Event Codes .Some non - terminal symbols are used on the right - hand side in a production without a terminal symbol prefixed to them , but with a parenthesized event code affixed instead .", "label": "", "metadata": {}, "score": "79.13441"}
{"text": "The EXI Options field within an EXI header is optional .Its presence is indicated by the value of the presence bit that follows Distinguishing Bits .The presence and absence is indicated by the value 1 and 0 , respectively .", "label": "", "metadata": {}, "score": "79.3639"}
{"text": "They serve two distinct roles .One is for content coding and the other is for internet media type .F.1 Content Coding .The content - coding value \" exi \" is registered with the Internet Assigned Numbers Authority ( IANA ) for use with EXI .", "label": "", "metadata": {}, "score": "79.50737"}
{"text": "On the other hand , there are no padding bits when the alignment in use is bit - packed .The padding bits field if it is present can contain any values of bits as its contents .[ Definition : ] An EXI header MAY start with an EXI Cookie , which is a four byte field that serves to indicate that the stream of which it is a part is an EXI stream .", "label": "", "metadata": {}, "score": "79.56627"}
{"text": "A processing instruction information maps to a Processing Instruction ( PI ) event with each of its properties subject to further mapping as shown in the following table .Table B-4 .Mapping of the processing instruction information item properties to EXI event types .", "label": "", "metadata": {}, "score": "79.680885"}
{"text": "[ notation name ] .Computed based on text content item of DT .[ notation ] .Computed based on text content item of DT .B.10 Notation Information Item .An notation information item maps to part of the text content item of DOCTYPE ( DT ) event with each of its properties subject to further mapping as shown in the following table .", "label": "", "metadata": {}, "score": "79.91261"}
{"text": "EXI Header .Each EXI stream begins with an EXI header .[ Definition : ] The EXI header can identify EXI streams , distinguish EXI streams from text XML documents , identify the version of the EXI format being used , and specify the options used to process the body of the EXI stream .", "label": "", "metadata": {}, "score": "79.94039"}
{"text": "When the \" blockSize \" element is absent in the EXI Options document , the default blocksize of 1,000,000 is used .The default blockSize is intentionally large but can be reduced for processing large documents on devices with limited memory .", "label": "", "metadata": {}, "score": "80.10169"}
{"text": "The EXI Format Version identifies the version of EXI in use and allows future improvements and modifications .A leading 0 ( zero ) bit indicates that the document is encoded according to the final version of the recommendation , while a leading 1 ( one ) indicates that it is a preview version .", "label": "", "metadata": {}, "score": "80.44229"}
{"text": "Each version of the EXI Format Specification specifies the corresponding EXI format version number to be used by conforming implementations .The EXI format version number that corresponds with this version of the EXI format specification is 1 ( one ) .", "label": "", "metadata": {}, "score": "80.50052"}
{"text": "It was made clear that \" strict \" element is not permitted to appear alongside \" selfContained \" element in an options document .( see the term definitions of \" strict option \" and \" selfContained option \") .The provision for selfContained option was removed from section 8.5.4.4.2 Adding Productions when Strict is True .", "label": "", "metadata": {}, "score": "80.86568"}
{"text": "Dominik D. Freydenberger Feb 7 ' 13 at 11:58 .Do you know any details in this conntext regarding deterministic context - free or visibly pushdown languages ? -Dan Feb 7 ' 13 at 15:44 .From DCFL to DFA , I think it 's something like a double - exponential tradeoff , according to Valiant , IIRC ( Do n't have time to check , do n't know if the situation is better for VPL . ) - Dominik D. Freydenberger Feb 7 ' 13 at 18:05 .", "label": "", "metadata": {}, "score": "80.930016"}
{"text": "Character data represented using the datatype representation associated with the schema datatype of the character data are matched by productions of the form LeftHandSide : CH [ schema - typed value ] RightHandSide described in section 8.5.4.1.3.1 Simple Type Grammars .Apply the process described above for element grammars to each normalized type grammar Type i and TypeEmpty i . 8.5.4.4.2", "label": "", "metadata": {}, "score": "81.079575"}
{"text": "Mapping of the namespace information item properties to EXI event types .Property .EXI event types .[ prefix ] .NS .[ namespace name ] .NS .C XML Schema for EXI Options Document .The following schema describes the EXI options header .", "label": "", "metadata": {}, "score": "81.1223"}
{"text": "If the QName value is part of an SE event followed by an associated NS event with its local - element - ns flag value set to true , the prefix value is the prefix of this NS event .Otherwise , the prefix value is the candidate value , if any , selected in step 1 above .", "label": "", "metadata": {}, "score": "81.390884"}
{"text": "datatypeRepresentationMap illustrating a user - defined type represented by a user - defined datatype representation .Note : .EXI only defines a way to indicate the use of user - defined datatype representations for representing values of specific datatypes .Datatype representations are referred to by their respective qnames in \" datatypeRepresentationMap \" elements .", "label": "", "metadata": {}, "score": "81.5717"}
{"text": "Each NS event either associates a prefix with an URI , assigns a default namespace , or in the case of a namespace declaration with an empty URI , rescinds one of such associations in effect at the point of its occurrence .", "label": "", "metadata": {}, "score": "81.62104"}
{"text": "In the subsequent paragraphs more details about the different partitions are given by making use of the previously introduced Notebook example .The XML example is inserted inline once again to facilitate a better understanding .EXI Do not forget it !", "label": "", "metadata": {}, "score": "81.81828"}
{"text": "EXI Stream Structure .EXI Header .EXI Body .The EXI header conveys format version information and may also include the set of options that were used during encoding ; if these options are omitted , then it is assumed that the decoder has access to them out of band .", "label": "", "metadata": {}, "score": "82.14009"}
{"text": "When EXI Options are present in the header , an EXI Processor MUST observe the specified options to process the EXI stream that follows .Otherwise , an EXI Processor may obtain the EXI options using another mechanism .There are no fallback option values provided by this specification for use in the absence of the whole EXI Options part .", "label": "", "metadata": {}, "score": "82.30376"}
{"text": "Character data that is not represented using the EXI datatype representation associated with the simple type definition is represented by productions of the form LeftHandSide : CH [ untyped value ] RightHandSide described in section 8.5.4.4 Undeclared Productions .The content index of grammar Type i and TypeEmpty i created from an XML Schema simple type definition is always 0 ( zero ) .", "label": "", "metadata": {}, "score": "82.36902"}
{"text": "The URI portion of qname content items and uri content items are assigned to the URI partition .The partition is initially pre - populated with three likely entries ( see figure below ) .When XML Schemas are used ( schema - informed mode ) there is an additional entry that is appended to the URI partition .", "label": "", "metadata": {}, "score": "82.689186"}
{"text": "For example , the attribute event AT(\"foo \" ) may have an attribute value foo1 associated with it .The following table shows all the possible event types together with their associated content .These events differ in their associated content : when SE ( qname ) or AT ( qname ) are used , the actual qname of the XML item is not encoded as part of event .", "label": "", "metadata": {}, "score": "82.767136"}
{"text": "datatypeRepresentationMap indicating all Decimal values are represented using built - in String datatype representation .It is the responsibility of an EXI processor to interface with a particular implementation of built - in EXI datatype representations or user - defined datatype representations properly .", "label": "", "metadata": {}, "score": "82.90013"}
{"text": "Paresh Feb 7 ' 13 at 15:17 .Regarding the edit : The only ( somewhat ) hard part is finding out which language is generated by the CFG .After that , writing down the RLG is straightforward . -Dominik D. Freydenberger Feb 8 ' 13 at 12:34 .", "label": "", "metadata": {}, "score": "82.90979"}
{"text": "A document type declaration information item maps to a DOCTYPE ( DT ) event with each of its properties subject to further mapping as shown in the following table .Table B-8 .Mapping of the document type declaration information item properties to the EXI event types .", "label": "", "metadata": {}, "score": "82.94507"}
{"text": "( see 8.5.3 Schema - informed Element Fragment Grammar ) .Added a statement that suggests turning on Preserve.prefixes fidelity option when the Preserve.lexicalValues fidelity option is true and xsi : type attributes are used in the EXI stream .( see 6.3 Fidelity Options ) .", "label": "", "metadata": {}, "score": "83.09616"}
{"text": "Arturo Magidin Sep 28 ' 11 at 16:58 .3 Answers 3 .Basically an abstract surface has , at every point two independent directions along the surface .Or even better , there is an entire circle 's worth of rays coming out of each point .", "label": "", "metadata": {}, "score": "83.341705"}
{"text": "Bytes are ordered with the least significant byte first .The n -bit unsigned integer is used for representing event codes , the prefix component of QNames ( see 7.1.7 QName ) and certain value content items , as described in respective relevant parts of this document .", "label": "", "metadata": {}, "score": "83.3938"}
{"text": "Let us continue the example from the previous section by assuming the following schema is available statically .Example 2 - 2 .Notebook ( XML Schema ) .The schema for the element \" note \" states that it has a mandatory attribute \" date \" and an optional attribute \" category \" , and that its structure is composed of an element \" subject \" followed by an element \" body \" .", "label": "", "metadata": {}, "score": "84.41608"}
{"text": "Section 6.3 Fidelity Options describes the set of information items affected by the preserve option .The elements \" dtd \" , \" prefixes \" , \" comments \" and \" pis \" MUST NOT appear in an EXI options document when the \" strict \" element is present in the same options document .", "label": "", "metadata": {}, "score": "84.49982"}
{"text": "For example , the following \" datatypeRepresentationMap \" element indicates all values of type xsd : decimal are represented using the built - in exi : string datatype representation .In addition , all datatypes derived from xsd : decimal by restriction that do not have a closer ancestor in the type hierarchy with an associated datatype representation are represented using exi : string .", "label": "", "metadata": {}, "score": "85.10155"}
{"text": "A W3C Proposed Recommendation is a mature technical report that , after wide review for technical soundness and implementability , W3C has sent to the W3C Advisory Committee for final endorsement .W3C Advisory Committee Representatives should consult their WBS questionnaires .", "label": "", "metadata": {}, "score": "85.11398"}
{"text": "[Geneva ] : International Organization for Standardization .This appendix contains the mappings between the XML Information Set [ XML Information Set ] model and the EXI format .Starting from the document information item , each information item definition is mapped to its respective unordered set of EXI event types ( see Table 4 - 1 ) .", "label": "", "metadata": {}, "score": "85.73856"}
{"text": "The EXI options header , when it appears in an EXI stream , MUST include a \" datatypeRepresentationMap \" element for each schema datatype of which the descendant datatypes derived by restriction as well as itself are not represented using the default built - in EXI datatype representation .", "label": "", "metadata": {}, "score": "85.74097"}
{"text": "( I 'm not sure if this means that they must be embedded into U(26 ) but I would guess so ... ) - Nick Gill Jun 13 ' 12 at 12:40 .Bull .Amer .Math .Soc .", "label": "", "metadata": {}, "score": "85.807625"}
{"text": "Retrieve the exponent value using the procedure described in 7.1.5 Integer .If the exponent value is -(2 14 ) , the mantissa value 1 represents INF , the mantissa value -1 represents -INF and any other mantissa value represents NaN. If the exponent value is not -(2 14 ) , the float value is m \u00d7 10 e where m is the mantissa and e is the exponent obtained in the preceding steps .", "label": "", "metadata": {}, "score": "85.93071"}
{"text": "Each grammar production has an event code , which is represented by a sequence of one to three parts separated by periods ( \" . \" )Each part is an unsigned integer .The following are examples of grammar productions with event codes as they appear in this specification .", "label": "", "metadata": {}, "score": "86.12571"}
{"text": "The EXI Options document is represented as an EXI body informed by the above mentioned schema using the default options specified by the following XML document .An EXI Options document consists only of an EXI body , and MUST NOT start with an EXI header .", "label": "", "metadata": {}, "score": "86.135414"}
{"text": "Below are some examples of variable event codes : .Example 8 - 3 .Example non - terminal macros and its productions with variable event codes .Unless otherwise specified , the variable n evaluates to the first part of the event code of the production in which the macro non - terminal LEFTHANDSIDE 1 appears on the right - hand side .", "label": "", "metadata": {}, "score": "86.723495"}
{"text": "The body of an EXI document is composed of a sequence of EXI events .The notion of an event in this context is similar to that in the StAX and SAX APIs .XML items are encoded into one or more EXI events ; for example , an attribute named foo can be encoded as AT(\"foo \" ) and an element named bar as the pair of events SE(\"bar \" ) and EE .", "label": "", "metadata": {}, "score": "87.229965"}
{"text": "The term event and stream is used throughout this document to denote EXI event and EXI stream respectively unless the words are qualified differently to mean otherwise .This document specifies an abstract grammar for EXI .In grammar notation , all terminal symbols are represented in plain text and all non - terminal symbols are represented in italics .", "label": "", "metadata": {}, "score": "87.831604"}
{"text": "Productions of the form LeftHandSide : CH [ schema - typed value ] RightHandSide represent typed character data that can be represented using the EXI datatype representation associated with the simple type definition ( see 7 .Representing Event Content ) .", "label": "", "metadata": {}, "score": "87.905594"}
{"text": "Example 2 - 1 .Notebook ( XML Document ) .EXI Do not forget it !Shopping List milk , honey .The sequence of EXI events corresponding to the body of this XML document is shown below .This sequence of EXI events can be easily mapped to the structure of the XML document shown above .", "label": "", "metadata": {}, "score": "88.276474"}
{"text": "Oliver Goldman , Adobe Systems , Inc. ( former co - chair ) ( until 08 June 2006 ) .Robin Berjon , Expway ( former co - chair ) ( until 17 October 2006 ) .Peter Haggar , IBM ( until 07 March 2007 ) .", "label": "", "metadata": {}, "score": "88.41777"}
{"text": "If qname is xsi : type , let target - type be the value of the xsi : type attribute and assign it the QName datatype representation ( see 7.1.7 QName ) .If there is no namespace in scope for the specified qname prefix , set the uri of target - type to empty ( \" \" ) and the localName to the full lexical value of the QName , including the prefix .", "label": "", "metadata": {}, "score": "88.53615"}
{"text": "So it 's the old 80 - 20 rule ( also called the law of diminishing returns ) ?80 % of the coverage is handled by 20 % of the effort .I alluded to this in my answer but this goes into much more detail . - acattle Feb 1 ' 13 at 17:53 .", "label": "", "metadata": {}, "score": "89.13512"}
{"text": "An exponent value -(2 14 ) with mantissa values 1 and -1 represents positive infinity ( INF ) and negative infinity ( -INF ) respectively .An exponent value -(2 14 ) with any other mantissa value represents NaN. The Float datatype representation can be decoded by going through the following steps .", "label": "", "metadata": {}, "score": "89.74791"}
{"text": "Mantissa or exponent values outside of the respective accepted range MUST NOT be used in the Float datatype representation .Values typed as Float with a mantissa or exponent outside the accepted range are represented as untyped values , processed by an alternative production if available that can be used to represent untyped values .", "label": "", "metadata": {}, "score": "89.75374"}
{"text": "Because non - terminal macros are injected into the right - hand side of more than one production , the event codes of productions with these macro non - terminals on the left - hand side are not fixed , but will have different event code values depending on the context in which the macro non - terminal appears .", "label": "", "metadata": {}, "score": "90.25862"}
{"text": "Santiago Pericas - Geertsen , Sun Microsystems , Inc. ( until 06May 2010 ) .Paul Sandoz , Sun Microsystems , Inc. ( until 06May 2010 ) .The EXI working group owes so much to our distinguished colleague from Nokia , Kimmo Raatikainen ( 1955 - 2008 ) , on the progress of our work , who succumbed to an ailment on March 13 , 2008 .", "label": "", "metadata": {}, "score": "92.051834"}
{"text": "Local - Names ( default ) .\" notebook \" . \" date \" . \"note \" .StartTagNotebook extended by leading SE(note ) .StartTagNotebook moves on to ElementNotebook and StartTagNote is pushed on rule - stack .\" notebook \" . \" date \" . \"", "label": "", "metadata": {}, "score": "92.1487"}
{"text": "Kimmo Raatikainen , Nokia ( until 13 March 2008 ) .Daniel Vogelheim , Invited Expert ( former co - chair then from Siemens AG ) ( until 15 July 2008 ) .Stephen Williams , High Performance Technologies , Inc. ( until 8 Aug 2008 ) .", "label": "", "metadata": {}, "score": "92.898346"}
{"text": "When an EXI processor encodes an EXI stream using a Datatype Representation Map and the EXI Options part of the header is present , the EXI options part MUST specify all alternate datatype representations used in the EXI stream .An EXI processor that attempts to decode an EXI stream that specifies a user - defined datatype representation in the EXI header that it does not recognize MAY report a warning , but this is not an error .", "label": "", "metadata": {}, "score": "93.41919"}
{"text": "\" notebook \" +1 ( local - name miss ) .Local - Names ( default ) .\" notebook \" .DocContent moves on to DocEnd and StartTagNotebook is pushed on rule - stack . \" ... /XMLSchema \" . \"", "label": "", "metadata": {}, "score": "93.61203"}
{"text": "@ArturoMagidin :Thanks !I think I am not sure why the Klein bottle is not a 3D object ... ?I can see why the Mobius strip is not 2D though .Would you mind explaining a bit please ? - surface Sep 28 ' 11 at 16:55 .", "label": "", "metadata": {}, "score": "95.29231"}
{"text": "This Master 's thesis describes parts of the control software used by the soccer robots of the Free University of Berlin , the so called FU - Fighters .The FU - Fighters compete in the Middle Sized League of RoboCup and reached the semi - finals during the 2004 RoboCup World Cup in Lisbon , Portugal .", "label": "", "metadata": {}, "score": "95.373795"}
{"text": "Final version 1 .Final version 15 .Final version 16 .Final version 17 .EXI processors conforming with the final version of this specification MUST use the 5-bit value 0 0000 as the version number .5.4 EXI Options .", "label": "", "metadata": {}, "score": "95.71549"}
{"text": "The terminal symbol that matches a start element ( SE ) event with any local - name in namespace uri .The terminal symbol that matches an attribute ( AT ) event with any qname .The terminal symbol that matches an attribute ( AT ) event with any local - name in namespace uri .", "label": "", "metadata": {}, "score": "95.789"}
{"text": "\" subject \" .StartTagNote extended by leading SE(subject ) .StartTagNote moves on to ElementNote and StartTagSubject is pushed on rule - stack .StartTagNote . ElementNote .CH . ElementNote .StartTagNote moves on to ElementNote and StartTagSubject is pushed on rule - stack .", "label": "", "metadata": {}, "score": "98.7503"}
{"text": "Terminal symbol that matches an attribute event with qname qname and an untyped value .Terminal symbol that matches an attribute event with any qname and an untyped value .CH [ untyped value ] .Terminal symbol that matches a characters event with an untyped value .", "label": "", "metadata": {}, "score": "100.37096"}
