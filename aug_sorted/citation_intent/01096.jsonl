{"text": "94 - 102 ) is one of the most efficient parsing algorithms for written sentence input and can operate in linear time for regular grammars .It was one of the first parsing methods that used a central data structure , known as a chart , for storing all intermediate results during the parsing process of a sentence .", "label": "", "metadata": {}, "score": "44.009754"}
{"text": "( 2006 ) , which achieved top results in the 2006 We were given around CoNLL - X shared task .Preliminary experiments in- dicated that the edge labeler was fairly robust to do- main adaptation , lowering accuracy by 3 % in the de- velopment domain as opposed to 2 % in the source , so we focused on unlabeled dependency parsing .", "label": "", "metadata": {}, "score": "45.069992"}
{"text": "Some of these constructs can not be parsed without semantics , such as symbol table information , and some can not be properly recognized without first examining the entire construct , that is we need \" infinite lookahead . \" In this paper , we introduce a new LL(k ) parser strategy , pred - LL(k ) , that uses semantic or syntactic predicates to recognize language constructs when normal deterministic LL(k ) parsing breaks down .", "label": "", "metadata": {}, "score": "45.49363"}
{"text": "Some of these constructs can not be parsed without semantics , such as s ... \" .Most language translation problems can be solved with existing LALR(1 ) or LL(k ) language tools ; e.g. , YACC [Joh78 ] or ANTLR [ PDC92].", "label": "", "metadata": {}, "score": "46.146103"}
{"text": "The GOLD Parsing System is designed to aid in the development of compilers , interpreters , and translators while supporting multiple programming languages ' backends .Because the LALR and DFA algorithms can be implemented with simple state transition graphs , the parsing can be easily hosted by any programming language because the logic simply looks up a value in a table and then acts accordingly .", "label": "", "metadata": {}, "score": "47.021584"}
{"text": "( 3 ) Our method significantly outperformed Greenwood et al .[ 12 ] , which also used MINIPAR ( see Table 4 ) .( 4 ) When the second or third phase was removed , the precision became significantly worse ( see Table 5 ) .", "label": "", "metadata": {}, "score": "48.813076"}
{"text": "The parser now has two complete verb symbols and it extends , or looks , for states that need a verb that starts at either frame 2 or frame 3 and finds an S that corresponds to both back in state 8 and state 4 .", "label": "", "metadata": {}, "score": "49.06905"}
{"text": "by Terence J. Parr , Russell W. Quong - In Computational Complexity , 1994 .Most language translation problems can be solved with existing LALR(1 ) or LL(k ) language tools ; e.g. , YACC [Joh78 ] or ANTLR [ PDC92].", "label": "", "metadata": {}, "score": "49.4225"}
{"text": "For example , our clus- tering algorithm grouped first names in one group and measurements in another .We then added the cluster membership as a lexical feature to the parser .None of the resulting features helped adaptation .3.2Diversity Training diversity may be an effective source for adaptation .", "label": "", "metadata": {}, "score": "49.61046"}
{"text": "After alignment of positive and negative rule sets , we construct direction rules from the two rule sets .In Algorithm 3 , ( 3.1 ) case indicates that direction information C is changed to ANY .Since the same direction exists in both the positive and negative rule sets , the direction information is not trustworthy .", "label": "", "metadata": {}, "score": "50.132378"}
{"text": "20 , no .18 , pp .3604 - 3612 , 2004 .View at Publisher \u00b7 View at Google Scholar .N. Daraselia , A. Yuryev , S. Egorov , S. Novichkova , A. Nikitin , and I. Mazo , \" Extracting human protein interactions from MEDLINE using a full - sentence parser , \" Bioinformatics , vol .", "label": "", "metadata": {}, "score": "50.434875"}
{"text": "It is the computation of these tables that is both time - consuming and complex .Once created , these parsing tables are essentially independent of any programming language binding .As if to prove this point , the GOLD developers have implemented a dozen language bindings as of this writing ( as either linkable .", "label": "", "metadata": {}, "score": "51.121838"}
{"text": "This paper outlines our participation in the 2007 CoNLL Shared Task on Domain Adaptation ( Nivre et al . , 2007 ) .The goal was to adapt a parser trained on a single source domain to a new target domain us- ing only unlabeled data .", "label": "", "metadata": {}, "score": "51.26106"}
{"text": "To confirm that nouns were problem- atic , we modified a first - order parser ( no second or- der features ) by adding a feature indicating correct noun - noun edges , forcing the parser to predict these edges correctly .", "label": "", "metadata": {}, "score": "51.68254"}
{"text": "Like most parsing systems , GOLD uses the LALR(1 ) state machine ( algorithm ) to analyze syntax and a Deterministic Finite Automaton ( DFA ) to identify different lexical units ( tokenizer ) .Practically all common parser generators , such as YACC / Bison , use these algorithms .", "label": "", "metadata": {}, "score": "51.722603"}
{"text": "In particular , programmers implement translators not recognizers .Yet too often , translation is equated with the simpler task of syntactic parsing .This misconception coupled with computing limitations of past computers has led to the almost exclusive use of LR(1 ) and LL(1 ) in parser generators .", "label": "", "metadata": {}, "score": "52.21991"}
{"text": "Goadrich et al .[14 ] used Gleaner as an inductive logic programming approach and further applied Brill Tagger , a shallow parser based on conditional random fields , and Porter stemmer .They also used much linguistic information , including sentence - structure predicates , the frequencies of words , lexical properties , and semantic knowledge using Mesh .", "label": "", "metadata": {}, "score": "52.259808"}
{"text": "A syntactic relation is important linguistic information for detecting the structure of text .Algorithm 1 shows one example of syntactic relations between two genes in the LLL05 data .The syntactic relations provided in LLL05 were of the form . assigned by the LLL parser .", "label": "", "metadata": {}, "score": "52.397194"}
{"text": "Many studies have used linguistic information to improve performance in detecting gene interactions .To improve recall without sacrificing precision , Otasek et al .[ 8 ] expanded the diversity of sentence structures recognized by a syntactic parser through additional training , and Park et al .", "label": "", "metadata": {}, "score": "52.470425"}
{"text": "5 , pp .604 - 611 , 2004 .View at Publisher \u00b7 View at Google Scholar .B. J. Stapley , L. A. Kelley , and M. J. Sternberg , \" Predicting the sub - cellular location of proteins from text using support vector machines , \" in Proceedings of the 7th Pacific Symposium on Biocomputing , pp .", "label": "", "metadata": {}, "score": "52.547462"}
{"text": "Furthermore the processor will output a score of for best sentence explanation at grammar level 0 ( FIG .2 ) , which is the sentence level grammar .After reading the vector of grammars , in the preferred embodiment , the processor will then input an ending frame indicator n. Although this is not required , it makes the algorithm more complete .", "label": "", "metadata": {}, "score": "52.63345"}
{"text": "This continues until all of the input has advanced up to sentence grammar level 0 and advanced S over several time frames to cover all of the input data .At this point , the processor has completed its parse and outputs its hypothesis of the spoken input .", "label": "", "metadata": {}, "score": "52.70706"}
{"text": "[ 2 ] .The solution generally consists of feeding information from the semantic symbol table back into the lexer .That is , rather than functioning as a pure one - way pipeline from the lexer to the parser , there is a backchannel from semantic analysis back to the lexer .", "label": "", "metadata": {}, "score": "52.757057"}
{"text": "( b ) Complete .In implementing the above algorithm , the processor reads a vector of grammars representing any number of grammar levels .Looking for the moment at FIG .2 , an example of grammar levels is shown .", "label": "", "metadata": {}, "score": "52.994457"}
{"text": "This is because of the errors in syntactic relations and POS - tags that MINIPAR produced .Conclusion .To improve recall without sacrificing precision , this paper proposes a three - phase method for the automatic detection of gene interactions using syntactic relations .", "label": "", "metadata": {}, "score": "53.20292"}
{"text": "5 is a graph showing the effect of chart parsing on pruning as employed by the present invention .DETAILED DESCRIPTION OF A PREFERRED EMBODIMENT .The present invention discloses a method which makes use of an algorithm ( discussed below ) which includes a parsing subalgorithm to affect the central data structure of a spoken language processor .", "label": "", "metadata": {}, "score": "53.41243"}
{"text": "Figure 1 also shows an example of direction information of a syntactic path .Among the directions , we retrieve only the direction information of an interaction verb .The direction information is dependent on the syntactic category of the relation and the lexical word of the current node .", "label": "", "metadata": {}, "score": "53.443848"}
{"text": "Several works examining gene interactions are based on LLL05 open data .Hakenberg et al .[ 11 ] used sentence alignment and finite - state automata optimized with a genetic algorithm .First , they applied a pattern - generating algorithm .", "label": "", "metadata": {}, "score": "53.493866"}
{"text": "In what follows , we provide an er- ror analysis that attributes domain loss for this task to a difference in annotation guidelines between do- mains .We then overview our attempts to improve adaptation .While we were able to show limited adaptation on reduced training data or with first- order features , no modifications improved parsing with all the training data and second - order features .", "label": "", "metadata": {}, "score": "54.241165"}
{"text": "It saves time and memory space by expanding symbols only once .The present invention extends Earley 's basic CFG parsing algorithm to combine rule and observation probabilities with the use of unification grammars .This retains the Earley algorithm complexity while extending the results to spoken input recognition : linear for regular grammars , quadratic for unambiguous CFGs , and cubic for general CFGs .", "label": "", "metadata": {}, "score": "54.302"}
{"text": "This allows a much cleaner separation of concerns and encapsulation of the lexer and parser , and is therefore considered a much more elegant solution than The Lexer Hack by most modern software design metrics .[ 4 ] This is also the approach used in most other modern languages , which do not distinguish different classes of identifiers in the lexical grammar , but instead defer them to the parsing or semantic analysis phase , when sufficient information is available .", "label": "", "metadata": {}, "score": "54.35202"}
{"text": "A CCG parser handled both POS - tagging and parsing .However , recall was only 46.2 % , and the system needs to improve recall .For GENIA and ATCR data , Rinaldi et al .[ 18 ] also used linguistic approach .", "label": "", "metadata": {}, "score": "54.61795"}
{"text": "Accordingly , it is intended that the invention be limited only in terms of the appended claims .Trehan , R. et al . , A paralle chart parser for the committed choice non deterministic logic languages , IEEE Proceedings of the Fifth International Conference and Symposium : Logic Programming , Seattle , WA , Aug. 1988 , 212 232 , vol .", "label": "", "metadata": {}, "score": "54.864456"}
{"text": "We observe redundancy levels of about 30 % and non - standard distribution of both words and concepts .We measure the impact of redundancy on two standard text - mining applications : collocation identification and topic modeling .We compare the results of these methods on synthetic data with controlled levels of redundancy and observe significant performance variation .", "label": "", "metadata": {}, "score": "54.899506"}
{"text": "Another goal of the present invention is to provide a chart parser that correctly computes hypothesis probabilities in an efficient manner for CFGs and stochastic unification grammars , by interleaving the search for explanations of symbols from both the top down and from the bottom up .", "label": "", "metadata": {}, "score": "54.92542"}
{"text": "We found certain scaling techniques obtained tiny improvements on the target domain that , while significant compared to competition results , are not statistically significant .We also attempted a sim- ilar approach on the feature level .A very predic- tive source domain feature is not useful if it does not appear in the target domain .", "label": "", "metadata": {}, "score": "54.9593"}
{"text": "This enters into an infinite loop and will cause a stack overflow exception .The workaround is to rewrite the recursive rule as an iterative rule .This rule recognizes the desired expressions but unfortunately produces a parse - tree which can introduce undesired complexity into an evaluator or compiler .", "label": "", "metadata": {}, "score": "55.512142"}
{"text": "This enters into an infinite loop and will cause a stack overflow exception .The workaround is to rewrite the recursive rule as an iterative rule .This rule recognizes the desired expressions but unfortunately produces a parse - tree which can introduce undesired complexity into an evaluator or compiler .", "label": "", "metadata": {}, "score": "55.512142"}
{"text": "FIG .4 is an example of a typical left recursive rule showing rule probabilities , using a treatment of conjunctions and disjunctions such as \" a or b or d \" .As seen in portion A of FIG .4 , the example shown has the four terminal symbols : a , b , d and \" or \" .", "label": "", "metadata": {}, "score": "55.651413"}
{"text": "Instead , we scaled each feature 's value by a factor proportional to its frequency in the target do- main and trained the parser on these scaled feature values .We obtained small improvements on small amounts of training data .Target Focused Learning 4 Future Directions Given our pessimistic analysis and the long list of failed methods , one may wonder if parser adapta- tion is possible at all .", "label": "", "metadata": {}, "score": "55.69072"}
{"text": "Gleaner suffered from not distinguishing between an agent and a target well because no syntactic structure was used .Popelinsky and Blatak [ 15 ] used Brill Tagger and WordNet , and Katrenko et al .[ 16 ] created a simple ontology specifically for use in the LLL05 challenge .", "label": "", "metadata": {}, "score": "55.911003"}
{"text": "Our suspicions are supported by the observation that no team was able to im- prove target domain performance substan- tially over a state of the art baseline . 1 Introduction Dependency parsing , an important NLP task , can be done with high levels of accuracy .", "label": "", "metadata": {}, "score": "55.932934"}
{"text": "DESCRIPTION OF THE DRAWINGS .FIG .1 is a block diagram showing a speech recognition processor which employs the present invention ; .FIG .2 is a stack diagram demonstrating a possible grammar level structure and positioning as used by the present invention ; .", "label": "", "metadata": {}, "score": "56.05859"}
{"text": "We began with the first ap- proach and removed a large number of features that we believed transfered poorly , such as most features for noun - noun edges .We obtained a small improve- ment in BIO performance on limited data only .", "label": "", "metadata": {}, "score": "56.254047"}
{"text": "A recursive descent parser uses a set of mutually recursive procedures to recognize syntactic elements in the language .A back - tracking parser will try parsing a set of rules in order , when facing a choice , until one succeeds .", "label": "", "metadata": {}, "score": "56.310997"}
{"text": "A recursive descent parser uses a set of mutually recursive procedures to recognize syntactic elements in the language .A back - tracking parser will try parsing a set of rules in order , when facing a choice , until one succeeds .", "label": "", "metadata": {}, "score": "56.310997"}
{"text": "Blaschke et al .[ 10 ] assumed that sentences derived from sets of abstracts contained a significant number of protein names connected by verbs that indicate the type of relationship between them .They restricted the problem domain and imposed several strong assumptions that included prespecified protein names and a limited set of verbs to represent actions .", "label": "", "metadata": {}, "score": "56.35618"}
{"text": "Unfortunately , conventional macroprocessing is oblivious to the semantics of the base language , resulting in scoping anomalies , poor handling of static semantic errors , and an inability to perform transformations dependent on semantic attributes of the manipulated program .We introduce a new mechanism , semantic macros , which permit such transformations a significant level of access to the static semantic properties of the program fragments they manipulate .", "label": "", "metadata": {}, "score": "56.41351"}
{"text": "( 3 )The change in performance when each phase is removed .In the experiments , we obtained the following five results .( 1 ) Our three - phase detection method for gene interactions achieved an F - measure of 67.2 % using LLL05-annotated syntactic relations , and 44.0 % using a real - syntactic analyzer ( see Tables 3 and 4 ) .", "label": "", "metadata": {}, "score": "56.649277"}
{"text": "Knowing this , the possible uses for this feature increase dramatically .For example : .Here , after the initial expansion the prerequisites of both the main and lib targets will be $ ( $ @_OBJS ) .You can also mix in functions here , as long as they are properly escaped : .", "label": "", "metadata": {}, "score": "56.663296"}
{"text": "The system for parsing of claim 20 , wherein said language model incorporates context - free grammars .A method for parsing a spoken sentence having a plurality of words , comprising the steps of : .( a ) inputting a desired spoken input composed of a plurality of grammar levels ; .", "label": "", "metadata": {}, "score": "56.710327"}
{"text": "[ 12 ] mentioned the failure of the system to extract meaningful relations can be traced back to the errors of the applied syntactic analyzer .If we use the annotated LLL05 syntactic relation information , we can not testify the robustness of our system in real time .", "label": "", "metadata": {}, "score": "56.734108"}
{"text": "Our method achieved a precision of 67.9 % , a recall of 66.6 % , an F - measure of 67.2 % using LLL05 syntactic relations .We conclude that our proposed three - phase method is effective for detecting gene interactions .", "label": "", "metadata": {}, "score": "56.796303"}
{"text": "\" In Figure 1 , mod_att and comp_of are examples of the syntactic encapsulation categories .To detect a metaagent and a metatarget , we should first identify an interaction verb in a syntactic chain .However , in the automatically obtained syntactic chains , we do not know which verb is an interaction verb .", "label": "", "metadata": {}, "score": "56.80416"}
{"text": "The efficiency of the parser makes it applicable to multiple levels of a spoken language system ( e.g. , sentence , word , phoneme , and phone levels ) .( n ) parsing terminal symbols from the current grammar level as start symbols for the next lower grammar level unless at the lowest grammar level ; .", "label": "", "metadata": {}, "score": "56.94129"}
{"text": "GOLD is freeware and uses the \" zlib \" style license so you can integrate it with your own apps without worry .In GOLD , the LALR and DFA algorithms are merely simple automata , using lookup tables to determine both state transition and parsing actions .", "label": "", "metadata": {}, "score": "56.94587"}
{"text": "Figure 2 shows the reverse syntactic path from a target to its agent of the sentence in Figure 1 .The positive and negative rules for the sentence in Figure 1 are shown in Table 1 .From the positive and negative rule sets , we construct direction rules according to the following subsections .", "label": "", "metadata": {}, "score": "57.023533"}
{"text": "The thesis starts by presenting a new unification algorithm , justifies why it is well - suited to practical NL parsing , and describes a bottom - up active chart parser which employs this unification algorithm together with several other novel processing and optimisation techniques .", "label": "", "metadata": {}, "score": "57.05892"}
{"text": "aFor text mining , preprocessing the EHR corpus with fingerprinting yields significantly better results .Conclusions Before applying text - mining techniques , one must pay careful attention to the structure of the analyzed corpora .While the importance of data cleaning has been known for low - level text characteristics ( e.g. , encoding and spelling ) , high - level and difficult - to - quantify corpus characteristics , such as naturally occurring redundancy , can also hurt text mining .", "label": "", "metadata": {}, "score": "57.05954"}
{"text": "Grammars are completely independent of any implementation language or platform .Instead , the application analyzes the grammar and then saves the parse tables to a separate file .This file can be subsequently loaded by the actual parser engine and used .", "label": "", "metadata": {}, "score": "57.094017"}
{"text": "Riedel and Klein [ 17 ] obtained the best performance on the LLL05 challenge task using syntactic chains .They assumed that clauses had to connect both genes transitively .Therefore , they generated a set of clauses based on chains of syntactic relations between two genes .", "label": "", "metadata": {}, "score": "57.218834"}
{"text": "The parser operates frame synchronously to provide top - down hypotheses and to incorporate observation probabilities as they become available .A chart parser is disclosed which incorporates rule and observation probabilities with stochastic unification grammars .The parser operates frame synchronously to provide top - down hypotheses and to incorporate observation probabilities as they become available .", "label": "", "metadata": {}, "score": "57.296585"}
{"text": "In particular , syntactic relations among linguistic information are good for detecting gene interactions .However , previous systems give a reasonably good precision but poor recall .To improve recall without sacrificing precision , this paper proposes a three - phase method for detecting gene interactions based on syntactic relations .", "label": "", "metadata": {}, "score": "57.461117"}
{"text": "We will summarize the significance of each phase introduced in Section 3 .As shown in Table 5 , every phase is important for its performance .Without the first phase , if no syntactic relations are considered encapsulation categories , then no pairs of genes are generated .", "label": "", "metadata": {}, "score": "57.46727"}
{"text": "( 3 ) Otherwise , if the current lexical word is an interaction verb and the direction of the next node candidate is consistent with the direction rules , then we extend the syntactic chain .In the finally obtained syntactic chains , we determine that the first node is an agent and the last node is its target .", "label": "", "metadata": {}, "score": "57.623375"}
{"text": "These models provide good recognition results when perplexity can be minimized , but preclude any direct support for spoken language systems by eliminating the semantic level .Language models have traditionally proven valuable in natural language systems , but only during the past decade have computationally - oriented , declarative grammar formalisms become widely available .", "label": "", "metadata": {}, "score": "57.632275"}
{"text": "These rules add a new instance of a Node to a parse tree if the associated rule is matched successfully .Calling the Rule .Parse ( ) function will return a list of parse nodes , each one the root of a parse tree .", "label": "", "metadata": {}, "score": "57.667843"}
{"text": "These rules add a new instance of a Node to a parse tree if the associated rule is matched successfully .Calling the Rule .Parse ( ) function will return a list of parse nodes , each one the root of a parse tree .", "label": "", "metadata": {}, "score": "57.667843"}
{"text": "Returning again to FIG .2 , the processor looks at the inputted grammar and sees that there is a symbol , say S , that corresponds to a sentence .The processor proceeds to the parse function , does the prediction and completion , and finds out that it needs some words which are terminal symbols in the sentence grammar level .", "label": "", "metadata": {}, "score": "57.919613"}
{"text": "( s ) between steps ( d ) and ( e ) , reading an ending frame indicator ; and .( t ) after step ( n ) , incrementing a frame counter .The method for parsing of claim 25 , further comprising the steps of : .", "label": "", "metadata": {}, "score": "57.97664"}
{"text": "To objectively compare the performance of our system with that of previous systems , we use LLL05 data .In the next section , we explain our proposed three - phase method in detail .Three - Phase Detection of Gene Interactions .", "label": "", "metadata": {}, "score": "58.031082"}
{"text": "In the third phase , we propose learning the directions of the syntactic relations in the syntactic path from an agent to its target .If we do not permit the reverse direction , the agent and target will not be detected wrongly and thus improve the precision .", "label": "", "metadata": {}, "score": "58.031616"}
{"text": "J. Saric , L. Jensen , R. Ouzounova , I. Rojas , and P. Bork , \" Large - scale extraction of protein / gene relations for model organisms , \" in Proceedings of the Symposiumon SemanticMining in Biomedicine , p. 50 , Hinxton , Cambridgeshire , UK , April 2005 .", "label": "", "metadata": {}, "score": "58.271122"}
{"text": "Text - mining methods in particular can help disease modeling by mapping named - entities mentions to terminologies and clustering semantically related terms .EHR corpora , however , exhibit specific statistical and linguistic characteristics when compared with corpora in the biomedical literature domain .", "label": "", "metadata": {}, "score": "58.373905"}
{"text": "S. Riedel and E. Klein , \" Genic interaction extraction with semantic and syntactic chains , \" in Proceedings of the ICML05 Workshop on Learning Language in Logic ( LLL ' 05 ) , Bonn , Germany , August 2005 . D. Lin , \" Dependency - based evaluation of MINIPAR , \" in Proceedings of the Workshop on the Evaluation of Parsing Systems , Granada , Spain , May 1998 .", "label": "", "metadata": {}, "score": "58.39345"}
{"text": "Memoizing PEG parsers are also known as Packrat parsers .A PEG ( Parsing Expression Grammar ) parser recognizes grammars where each rule corresponds directly to a pattern matching algorithm .A more common alternative to PEG are predictive LR parsers ( of which there are many ) but they are more complicated .", "label": "", "metadata": {}, "score": "58.40504"}
{"text": "Memoizing PEG parsers are also known as Packrat parsers .A PEG ( Parsing Expression Grammar ) parser recognizes grammars where each rule corresponds directly to a pattern matching algorithm .A more common alternative to PEG are predictive LR parsers ( of which there are many ) but they are more complicated .", "label": "", "metadata": {}, "score": "58.40504"}
{"text": "The experiments prove that the second and third phases contribute to the improvement of precision , and the first phase to the improvement of recall .We conclude that all three phases are important for detecting gene interactions .To experiment the robustness of our method in real time , we have used MINIPAR , an existing syntactic analyzer .", "label": "", "metadata": {}, "score": "58.48134"}
{"text": "If the processor is not on the bottom level , then it will predict the terminal symbols at the next lower level and proceed to parse .The processor will scan observations from a lower grammar level into the current grammar level .", "label": "", "metadata": {}, "score": "58.59021"}
{"text": "In addition to a change in the annotation guide- lines for NPs , we observed an important difference in the distribution of POS tags .NN tags were almost twice as likely in the BIO domain ( 14 % in WSJ and 25 % in BIO ) .", "label": "", "metadata": {}, "score": "58.748"}
{"text": "Performance of Our Three - Phase Method versus Those of Other Methods .With more and more biomedical datasets becoming publicly available , there has been some research effort on corpus design issues and usage in biomedical natural language processing [ 22 , 23 ] .", "label": "", "metadata": {}, "score": "58.797653"}
{"text": "Without any domain knowledge of biomolecular text , we automatically detect gene interactions using syntactic relations annotated in the LLL05 data .In the first phase , to improve recall , we detect the relations that encapsulate an agent or target .", "label": "", "metadata": {}, "score": "58.90335"}
{"text": "Phase 2 : Extracting Interaction Verbs that Indicate an Interaction between Two Genes .To detect gene interactions , we must recognize the interaction verbs .In the second phase , we retrieve the interaction verbs that indicate an interaction between two genes .", "label": "", "metadata": {}, "score": "58.955963"}
{"text": "In order to take advantage of the secondary expansion phase of the parser , then , it 's necessary to escape the variable or function reference in the makefile .In this case the first expansion merely un - escapes the reference but does n't expand it , and expansion is left to the secondary expansion phase .", "label": "", "metadata": {}, "score": "58.96264"}
{"text": "[ Show abstract ] [ Hide abstract ] ABSTRACT : Dependency parsing is a central NLP task .In this paper we show that the common evaluation for unsupervised dependency parsing is highly sensitive to problematic annotations .We show that for three leading unsupervised parsers ( Klein and Manning , 2004 ; Cohen and Smith , 2009 ; Spitkovsky et al .", "label": "", "metadata": {}, "score": "58.997826"}
{"text": "Accepted Poster Presentations .Philippe Blache , Meta - level constraints for representing interaction .between linguistic domains .Vladimir Kadlec , Pavel Smrz , PACE --- Parser Comparison and .Evaluation .Mi - Young Kim , Jong - Hyeok Lee , S_clause Segmentation for Efficient .", "label": "", "metadata": {}, "score": "59.058285"}
{"text": "This can be useful in text editors , or when doing source - to - source translation .The Printer class in the Jigsaw library facilitates writing custom source translators .By deriving from Printer , you only need to override the Print ( ) function and can then easily generate output depending on the kind of node received .", "label": "", "metadata": {}, "score": "59.064808"}
{"text": "This can be useful in text editors , or when doing source - to - source translation .The Printer class in the Jigsaw library facilitates writing custom source translators .By deriving from Printer , you only need to override the Print ( ) function and can then easily generate output depending on the kind of node received .", "label": "", "metadata": {}, "score": "59.064808"}
{"text": "We added features indicating when an edge was predicted by another parser and if an edge crossed a predicted edge , as well as conjunctions with edge types .This failed to improve BIO accuracy since these features were less reliable at test time .", "label": "", "metadata": {}, "score": "59.188347"}
{"text": "Although Engine implementations vary in design , they all behave identically because they completely are table - driven with respect to the input .Mechanically speaking , this means each time you modify the grammar file , you 'll run the Builder to regenerate the CGT file .", "label": "", "metadata": {}, "score": "59.250977"}
{"text": "In Conference on Natural Language Learning ( CoNLL ) .J. Nivre , J. Hall , S. K\u00a8 ubler , R. McDonald , J. Nils- son , S. Riedel , and D. Yuret .2007 shared task on dependency parsing . of the CoNLL 2007 Shared Task .", "label": "", "metadata": {}, "score": "59.32778"}
{"text": "Score calculation includes the detection of these cycles and propagation of the best scores to the next frame .The algorithm creates no more states than a nonprobilistic chart parser , and remains linear for regular grammars and cubic in the worst case for CFGs .", "label": "", "metadata": {}, "score": "59.333054"}
{"text": "Eugene Charniak ( Brown University ) , Syntax- based Language Models for .Statistical Machine Translation .Gregory Grefenstette ( Claivoyance Corporation , Pittsburgh ) , Why Parse ?Statistical Processing or Symbolic Processing . accepted papers : .Parsing Tree Adjoining Grammars and Tree Insertion Grammars with . simultaneous adjunctions .", "label": "", "metadata": {}, "score": "59.61624"}
{"text": "Mark - Jan Nederhof , Giorgio Satta , Stuart M. Shieber , Partially .Ordered Multiset Context - Free Grammars and ID / LP Parsing .Joakim Nivre , An Efficient Algorithm for Projective Dependency .Parsing .Kilian Foth , Wolfgang Menzel , Subtree Parsing to Speed up Deep .", "label": "", "metadata": {}, "score": "59.65771"}
{"text": "Since the processor is at a terminal symbol , it can then perform this algorithm because all states have been predicted and completed and there is no more information available to enable it to predict or complete any more states .The processor will predict at level 1 + 1 , which is the next lower level .", "label": "", "metadata": {}, "score": "59.658043"}
{"text": "To address conflicting annota-1053 .Page 4 . tions , we added slack variables to the MIRA learn- ing algorithm ( Crammer et al . , 2006 ) used to train the parsers , without success .We measured diversity by comparing the parses of each model .", "label": "", "metadata": {}, "score": "59.97908"}
{"text": "First , there may be room for adaptation with our domains if a common annotation scheme is used .Second , we have stressed that typical adaptation , modifying a model trained on the source domain , will fail but there may be unsupervised parsing techniques that improve performance after adaptation , such as a rule based NP parser for BIO based on knowledge of the annotations .", "label": "", "metadata": {}, "score": "60.41906"}
{"text": "An example is the above BIO NP , in which the phrase \" glutathione transferase P1 - 1 \" is an appositive indicating which \" enzyme \" is meant .However , since there are no commas , the parser thinks \" P1 - 1 \" is the head .", "label": "", "metadata": {}, "score": "60.45678"}
{"text": "Once it has a complete noun from frame 0 to frame 2 , it checks if there are any symbols that ended at zero that needed a noun that it can complete and finds there was one starting with S in the very first state .", "label": "", "metadata": {}, "score": "60.489693"}
{"text": "1 , an input device 10 receives input from a user and transmits the input along connecting element 12 to processor 14 .Processor 14 contains a central data structure , known as a chart 24 , not shown , where the algorithm is implemented .", "label": "", "metadata": {}, "score": "60.692604"}
{"text": "In JavaScript , when a variable is declared , it is added to the list of variable bindings .When a \" block \" goes out of scope , all names declared in that scope are unbound .In Jigsaw , this is done in a function called \" EvalScoped \" .", "label": "", "metadata": {}, "score": "60.72766"}
{"text": "In JavaScript , when a variable is declared , it is added to the list of variable bindings .When a \" block \" goes out of scope , all names declared in that scope are unbound .In Jigsaw , this is done in a function called \" EvalScoped \" .", "label": "", "metadata": {}, "score": "60.72766"}
{"text": "39 , no . 2 , pp .127 - 136 , 2007 .View at Publisher \u00b7 View at Google Scholar .S. Zhao and R. Grishman , \" Extracting relations with integrated information using kernel methods , \" in Proceedings of the Association for Computational Linguistics , pp .", "label": "", "metadata": {}, "score": "60.82469"}
{"text": "For the most common 1While only 8 teams participated in the closed track with us , our score beat all of the teams in the open track .Page 2 .The parser was trained on the provided WSJ data .Digits are less than 4 % of the tokens in BIO .", "label": "", "metadata": {}, "score": "60.91021"}
{"text": "3 labeled B discloses a word lattice , which is the input to the system ( in this example ) showing the beginning and ending frames of each of the word hypotheses .The lattice contains a plurality of lines which show the logarithmic probability of seeing a particular word over a particular span of data and gives such probability as a negative number .", "label": "", "metadata": {}, "score": "61.00185"}
{"text": "3A - C show an example demonstrating frame synchronous parsing using probabilities employed by the present invention ; .FIGS .4A - D show an example showing a typical left recursive rule showing rule probabilities correctly computed by the present invention ; and .", "label": "", "metadata": {}, "score": "61.110664"}
{"text": "The problem also exists in C++ and parsers can use the same hack .[ 1 ] .This problem does not arise ( and hence needs no \" hack \" in order to solve ) when using lexerless parsing techniques , as these are intrinsically contextual .", "label": "", "metadata": {}, "score": "61.33748"}
{"text": "( s ) parsing said start symbols according to the spoken input and grammars to produce observations of said symbols ; and .( t ) explaining the input based on the results of said step of parsing .The method for recognizing spoken sentences of claim 3 , further comprising the steps of : .", "label": "", "metadata": {}, "score": "61.425533"}
{"text": "The processor then loops down to the bottom level , advances as many states as possible and then returns to parse .This shows a mutually recursive relationship between hypothesize and parse .rh o.+(\u03c3.sub.\u03bf -\u03c3 ) ] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ .", "label": "", "metadata": {}, "score": "61.5038"}
{"text": "However , our results were obtained without adap- tation .Given our position in the ranking , this sug- gests that no team was able to significantly improve performance on either test domain beyond that of a state - of - the - art parser .", "label": "", "metadata": {}, "score": "61.593796"}
{"text": "Many studies have indeed shown that cross - domain learned corpora yield poor language models [ 35].The field of domain adaptation attempts to compensate for the poor quality of cross - domain data , by adding carefully picked text from other domains [ 36,37 ] or other statistical mitigation techniques .", "label": "", "metadata": {}, "score": "61.670723"}
{"text": "Mark - Jan Nederhof , Giorgio Satta , Probabilistic Parsing as .Intersection .Khalil Sima'an , On Maximizing Metrics for Syntactic Disambiguation .Hiroyasu Yamada , Yuji Matsumoto , Statistical Dependency Analysis with .Support Vector Machines .Gennaro Costagliola , Vincenzo Deufemia , Visual Language Editors based .", "label": "", "metadata": {}, "score": "61.826447"}
{"text": "We tried a number of criteria to weigh sentences without suc- cess , including sentence length and number of verbs .Next , we trained a discriminative model on the pro- vided unlabeled data to predict the domain of each sentence based on POS n - grams in the sentence .", "label": "", "metadata": {}, "score": "61.866447"}
{"text": "But how does the observed EHR redundancy affect text mining ?Does such redundancy introduce a bias that distorts learned models ?Or does the redundancy introduce benefits by highlighting stable and important subsets of the corpus ?( iii )How can one mitigate the impact of redundancy on text mining ?", "label": "", "metadata": {}, "score": "61.972954"}
{"text": "3 Adaptation Approaches We survey the main approaches we explored for this task .While some of these approaches provided a modest performance boost to a simple parser ( lim- ited data and first - order features ) , no method added any performance to our best parser ( all data and second - order features ) .", "label": "", "metadata": {}, "score": "61.99163"}
{"text": "Due to the variability and ambiguity of a spoken input signal , modified algorithms were created to improve on Earley 's algorithm and to adapt it to spoken language recognition .An example of such a modified algorithm is shown in A. Paeseler , ' Modification of Earley 's Algorithm for Speech Recognition ' , Proc . of NATO ASI , Bad Windsheim , 1987 .", "label": "", "metadata": {}, "score": "62.000603"}
{"text": "References Shai Ben - David , John Blitzer , Koby Crammer , and Fer- nando Pereira .Analysis of representations for domain adaptation .In NIPS .Leo Breiman .Learning , 24(2):123 - 140 .Bagging predictors .Machine R. Brown .", "label": "", "metadata": {}, "score": "62.105476"}
{"text": "Thus , within a longitudinal patient record , one expects to observe heavy redundancy .In this paper , we ask three research questions : ( i ) How can redundancy be quantified in large - scale text corpora ?( ii )", "label": "", "metadata": {}, "score": "62.154366"}
{"text": "This was an experimental challenge for gene interactions using linguistic information .Previous studies have insisted that linguistic information was useful for improving the detection of gene interactions .However , the experimental results for the LLL05 data gave a reasonable precision but poor recall .", "label": "", "metadata": {}, "score": "62.206394"}
{"text": "In the second phase , we construct a verb list that indicates the nature of the interaction between pairs of genes .In the last phase , we determine direction rules to detect which of two genes is the agent or target .", "label": "", "metadata": {}, "score": "62.433403"}
{"text": "Explanations of each of those different functions are given below .Further assume all symbols are at level 1 unless otherwise indicated .If B 1 and B 2 are atomic symbols for context - free grammars , then they are unified by default .", "label": "", "metadata": {}, "score": "62.719368"}
{"text": "Below that is word grammar level 1 , and below that is phoneme grammar level 2 .The next lower level shown is phone grammar level 3 .Each lower level contains narrower and narrower portions of the inputted data until the lowest level or reference frame grammar level 1 is reached .", "label": "", "metadata": {}, "score": "62.722984"}
{"text": "Since the guidelines differ , we observe no corresponding structure in the WSJ .It is telling that the parser labels this BIO example by attaching ev- ery token to the final proper noun \" P1 - 1 \" , exactly as the WSJ guidelines indicate .", "label": "", "metadata": {}, "score": "62.74206"}
{"text": "Greenwood et al .[ 12 ] extracted patterns based on paths in MINIPAR dependency trees [ 13 ] .The nodes in the dependency trees from which patterns were derived were either a lexical item or a semantic category , such as a gene , protein , agent , or target .", "label": "", "metadata": {}, "score": "62.749878"}
{"text": "Intermediate Results .Some recursive - descent parsers can take extremely long to parse certain inputs .A solution to this is to cache intermediate parse results in a look - up table .This technique is called memoization .In the Jigsaw library , all NodeRule match results are cached in a dictionary stored in the ParserState object .", "label": "", "metadata": {}, "score": "62.862564"}
{"text": "Intermediate Results .Some recursive - descent parsers can take extremely long to parse certain inputs .A solution to this is to cache intermediate parse results in a look - up table .This technique is called memoization .In the Jigsaw library , all NodeRule match results are cached in a dictionary stored in the ParserState object .", "label": "", "metadata": {}, "score": "62.862564"}
{"text": "We describe some challenges of adaptation in the 2007 CoNLL Shared Task on Domain Adaptation .Our error analysis for this task suggests that a primary source of error is differences in annotation guidelines between treebanks .Our suspicions are supported by the observation that no team was able to improve target domain performance substantially over a state of the art baseline .", "label": "", "metadata": {}, "score": "63.05719"}
{"text": "It demonstrates that the syntactic encapsulation categories contribute to the improvement of recall .Without the second phase , if all the verbs are considered interaction verbs , the precision is very low , which results from the generation of too many wrong syntactic paths .", "label": "", "metadata": {}, "score": "63.073166"}
{"text": "The tree in portion B reflects the desired outcome of this parse .The tree shows that to recognize this input the parser has to use a left recursive rule two times and the non - left recursive S choice , which is S goes to C , once at the bottom .", "label": "", "metadata": {}, "score": "63.20432"}
{"text": "METHOD : .Repeat the following two steps until no new states can be added : .( a ) Predict .( b ) Complete .Hypothesize .Scan .Repeat the following two steps until no new states can be added : .", "label": "", "metadata": {}, "score": "63.327354"}
{"text": "But in order to expand those subsequent symbols , according to Paeseler 's algorithm , the best probability must be known , otherwise if a better probability appears , the parsing must be redone .This means potentially an exponential amount of work , which is highly undesirable .", "label": "", "metadata": {}, "score": "63.340157"}
{"text": "3 , an example of frame synchronous parsing using probabilities is demonstrated .In the portion labeled A , a simple grammar is given which consists of one rule , namely sentence rewrites to a noun and a verb .One noun \" boys \" and two verbs \" sleep \" and \" leap \" are given .", "label": "", "metadata": {}, "score": "63.487755"}
{"text": "It should be noted , however , that the frame counter may be incremented at other times during the execution of the algorithm depending on how one wants to keep track of the frames .At this point , either the states are complete or are reported as observations to the next higher grammar level .", "label": "", "metadata": {}, "score": "63.546173"}
{"text": "While the first phase contributes to improve recall , the second and third phases contribute to improve precision .In the experimental results using ICML 05 Workshop on Learning Language in Logic ( LLL05 ) data , our proposed method gave an F - measure of 67.2 % for the test data , significantly outperforming previous methods .", "label": "", "metadata": {}, "score": "63.615368"}
{"text": "The LLL05 challenge focuses on extracting information on gene interactions in Bacillus subtilis .The training dataset is decomposed into two subsets of increasing difficulty .The first subset does not include coreferences or ellipsis , unlike the second subset .The training set without coreferences consists of 55 sentences , including 106 examples of genic interactions .", "label": "", "metadata": {}, "score": "63.857887"}
{"text": "However , this would have made debugging harder and would have had a significant negative impact on performance .A more efficient approach to this problem is to rewrite the parse tree so that there is only one \" return \" statement at the end of a function .", "label": "", "metadata": {}, "score": "63.998165"}
{"text": "However , this would have made debugging harder and would have had a significant negative impact on performance .A more efficient approach to this problem is to rewrite the parse tree so that there is only one \" return \" statement at the end of a function .", "label": "", "metadata": {}, "score": "63.998165"}
{"text": "Needing to explicitly set the names of node rules .You can work around these issues by defining all rules in a class derived from Grammar with each rule declared as a public static field .You can then use the InitGrammar ( ) function in the static initializer to assign names automatically to each rule associated with a field .", "label": "", "metadata": {}, "score": "63.998337"}
{"text": "Needing to explicitly set the names of node rules .You can work around these issues by defining all rules in a class derived from Grammar with each rule declared as a public static field .You can then use the InitGrammar ( ) function in the static initializer to assign names automatically to each rule associated with a field .", "label": "", "metadata": {}, "score": "63.998337"}
{"text": "Since these annotations are new with respect to the WSJ guidelines , it is impossi- ble to parse these without injecting knowledge of the annotation guidelines.3 common , comprising 33 % of BIO and 30 % of WSJ tokens , the most popular POS tag by far .", "label": "", "metadata": {}, "score": "64.01304"}
{"text": "The Evaluation Function .The JavaScript evaluation function is similar in structure to the JsonObject .Eval ( ) function with the following differences : .The node tree is transformed into a form that is a bit easier to evaluate .", "label": "", "metadata": {}, "score": "64.05124"}
{"text": "The Evaluation Function .The JavaScript evaluation function is similar in structure to the JsonObject .Eval ( ) function with the following differences : .The node tree is transformed into a form that is a bit easier to evaluate .", "label": "", "metadata": {}, "score": "64.05124"}
{"text": "If we consider only the syntactic chains that contain only one verb , the size of the interaction verbs becomes very small .Since the LLL05 training dataset is small , we collect all the verbs in the syntactic chains from an agent to its target .", "label": "", "metadata": {}, "score": "64.07112"}
{"text": "Do you mean faster performance of the compiled code or of the parser ?I do n't know , but either way the Jigsaw implementation is probably slower .I have n't spent any time trying to produce a high - quality JavaScript implementation , I wanted to create the simplest thing that could possibly work .", "label": "", "metadata": {}, "score": "64.08475"}
{"text": "Because of this efficiency , the algorithm applies to multiple grammar levels of a spoken language system .In accordance with the invention , a method is disclosed for combining unification grammars with rule and observation probabilities to enable a processor to recognize a speech signal input for several levels of a language model .", "label": "", "metadata": {}, "score": "64.09225"}
{"text": "Print(n [ 0 ] ) .Writing a Tree Transformer .The JavaScript parser works well , although certain parts of the parse tree will be hard to work with during evaluation : .Chained binary expressions are not separated .Chained postfix operators are not separated .", "label": "", "metadata": {}, "score": "64.13382"}
{"text": "Print(n [ 0 ] ) .Writing a Tree Transformer .The JavaScript parser works well , although certain parts of the parse tree will be hard to work with during evaluation : .Chained binary expressions are not separated .Chained postfix operators are not separated .", "label": "", "metadata": {}, "score": "64.13382"}
{"text": "During this phase , a string of characters is converted into a string of tokens ( also called lexemes ) .This phase is necessary for certain kinds of parsers ( e.g. , LALR ) but not others ( e.g. , PEG ) .", "label": "", "metadata": {}, "score": "64.18104"}
{"text": "During this phase , a string of characters is converted into a string of tokens ( also called lexemes ) .This phase is necessary for certain kinds of parsers ( e.g. , LALR ) but not others ( e.g. , PEG ) .", "label": "", "metadata": {}, "score": "64.18104"}
{"text": "A system for recognizing a spoken sentence representing a plurality of words , comprising : . a processing means ; . a grammar coupled to said processing means for defining sentences in terms of elements of a language model ; . a lexicon for defining elements of the grammar in terms of symbols ; . a parser coupled to said grammar for combining words into partial sentences , for generating sets of states and for determining completed states ; . a predictor coupled to said grammar and said processing means for predicting the symbols of valid next elements generated by said parser ; . a completer for explaining the results from the parser ; and .", "label": "", "metadata": {}, "score": "64.24722"}
{"text": "Jigsaw comes with an efficient and robust parsing engine as well as a large number of sample grammars and evaluators .The Jigsaw parsing library is an evolution of the parsers used in the Cat language and in the later Heron language .", "label": "", "metadata": {}, "score": "64.26361"}
{"text": "Jigsaw comes with an efficient and robust parsing engine as well as a large number of sample grammars and evaluators .The Jigsaw parsing library is an evolution of the parsers used in the Cat language and in the later Heron language .", "label": "", "metadata": {}, "score": "64.26361"}
{"text": "Applying Our Proposed Method to Test Data .The procedure to detect gene interactions in the test data is as follows .We detect agent candidates from the test set using the gene dictionary provided by LLL05 .Starting from an agent candidate node , we extend all possible syntactic paths .", "label": "", "metadata": {}, "score": "64.45006"}
{"text": "Based on the direction information , we learn direction rules .Let us explain the direction rule - learning algorithm , which is shown in Algorithm 3 .We obtain two types of rule set .One is a positive rule set obtained by learning the direction from an agent to its target .", "label": "", "metadata": {}, "score": "64.492874"}
{"text": "This class defines some additional common rules and rule operations like WS , Integer , Float , and CharToken ( ) .I 'll leave it to you to poke around in the code to see what is available .Evaluating the Arithmetic Grammar Parse Tree .", "label": "", "metadata": {}, "score": "64.49722"}
{"text": "This class defines some additional common rules and rule operations like WS , Integer , Float , and CharToken ( ) .I 'll leave it to you to poke around in the code to see what is available .Evaluating the Arithmetic Grammar Parse Tree .", "label": "", "metadata": {}, "score": "64.49722"}
{"text": "( t ) after step ( k ) , incrementing a frame counter .The method for parsing of claim 25 , wherein said state sets are 1 rows corresponding to the number of grammar levels and N columns corresponding to the number of input frames of speech .", "label": "", "metadata": {}, "score": "64.55527"}
{"text": "This decision effectively removes NNP from the BIO domain and renders all features that depend on the NNP tag ineffective .In our above BIO NP example , all nouns are labeled NN , whereas the WSJ example contains NNP tags .", "label": "", "metadata": {}, "score": "64.621445"}
{"text": "You can see an example of its usage in the Evaluator class .The VarBindings class is a recursively defined associative list class .It contains a name and its associated value , along with a pointer to another VarBindings class .", "label": "", "metadata": {}, "score": "64.74706"}
{"text": "You can see an example of its usage in the Evaluator class .The VarBindings class is a recursively defined associative list class .It contains a name and its associated value , along with a pointer to another VarBindings class .", "label": "", "metadata": {}, "score": "64.74706"}
{"text": "With a few extra primitives you can actually writing node visitors as grammars as well , instead of hand coded .But it seems you and I think a lot alike !Time for some unlearning : The PEG is distinct from a CFG in that each rule describes how to generate strings , not how to recognize them .", "label": "", "metadata": {}, "score": "64.768394"}
{"text": "Assembly - Intel x86 .C / C++ .C # .D .Delphi .Java .Pascal .Python .Visual Basic .NET .wxWidgets .GOLD takes a unique approach of logically separating the development of the LALR and DFA parse tables from the algorithms that use them .", "label": "", "metadata": {}, "score": "64.79935"}
{"text": "The CoNLL In Proc .Lawrence Saul and Fernando Pereira . gate and mixed - order markov models for statistical language modeling .In EMNLP . Aggre-1055 .Data provided are for informational purposes only .Although carefully collected , accuracy can not be guaranteed .", "label": "", "metadata": {}, "score": "64.870056"}
{"text": "They extended the patterns based on eight seed patterns and trained the model using the basic dataset without coreference , as provided by the LLL05 challenge organizers .The F - measure for the test data in LLL05 was 14.8 % .", "label": "", "metadata": {}, "score": "65.05044"}
{"text": "Unfortunately it always takes N 3 time , rather than linear time , even when processing a regular grammar .Additionally , the CYK algorithm is exhaustive ; it systematically expands everything whether it will be needed or not .Such an algorithm uses a great deal of processing time and memory space .", "label": "", "metadata": {}, "score": "65.069374"}
{"text": "Integrated annotation for biomedical information ex- traction .In Proc . of the Human Language Technol- ogy Conference and the Annual Meeting of the North American Chapter of the Association for Computa- tional Linguistics ( HLT / NAACL ) .B. MacWhinney .", "label": "", "metadata": {}, "score": "65.083855"}
{"text": "( q ) parsing said start symbols according to the spoken input and grammars to produce observations of said symbols ; and .( r ) explaining the input based on the results of said step of parsing .The method for parsing of claim 25 , wherein a complete state is a state which fully explains a segment of the spoken input .", "label": "", "metadata": {}, "score": "65.10863"}
{"text": "The system for recognizing a spoken sentence of claim 11 , further comprising a means for generating a chart , wherein the chart is accessed by said parser , said predictor , and said completer for storing intermediate results .The system for recognizing a spoken sentence of claim 12 , wherein the chart comprises states and state sets , said states to be manipulated by said parser and said predictor .", "label": "", "metadata": {}, "score": "65.16812"}
{"text": "In more detail , in a compiler , the lexer performs one of the earliest stages of converting the source code to a program .It scans the text to extract meaningful tokens , such as words , numbers , and strings .", "label": "", "metadata": {}, "score": "65.24176"}
{"text": "The development data was 200 sentences of labeled biomedical oncology text ( BIO , the ONCO portion of the Penn Biomedical Treebank ) , as well as 200 K unlabeled sentences ( Kulick et al ., 2004 ) .The two test domains were a collection of medline chem- istry abstracts ( pchem , the CYP portion of the Penn Biomedical Treebank ) and the Child Language Data Exchange System corpus ( CHILDES ) ( MacWhin- ney , 2000 ; Brown , 1973 ) .", "label": "", "metadata": {}, "score": "65.264984"}
{"text": "Each rule describes a particular syntactic element in the language known as a phrase .In the Jigsaw library , grammars are expressed as a PEG ( Parsing Expression Grammar ) .In a PEG grammar , each rule defines a parser for a particular syntactic element .", "label": "", "metadata": {}, "score": "65.33501"}
{"text": "Each rule describes a particular syntactic element in the language known as a phrase .In the Jigsaw library , grammars are expressed as a PEG ( Parsing Expression Grammar ) .In a PEG grammar , each rule defines a parser for a particular syntactic element .", "label": "", "metadata": {}, "score": "65.33501"}
{"text": "This transformer does a number of tasks : .Converts postfix expressions into one of the following types of expression : . FieldExpr - An expression followed by a \" . \" and an identifier .For example , \" myobject.myfield \" .", "label": "", "metadata": {}, "score": "65.341995"}
{"text": "This transformer does a number of tasks : .Converts postfix expressions into one of the following types of expression : . FieldExpr - An expression followed by a \" . \" and an identifier .For example , \" myobject.myfield \" .", "label": "", "metadata": {}, "score": "65.341995"}
{"text": "The code can be specified in a small simple language ( a subset of C ) , and translated and passed to the container in a common XML - based intermediate language called X#.This approach effectively removes the dependence on any single implementation environment .", "label": "", "metadata": {}, "score": "65.37374"}
{"text": "As mentioned before , the LLL05 training dataset without coreference consists of 55 sentences , including 106 genic interactions , and the test data consist of 144 sentences .Our experiment focused on the following three points .( 1 ) Based on the LLL05 syntactic tags , the performance of our three - phase method versus that of previous methods .", "label": "", "metadata": {}, "score": "65.3874"}
{"text": "A translator consists of a s .. .9-C0038 with the Army High Performance Computing Research Center at the U of MN .In addition , programmers should ... . by Pu Liu , Michael J. Lewis - In Proc . of IEEE International Conference on Web Services ( ICWS'05 , 2005 . \" ...", "label": "", "metadata": {}, "score": "65.39048"}
{"text": "HMM grammars have reference vectors symbols corresponding to reference vectors as their terminal symbols .The processor then scores these reference vectors and gets probabilities for the frame and returns those as observations to the next higher level .Those observations are scanned into that next higher level .", "label": "", "metadata": {}, "score": "65.43174"}
{"text": "Compile ( ) function to create delegates at run - time that can be executed using DynamicInvoke ( ) .Generating expression trees is similar to evaluation , except that instead of returning a dynamic value for each node , we return an instance of the Expression class .", "label": "", "metadata": {}, "score": "65.52414"}
{"text": "Compile ( ) function to create delegates at run - time that can be executed using DynamicInvoke ( ) .Generating expression trees is similar to evaluation , except that instead of returning a dynamic value for each node , we return an instance of the Expression class .", "label": "", "metadata": {}, "score": "65.52414"}
{"text": "Avoiding Left - Recursive Rules .In a PEG grammar , recursive rules are not allowed in the left most position of a sequence .These are called \" left - recursive \" rules and will cause the parser to enter into an infinite loop .", "label": "", "metadata": {}, "score": "65.57623"}
{"text": "Avoiding Left - Recursive Rules .In a PEG grammar , recursive rules are not allowed in the left most position of a sequence .These are called \" left - recursive \" rules and will cause the parser to enter into an infinite loop .", "label": "", "metadata": {}, "score": "65.57623"}
{"text": "Loosely coupled systems , such as bottom - up systems or word lattice parsers , have produced nominal results , primarily due to time alignment problems .Top - down constraints from CFG 's have been integrated with speech using the Cocke - Younger - Kasami ( CYK ) algorithm , but this algorithm has bad average time complexity ( cubic ) .", "label": "", "metadata": {}, "score": "65.60406"}
{"text": "We build on the conclusion of the previous work that linguistic information , especially syntactic information , is an important key for detecting gene interactions .However , we need a more robust method to improve recall without sacrificing precision .Based on syntactic relation information , we propose a three - phase - based method for detecting gene interactions .", "label": "", "metadata": {}, "score": "65.714935"}
{"text": "The dot above that refers to the place in the rule or how far one has progressed through the rule which , at this point , is none .The numbers at the end of the rule represent the logarithmic probabilities of the initial and final probabilities , respectively .", "label": "", "metadata": {}, "score": "65.71619"}
{"text": "The probability of parsing this input is the product of all the rule probabilitiesthat are given in portion C of FIG .4 .The trace seen in Portion D of FIG .4 shows the behaviour of the algorithm with these rule probabilities with respect to the input .", "label": "", "metadata": {}, "score": "65.74086"}
{"text": "Adaptation techniques focus on the former since it is impossible to determine the lat- ter without knowledge of the labeling function .In parsing adaptation , the former corresponds to a dif- ference between the features seen in each domain , such as new words in the target domain .", "label": "", "metadata": {}, "score": "65.7451"}
{"text": "Phase 1 : Constructing Syntactic Encapsulation Categories for Agents and Targets .An agent or target gene is usually encapsulated in another term , and the verb that indicates the interaction between two genes has syntactic relations with two terms that encapsulate the genes .", "label": "", "metadata": {}, "score": "65.745895"}
{"text": "We divided the available WSJ data into a train and test set , trained a parser on the train set and compared errors on the test set and BIO .Accuracy dropped from 90 % on WSJ to 84 % on BIO .", "label": "", "metadata": {}, "score": "65.79712"}
{"text": "Some parser generators , such as the yacc -derived BtYacc ( \" Backtracking Yacc \" ) , give the generated parser the ability to try multiple attempts to parse the tokens .In the problem described here , if an attempt fails because of semantic information about the identifier , it can backtrack and attempt other rules .", "label": "", "metadata": {}, "score": "65.82874"}
{"text": "Finally , we provide our conclusions .Previous Work .The task of relation mining in the biomedical domain has been studied extensively in recent years .Current research includes protein - protein interactions [ 2 , 3 ] , subcellular locations [ 4 ] , and disease - treatment relationships [ 5 ] , and systems based on sequence modeling and pattern- or rule - based extraction best detect protein - protein interactions [ 2 , 6 , 7 ] .", "label": "", "metadata": {}, "score": "65.853"}
{"text": "Now during the secondary expansion the first word is expanded again but since it contains no variable or function references it remains the value onefile , while the second word is now a normal reference to the variable TWOVAR , which is expanded to the value twofile .", "label": "", "metadata": {}, "score": "66.02742"}
{"text": "BACKGROUND OF THE INVENTION .Field of the Invention .This invention relates to spoken language interfaces , and more particularly to a spoken language processor containing a chart parser that incorporates rule and observation 10 probabilities with stochastic unification grammars .", "label": "", "metadata": {}, "score": "66.19867"}
{"text": "Kenji Sagae , Alon Lavie , Combining Rule - based and Data - driven .Techniques for Grammatical Relation Extraction in Spoken Language .Frederik Fouvry , Constraint relaxation with weighted feature .structures .Chad Langley , Alon Lavie , Parsing Domain Actions with Phrase - Level .", "label": "", "metadata": {}, "score": "66.24742"}
{"text": "The method for recognizing spoken sentences of claim 1 , wherein said state sets are 1 rows corresponding to the number of grammar levels and N columns correspondong to the number of input frames of speech .The method for recognizing spoken sentences of claim 1 , wherein said grammar is a stochastic unification grammar .", "label": "", "metadata": {}, "score": "66.25576"}
{"text": "Language translation is a harder and more important problem than language recognition .In particular , programmers implement translators not recognizers .Yet too often , translation is equated with the simpler task of syntactic parsing .This misconception coupled with computing limitations of past ... \" .", "label": "", "metadata": {}, "score": "66.27289"}
{"text": "It takes a snapshot of the environment , executes the function , and then restores the environment .In JavaScript , when a new name is first used , a binding is created automatically .This might not have been a great language design decision , since it increases the chances of programmer error , but we respect it in our implementation .", "label": "", "metadata": {}, "score": "66.37249"}
{"text": "It takes a snapshot of the environment , executes the function , and then restores the environment .In JavaScript , when a new name is first used , a binding is created automatically .This might not have been a great language design decision , since it increases the chances of programmer error , but we respect it in our implementation .", "label": "", "metadata": {}, "score": "66.37249"}
{"text": "A non-Statistical Parsing - based .Approach . using proof - net interfaces .Pierre Boullier , Guided Earley Parsing .Anna Corazza , Parsing Strategies for the Integration of Two Stochastic .Context - Free Grammars .James Henderson , Generative Versus Discriminative Models for .", "label": "", "metadata": {}, "score": "66.42738"}
{"text": "5 is a graph showing the effect of chart parsing by the present invention on pruning .The graph considers time versus logarithmic probability of hypotheses .Each of the dots represent the same hypothesis symbol at times t i and t k .", "label": "", "metadata": {}, "score": "66.56027"}
{"text": "The two noun hypotheses ( \" boys \" from frame 0 to frame 2 and \" boys \" from frame 0 to frame 3 ) are non - intersecting hypotheses since they have different stop times , and therefore remain separate .", "label": "", "metadata": {}, "score": "66.57022"}
{"text": "The body consists of a list of tra ... .Computer - Aided Software Engineering ( CASE ) tools encourage users to codify the specification for the design of a system early in the development process .They often use graphical formalisms , simulation , and prototyping to help express ideas concisely and unambiguously .", "label": "", "metadata": {}, "score": "66.75215"}
{"text": "For each start symbol of grammar , the processor predicts the current frame 's initial and final probability as 0.0 .The processor then parses , given the start frame , the state set , and the level .In the parse algorithm , the processor inputs the matrix of state sets , a level 1 , a frame index i , and outputs an extra state for the next input frame request i+1 .", "label": "", "metadata": {}, "score": "66.96667"}
{"text": "For example , \" myarray[index ] \" .CallExpr - An expression followed by an argument list .For example , \" myfunc(arg0 , arg1 ) \" .MethodCallExpr - A FieldExpr followed by an argument list .For example , \" myobject .", "label": "", "metadata": {}, "score": "66.9805"}
{"text": "For example , \" myarray[index ] \" .CallExpr - An expression followed by an argument list .For example , \" myfunc(arg0 , arg1 ) \" .MethodCallExpr - A FieldExpr followed by an argument list .For example , \" myobject .", "label": "", "metadata": {}, "score": "66.9805"}
{"text": "The system for parsing of claim 20 , wherein the chart comprises states and state sets , said states to be manipulated by said parser and said predictor .The system for parsing of claim 20 , further comprising a knowledge base coupled to said predictor for supplying symbols and appropriate operating data .", "label": "", "metadata": {}, "score": "67.00829"}
{"text": "An ending frame n. .OUTPUT : .A matrix of state sets E , 1 rows and n columns . , the best score for S of G o .METHOD : .Make E l , o empty for all l. .", "label": "", "metadata": {}, "score": "67.089096"}
{"text": "Writing a JavaScript Grammar .It makes sense to derive a JavaScript grammar from the JSON grammar .Some rules will have to be rewritten , such as rules for defining object and array literals so that arbitrary expressions can be placed in objects and arrays , not just literals .", "label": "", "metadata": {}, "score": "67.10196"}
{"text": "Writing a JavaScript Grammar .It makes sense to derive a JavaScript grammar from the JSON grammar .Some rules will have to be rewritten , such as rules for defining object and array literals so that arbitrary expressions can be placed in objects and arrays , not just literals .", "label": "", "metadata": {}, "score": "67.10196"}
{"text": "field will be parsed by the PostfixExpr rule as ( f , ( 1 ) , [ \" hello \" ] , . field ) \" whereas it would be easier if it was ( ( ( f , ( 1 ) ) , [ \" hello \" ] ) , . field ) .", "label": "", "metadata": {}, "score": "67.13185"}
{"text": "field will be parsed by the PostfixExpr rule as ( f , ( 1 ) , [ \" hello \" ] , . field ) \" whereas it would be easier if it was ( ( ( f , ( 1 ) ) , [ \" hello \" ] ) , . field ) .", "label": "", "metadata": {}, "score": "67.13185"}
{"text": "In a syntactic chain from an agent to its target , we call the node preceding an interaction verb a \" metaagent , \" and the node following an interaction verb a \" metatarget . \" In Figure 1 , protein(N ) is a metaagent , and transcription(N ) is a metatarget .", "label": "", "metadata": {}, "score": "67.15173"}
{"text": "These fine grained tags provide more information than coarse tags ; experiments that removed fine grained tags 1052 .Page 3 . hurt WSJ performance but did not affect BIO .Finally , we examined the effect of unknown words .Not surprisingly , the most significant dif- ferences in error rates concerned dependencies be- tween words of which one or both were unknown to the parser .", "label": "", "metadata": {}, "score": "67.28835"}
{"text": "Parsing .Parsing , or syntactic analysis , tells us whether an input string matches a specific syntactic form ( grammar ) and breaks the input up into a parse tree representing the syntactic components ( terms or syntactic phrases ) .", "label": "", "metadata": {}, "score": "67.41063"}
{"text": "Parsing .Parsing , or syntactic analysis , tells us whether an input string matches a specific syntactic form ( grammar ) and breaks the input up into a parse tree representing the syntactic components ( terms or syntactic phrases ) .", "label": "", "metadata": {}, "score": "67.41063"}
{"text": "Because the chart parser parses symbols only once , it can specifically treat left recursive rules .To add the probabilities correctly , it is very important that the predict function add the rule probabilitiy onto the final probability of the state , not to add it onto the initial probability of the state .", "label": "", "metadata": {}, "score": "67.54195"}
{"text": "( p ) scanning observations from said next lower grammar level into waiting states of said current grammar level ; .( q ) repeating steps ( j ) through ( p ) until no new states can be completed ; .", "label": "", "metadata": {}, "score": "67.61421"}
{"text": "Some implications are that PEGs can have zero - width rules and are unambiguous .The difference between a PEG and a CFG is subtle but important .Each rule is an instance of a class derived from Rule .Its role is to recognize a syntactic element in the language ( called a term or phrase ) .", "label": "", "metadata": {}, "score": "67.62197"}
{"text": "Some implications are that PEGs can have zero - width rules and are unambiguous .The difference between a PEG and a CFG is subtle but important .Each rule is an instance of a class derived from Rule .Its role is to recognize a syntactic element in the language ( called a term or phrase ) .", "label": "", "metadata": {}, "score": "67.62197"}
{"text": "Language modeling has become an essential element in high performance , speaker - independent , continuous speech systems .Until recently , speech recognition systems have primarily used Finite State Automatons ( FSAs ) as the language model .These models offer efficient processing , easily accommodate observation probabilities , and permit simple training techniques to produce transition probabilities .", "label": "", "metadata": {}, "score": "67.6967"}
{"text": "CSharp .Microsoft .Jscript .Microsoft .VisualBasic .Each of these assemblies provides a class derived from CodeDomProvider ( e.g. , CSharpCodeProvider ) that you can use to compile an assembly at run - time .The following function shows how to use a CodeDomProvider to generate an assembly dynamically : . public static Assembly CompileWithProvider(CodeDomProvider provider , params string [ ] lines ) .", "label": "", "metadata": {}, "score": "67.81772"}
{"text": "CSharp .Microsoft .Jscript .Microsoft .VisualBasic .Each of these assemblies provides a class derived from CodeDomProvider ( e.g. , CSharpCodeProvider ) that you can use to compile an assembly at run - time .The following function shows how to use a CodeDomProvider to generate an assembly dynamically : . public static Assembly CompileWithProvider(CodeDomProvider provider , params string [ ] lines ) .", "label": "", "metadata": {}, "score": "67.81772"}
{"text": "Simply recognizing whether or not a string belongs to some grammar is not particularly useful when writing a programming language tool .What we really want is a data structure that represents the structure of the input .Jigsaw allows this to be done by embedding Grammar .", "label": "", "metadata": {}, "score": "67.85795"}
{"text": "Simply recognizing whether or not a string belongs to some grammar is not particularly useful when writing a programming language tool .What we really want is a data structure that represents the structure of the input .Jigsaw allows this to be done by embedding Grammar .", "label": "", "metadata": {}, "score": "67.85795"}
{"text": "Conventional procedure and type definition mechanisms are not sufficiently powerful to express many programming abstractions that can be captured by syntactic transformations .Unfortunately , conventional macroprocessing is oblivious to the semantics of the base language , resulting in scoping anom ... \" .", "label": "", "metadata": {}, "score": "67.90455"}
{"text": "Text ; . else . public dynamic Apply(JavaScriptEvaluator e , params dynamic [ ] args ) .e . AddBinding(p .Text , args[i++ ] ) ; .e .Eval(body ) ; . finally .Return Statements .When evaluating a series of statements and a return statement is encountered , you need to store the return value and exit the enclosing function .", "label": "", "metadata": {}, "score": "67.91063"}
{"text": "Text ; . else . public dynamic Apply(JavaScriptEvaluator e , params dynamic [ ] args ) .e . AddBinding(p .Text , args[i++ ] ) ; .e .Eval(body ) ; . finally .Return Statements .When evaluating a series of statements and a return statement is encountered , you need to store the return value and exit the enclosing function .", "label": "", "metadata": {}, "score": "67.91063"}
{"text": "L. Popelinsky and J. Blatak , \" Learning genic interactions without expert domain knowledge : comparison of different ILP algorithms , \" in Proceedings of the ICML05 Workshop on Learning Language in Logic ( LLL ' 05 ) , Bonn , Germany , August 2005 .", "label": "", "metadata": {}, "score": "68.01658"}
{"text": "While we believe this is not enough diversity , it was not feasible to repeat our experiment with a large number of parsers . 3.3Another approach to adaptation is to favor training examples that are similar to the target .We first mod- ified the weight given by the parser to each training sentence based on the similarity of the sentence to target domain sentences .", "label": "", "metadata": {}, "score": "68.173004"}
{"text": "Contents .The problem is that in the following code , the lexical class of A can not be determined without further contextual information : .This code could be multiplication of two variables , in which case A is a variable ; written unambiguously : .", "label": "", "metadata": {}, "score": "68.18921"}
{"text": "The subtleties of using the different automatic variables are described below .Secondary Expansion of Explicit Rules .During the secondary expansion of explicit rules , $ $ @ and $ $ % evaluate , respectively , to the file name of the target and , when the target is an archive member , the target member name .", "label": "", "metadata": {}, "score": "68.194145"}
{"text": "One of the newly created states needs the terminal \" sleep \" and one needs terminal \" leap \" , both of which have the same beginning and end probabilities of -0.03 .There it sees both \" sleep \" and \" leap \" , but \" sleep \" begins at frame 2 and \" leap \" begins at frame 3 .", "label": "", "metadata": {}, "score": "68.24922"}
{"text": "For example , \" Agent1 , Target3 , Pattern2 \" implies that Agent1 interacts with Target3 via Pattern2 .In biomolecular text , the agent or target can be encapsulated in another term based on some conditions , for example , apposition , modifying nouns , and so on .", "label": "", "metadata": {}, "score": "68.38182"}
{"text": "This is what the processor needs to see to indicate it has seen B 3 . \u03b5 is a string of 0 or more terminals and nonterminals In this case the ending frame is also the current frame because the processor has not processed anything .", "label": "", "metadata": {}, "score": "68.40065"}
{"text": "The system for recognizing a spoken sentence of claim 11 , further comprising a knowledge base for supplying symbols , wherein said predictor is coupled to said knowledge base .The system for recognizing a spoken sentence of claim 11 , wherein said language model incorporates stochastic unification grammars .", "label": "", "metadata": {}, "score": "68.502014"}
{"text": "The actual words , also called atoms , are defined elsewhere , such as in a knowledge base .The grammar and lexicon , taken together , can be compiled without reference to a particular domain .The result is to define a spoken language reference which can be a fairly complex subset of a language .", "label": "", "metadata": {}, "score": "68.62605"}
{"text": "Before considering the algorithm of the present invention , two definitions are needed .First , one defines a stochastic unification grammar which is based on the definition of stochastic context - free grammar and is described by the generalization that the symbols are not restricted to atomic symbols but can be feature - value pairs or feature sets .", "label": "", "metadata": {}, "score": "68.71655"}
{"text": "Efficient implementation of the algorithm depends on use of some details set out in Earley 's work .Furthermore , inherent throughout the program is a compute function .When finding probabilities for terminal symbols , it is up to the compute step to note cycles and efficiently find the probability of a given state .", "label": "", "metadata": {}, "score": "68.934875"}
{"text": "For this article , I am using a C # parsing library I wrote called Jigsaw .I chose to use a hand - written parser because it is easier to understand and debug .Jigsaw is a memoizing recursive descent backtracking PEG parser .", "label": "", "metadata": {}, "score": "69.04429"}
{"text": "For this article , I am using a C # parsing library I wrote called Jigsaw .I chose to use a hand - written parser because it is easier to understand and debug .Jigsaw is a memoizing recursive descent backtracking PEG parser .", "label": "", "metadata": {}, "score": "69.04429"}
{"text": "Abstract .Interactions between proteins and genes are considered essential in the description of biomolecular phenomena , and networks of interactions are applied in a system 's biology approach .Recently , many studies have sought to extract information from biomolecular text using natural language processing technology .", "label": "", "metadata": {}, "score": "69.22205"}
{"text": "Builder does a couple unrelated things , such as creating enum lists and allowing you to interactively test a grammar .The Builder could theoretically be ported to other OSes , but is only available for Win32 at this time .The Engine component performs the actual parsing and can be developed in any programming language necessary .", "label": "", "metadata": {}, "score": "69.23142"}
{"text": "Text ) ; case \" Float \" : return Double .ToList ( ) ; case \" Object \" : .Writing a Simple JavaScript Interpreter .The simplest kind of interpreter is little more than a wrapper around an evaluation function .", "label": "", "metadata": {}, "score": "69.234055"}
{"text": "Text ) ; case \" Float \" : return Double .ToList ( ) ; case \" Object \" : .Writing a Simple JavaScript Interpreter .The simplest kind of interpreter is little more than a wrapper around an evaluation function .", "label": "", "metadata": {}, "score": "69.234055"}
{"text": "Type checker - Nodes are transformed into a representation of the type of the expression .This is a form of abstract interpretation .Partial evaluator - An optimization phase where certain nodes in the tree are replaced by their evaluation ( e.g. , compile - time expressions ) .", "label": "", "metadata": {}, "score": "69.259735"}
{"text": "Type checker - Nodes are transformed into a representation of the type of the expression .This is a form of abstract interpretation .Partial evaluator - An optimization phase where certain nodes in the tree are replaced by their evaluation ( e.g. , compile - time expressions ) .", "label": "", "metadata": {}, "score": "69.259735"}
{"text": "They did not use linguistic information provided in the LLL05 data .Error analysis revealed that they wrongly detected an agent and its target in a pair of genes , although they correctly detected two genes that interact with each other .", "label": "", "metadata": {}, "score": "69.27704"}
{"text": "At this point , the processor initializes all of the state sets to empty at all levels of the first frame and sets the initial probability to 0.0 which is a logarithmic probability .The processor sets the level to 0 ( starts at the sentence grammar level ) , and sets the frame to 0 .", "label": "", "metadata": {}, "score": "69.5585"}
{"text": "( n ) scanning observations from said next lower grammar level into waiting states of said current grammar level ; .( i ) repeating steps ( h ) through ( n ) until no new states can be completed ; .", "label": "", "metadata": {}, "score": "69.56142"}
{"text": "Next , to improve precision , we must determine which of the two genes is the agent and which is the target .To determine the agent and target for two genes , we learn direction rules on the relations from agent to target in the third phase .", "label": "", "metadata": {}, "score": "69.618256"}
{"text": "For each syntactic chain , we repeat the following procedure .( 1 ) If a current node is a gene and syntactic chain contains any interaction verb , then we determine that the current node is a target , and stop the extension of the syntactic chain .", "label": "", "metadata": {}, "score": "69.757324"}
{"text": "Nouns are far more The annota- 2We measured these drops on several other dependency parsers and found similar results .ery token is headed by \" Department \" .In contrast , a similar BIO phrase has a very different structure , pursuant to the BIO guidelines .", "label": "", "metadata": {}, "score": "69.781296"}
{"text": "To add , there must be given a state that differs from a current state in the state set .It does not evaluate \u03c1 or \u03c3 , but instead marks the ending in the existing state set , thereby noting it has been added until the processor can later look up the probability and find the maximum .", "label": "", "metadata": {}, "score": "69.80234"}
{"text": "The present invention then enables the chart processor to predict all start symbols and parse for all input frames .The parse function requires that the processor alternately repeat a predict function and a complete function until no new states can be added .", "label": "", "metadata": {}, "score": "69.89798"}
{"text": "SECONDEXPANSION must be defined before the first prerequisite list that makes use of this feature .If that special target is defined then in between the two phases mentioned above , right at the end of the read - in phase , all the prerequisites of the targets defined after the special target are expanded a second time .", "label": "", "metadata": {}, "score": "69.95499"}
{"text": "From these considerations , the following general properties of a mor ... . ... transformation presentation style is expressed by a program called a schema .The prologue begins with a line specifying the medium into which the document is being transformed .", "label": "", "metadata": {}, "score": "70.04843"}
{"text": "Introduction .Determining interactions between proteins and genes are essential in describing biomolecular phenomena [ 1 ] .Thus , many recent studies have sought to extract interaction information from biomolecular text using natural language processing technology .However , we have insufficient biomolecular data annotated with linguistic information .", "label": "", "metadata": {}, "score": "70.05483"}
{"text": "The bottom line represents the best plus some predetermined log probability amount , or threshold .With other algorithms , if the probability of a symbol drops below that threshold at any point , it is discarded .Furthermore , when the best probability symbol completes , the parser will then associate the lower probability symbols with their starting states .", "label": "", "metadata": {}, "score": "70.06432"}
{"text": "Parsing .Tomasz Obrebski , Dependency parsing using dependency graph for storing .alternative structures .Registration : .Early registration is possible until March 28 ; after that date the .registration fee will be higher .At the web site you can also find information about accomodation and .", "label": "", "metadata": {}, "score": "70.17131"}
{"text": "Fine .A JavaScript to Expression Tree Compiler .The Expression class in the System .Linq .Expressions namespace ( also known as an expression tree ) is a convenient way to dynamically create new functions at run - time .", "label": "", "metadata": {}, "score": "70.176155"}
{"text": "Fine .A JavaScript to Expression Tree Compiler .The Expression class in the System .Linq .Expressions namespace ( also known as an expression tree ) is a convenient way to dynamically create new functions at run - time .", "label": "", "metadata": {}, "score": "70.176155"}
{"text": "Unification grammars have allowed the close integration of syntax , semantics , and pragmatics .These grammars are especially significant for spoken language systems because syntactic , semantic , and pragmatic constraints must be applied simultaneously during processing .Discourse and domain contraints can then limit the number of hypotheses to consider at lower levels , thereby greatly improving performance .", "label": "", "metadata": {}, "score": "70.2733"}
{"text": "This flag is checked whenever a compound statement is executed ( e.g. , for loops , while loops , etc . ) , to decide whether the execution of later statements should be skipped .We chose this approach because it is simple to understand and easy to implement .", "label": "", "metadata": {}, "score": "70.28643"}
{"text": "This flag is checked whenever a compound statement is executed ( e.g. , for loops , while loops , etc . ) , to decide whether the execution of later statements should be skipped .We chose this approach because it is simple to understand and easy to implement .", "label": "", "metadata": {}, "score": "70.28643"}
{"text": "In the future , we need to expand the size of the training dataset and experiment with a large dataset .Acknowledgment .This work was supported by the Sungshin Women 's University Research Grant of 2007 .References . D. Otasek , K. Brown , and I. Jurisica , \" Confirming protein - protein interactions by text mining , \" in Proceedings of the 6th SIAM Conference on Text Mining , Bethesda , Md , USA , April 2006 .", "label": "", "metadata": {}, "score": "70.30799"}
{"text": "It is a subset of the JavaScript language that is frequently used as a textual data representation language .It has a similar structure to XML .In the Jigsaw library , there is a class JsonObject derived from DynamicObject that can be created dynamically from a string .", "label": "", "metadata": {}, "score": "70.39364"}
{"text": "It is a subset of the JavaScript language that is frequently used as a textual data representation language .It has a similar structure to XML .In the Jigsaw library , there is a class JsonObject derived from DynamicObject that can be created dynamically from a string .", "label": "", "metadata": {}, "score": "70.39364"}
{"text": "When the first phase was removed , there were no interaction results .It means the first phase is important for the improvement of recall ( see Table 5 ) .As shown in Table 3 , of the systems evaluated , our system performed the best with a precision of 67.9 % , recall of 66.6 % , and an F - measure of 67.2 percent .", "label": "", "metadata": {}, "score": "70.39762"}
{"text": "Next Steps .There are a number of JavaScript features that are not implemented in the JavaScript interpreter and expression compiler .For further study , you can extend the samples provided to implement more features or add programming language features that you may find interesting .", "label": "", "metadata": {}, "score": "70.53415"}
{"text": "Next Steps .There are a number of JavaScript features that are not implemented in the JavaScript interpreter and expression compiler .For further study , you can extend the samples provided to implement more features or add programming language features that you may find interesting .", "label": "", "metadata": {}, "score": "70.53415"}
{"text": "Figure 1 shows an example of a syntactic path .In Figure 1 , Spo0A ( agent ) goes through four terms to reach spoIIG ( target ) .In the chain , node depend(V ) is the verb that indicates the interaction between Spo0A ( agent ) and spoIIG ( target ) .", "label": "", "metadata": {}, "score": "70.63325"}
{"text": "At the bottom of the trace , it is seen that the one - third arises the correct number of times ( 3 ) , the 0.4 arises twice , and the 0.6 arises once , which accurately reflect the number of times the left and nonleft recursive rule were applied .", "label": "", "metadata": {}, "score": "70.75973"}
{"text": "It 's not surprising , then , that GOLD is composed of three pieces : Builder , parser Engine , and an output file that contains table information .In a nutshell , the Builder constructs the parse tables and the Engine executes the tables .", "label": "", "metadata": {}, "score": "70.80321"}
{"text": "Obviously , this is not a very interesting case since the same result could more easily have been achieved simply by having both variables appear , unescaped , in the prerequisites list .One difference becomes apparent if the variables are reset ; consider this example : .", "label": "", "metadata": {}, "score": "70.849045"}
{"text": "The variable may be used elsewhere to denote the occurence of the same feature set .The preferred embodiment of the present invention is as follows : .INPUT : .A vector of grammars , G , G o , . . .", "label": "", "metadata": {}, "score": "70.89119"}
{"text": "B. Rosario and M. Hearst , \" Classifying semantic relations in bioscience texts , \" in Proceedings of the 42nd Annual Meeting of the Association for Computational Linguistics ( ACL ' 04 ) , pp .430 - 437 , Barcelona , Spain , July 2004 .", "label": "", "metadata": {}, "score": "70.927155"}
{"text": "We will follow the same basic form as the ArithmeticEvaluator example .We will write only one Eval ( ) function that can return any valid JSON type ( e.g. , number , string , array , etc . ) depending on the label of the argument . public static dynamic Eval(Node n ) .", "label": "", "metadata": {}, "score": "70.976265"}
{"text": "We will follow the same basic form as the ArithmeticEvaluator example .We will write only one Eval ( ) function that can return any valid JSON type ( e.g. , number , string , array , etc . ) depending on the label of the argument . public static dynamic Eval(Node n ) .", "label": "", "metadata": {}, "score": "70.976265"}
{"text": "The lexicon contains definitions of the terminal symbols of the grammar .These terminal grammar symbols are preferably word classification descriptors , such as verb , noun , and article , with syntactic and semantic information .The terms of the lexicon are assigned features , such as tense , plurality , or definiteness .", "label": "", "metadata": {}, "score": "71.107445"}
{"text": "Building and deploying such services do not benefit from the same advantages , however .Different Web Services containers are implemented in different programming ... \" .A primary benefit of Web Services is that they provide a uniform implementation - independent mechanism for accessing distributed services .", "label": "", "metadata": {}, "score": "71.20882"}
{"text": "Since the direction in the negative rule set is opposite with that in the positive rule set , the direction information in the template is trustworthy .( 3.3 ) case indicates that the negative rule set does not have any rule concerning A and B. The obtained direction rule is same with the original template in the positive rule set .", "label": "", "metadata": {}, "score": "71.308945"}
{"text": "Recursive Rules .Rules defined as variables or fields ca n't refer to themselves or to a rule that has n't been defined yet .This would result in a null reference in the rule definition .For example , the following grammar will generate an error during type initialization : .", "label": "", "metadata": {}, "score": "71.39288"}
{"text": "Recursive Rules .Rules defined as variables or fields ca n't refer to themselves or to a rule that has n't been defined yet .This would result in a null reference in the rule definition .For example , the following grammar will generate an error during type initialization : .", "label": "", "metadata": {}, "score": "71.39288"}
{"text": "SetName ( ) function ( unlike other rules where the name is optional ) .This name is used as the label of the associated node in the node tree .The following code defines a simple grammar for parsing words : .", "label": "", "metadata": {}, "score": "71.59993"}
{"text": "SetName ( ) function ( unlike other rules where the name is optional ) .This name is used as the label of the associated node in the node tree .The following code defines a simple grammar for parsing words : .", "label": "", "metadata": {}, "score": "71.59993"}
{"text": "If you end up using or abusing Jigsaw , I would love to hear about it !Built - in .NET Compilers .Before we start , I should point out that if you are looking for an off the shelf interpreter in C # , you should consider the System .", "label": "", "metadata": {}, "score": "71.64494"}
{"text": "If you end up using or abusing Jigsaw , I would love to hear about it !Built - in .NET Compilers .Before we start , I should point out that if you are looking for an off the shelf interpreter in C # , you should consider the System .", "label": "", "metadata": {}, "score": "71.64494"}
{"text": "c,% . o,$$($$@_SRCS ) ) .This version allows users to specify source files rather than object files , but gives the same resulting prerequisites list as the previous example .Evaluation of automatic variables during the secondary expansion phase , especially of the target name variable $ $ @ , behaves similarly to evaluation within recipes .", "label": "", "metadata": {}, "score": "71.68378"}
{"text": "Both words were unknown only 5 % of the time in BIO , while one of the words being un- known was more common , reflecting 27 % of deci- sions .Upon further investigation , the majority of unknown words were nouns , which indicates that unknown word errors were caused by the problems discussed above .", "label": "", "metadata": {}, "score": "71.7533"}
{"text": "Our er- ror analysis suggests that the primary cause of loss from adaptation is from differences in the annotation guidelines themselves .Therefore , significant im- provements can not be made without specific knowl- edgeofthetargetdomain'sannotationstandards .No amount of source training data can help if no rele- vant structure exists in the data .", "label": "", "metadata": {}, "score": "71.90999"}
{"text": "NET Framework has no tools out of the box for doing parsing but there are a large number of third - party parsing tools to choose from .Some of the more popular tools are ANTLR , YACC , and BISON .", "label": "", "metadata": {}, "score": "71.916565"}
{"text": "NET Framework has no tools out of the box for doing parsing but there are a large number of third - party parsing tools to choose from .Some of the more popular tools are ANTLR , YACC , and BISON .", "label": "", "metadata": {}, "score": "71.916565"}
{"text": "These parameters correspond to local cases where no linguistic consensus exists as to the proper gold annotation .Therefore , the standard evaluation does not provide a true indication of algorithm quality .We present a new measure , Neutral Edge Direction ( NED ) , and show that it greatly reduces this undesired phenomenon . \" ... this paper , we introduce the ANTLR ( ANother Tool for Language Recognition ) parser generator , which addresses all these issues .", "label": "", "metadata": {}, "score": "71.973694"}
{"text": "5 Acknowledgments We thank Joel Wallenberg and Nikhil Dinesh for their informative and helpful linguistic expertise , Kevin Lerman for his edge labeler code , and Koby Crammer for helpful conversations .Dredze is sup- ported by a NDSEG fellowship ; Ganchev and Taluk- dar by NSF ITR EIA-0205448 ; and Blitzer by DARPA under Contract No . NBCHD03001 .", "label": "", "metadata": {}, "score": "72.16121"}
{"text": "Then the processor predicts and completes grammar rules for the words which are composed of phonemes and when it finds a set of phonemes which are terminal symbols , it then calls itself at grammar level 2 which has phoneme symbols as start symbols .", "label": "", "metadata": {}, "score": "72.25818"}
{"text": "The only difference is that \" complete \" deals with nonterminal symbols and \" scan \" deals with terminal symbols .First the processor makes the state set at level 1 , frame i+1 , empty .Its probability is \u03c1 , that is the ending probability of that state plus the ending probability of the completed state minus the initial probability of the completed state .", "label": "", "metadata": {}, "score": "72.26926"}
{"text": "( c ) inputting a lexicon having entries for defining terminal symbols of said at least one grammar in terms of linguistic , syntactic or semantic features ; .( d ) generating a matrix of state sets ; .( e ) initializing said state sets ; .", "label": "", "metadata": {}, "score": "72.292496"}
{"text": "CatEvaluator.cs - Contains an evaluator for the Cat language , a simple functional stack - based language .Final Words .This article only scratches the surface of implementing programming languages .If you liked this article and want to learn more about programming language implementation , you may be interested to know that I am working on a book with the working title \" Implementing Programming Languages in C # \" .", "label": "", "metadata": {}, "score": "72.37346"}
{"text": "CatEvaluator.cs - Contains an evaluator for the Cat language , a simple functional stack - based language .Final Words .This article only scratches the surface of implementing programming languages .If you liked this article and want to learn more about programming language implementation , you may be interested to know that I am working on a book with the working title \" Implementing Programming Languages in C # \" .", "label": "", "metadata": {}, "score": "72.37346"}
{"text": "As an example : .Note that the directory prefix ( D ) , as described in Implicit Rule Search Algorithm , is appended ( after expansion ) to all the patterns in the prerequisites list .As an example : .", "label": "", "metadata": {}, "score": "72.4499"}
{"text": "When it has done all the predicting and completing it can do , it sees that it needs a verb indicated by v. There are two verb rules , so it predicts them .One is \" sleep \" and the other is \" leap \" , both beginning at frame 2 and having initial and final probabilities of -0.04 .", "label": "", "metadata": {}, "score": "72.49825"}
{"text": "A new data type ( JSFunction ) is introduced .The evaluation function is too long to list here , but here is a representative snippet : .Eval(n [ 1 ] ) : null ) ; case \" Empty \" : // An empty statement means we do nothing return null ; case \" ExprStatement \" : return Eval(n [ 0 ] ) ; .", "label": "", "metadata": {}, "score": "72.554016"}
{"text": "A new data type ( JSFunction ) is introduced .The evaluation function is too long to list here , but here is a representative snippet : .Eval(n [ 1 ] ) : null ) ; case \" Empty \" : // An empty statement means we do nothing return null ; case \" ExprStatement \" : return Eval(n [ 0 ] ) ; .", "label": "", "metadata": {}, "score": "72.554016"}
{"text": "One of the simplest methods to implement a closure is to use a copy of the environment from the moment the function value is declared .When the function is applied to its arguments ( i.e. , called ) , the current evaluator 's environment is temporarily replaced with the version stored with the function .", "label": "", "metadata": {}, "score": "72.59017"}
{"text": "One of the simplest methods to implement a closure is to use a copy of the environment from the moment the function value is declared .When the function is applied to its arguments ( i.e. , called ) , the current evaluator 's environment is temporarily replaced with the version stored with the function .", "label": "", "metadata": {}, "score": "72.59017"}
{"text": "right parenthesis . identifier ' B ' .The problem is precisely that the lexical class of A can not be determined without further context : the parser can interpret this as variable A multiplied by B or as type A casting the dereferenced value of B .", "label": "", "metadata": {}, "score": "72.81328"}
{"text": "The following example will help illustrate these behaviors : .In the second , they will have values foo.1 , foo.1 bar.1 , and foo.1 bar.1 respectively .In the third they will have values foo.1 , foo.1 bar.1 foo.2 bar.2 , and foo.1 bar.1 foo.2 bar.2 foo.1 foo.1 bar.1 foo.1 bar.1 respectively .", "label": "", "metadata": {}, "score": "72.93248"}
{"text": "information is available about previous IWPTs , proceedings , books . based on IWPTs , and SIGPARSE related activities .Introduction .This article introduces the basic concepts of programming language implementation for C # programmers .It is meant to provide a quick overview of the concepts of implementing programming languages using a number of examples including an arithmetic evaluator and a simple JavaScript interpreter .", "label": "", "metadata": {}, "score": "73.05172"}
{"text": "Lawrence Erlbaum .M. Marcus , B. Santorini , and M. Marcinkiewicz .Building a large annotated corpus of English : the Penn Treebank .Computational Linguistics , 19(2):313 - 330 .Ryan McDonald , Kevin Lerman , and Fernando Pereira .", "label": "", "metadata": {}, "score": "73.107445"}
{"text": "We give several examples justifying our arguments .1 Introduction Language translation is a harder and more important problem than language recognition .In particular , programmers implement translators not recognizers .Yet too often , translation is equated with the simpler task of syntactic parsing .", "label": "", "metadata": {}, "score": "73.25873"}
{"text": "( j ) generating a probability score for each said completed state ; .( k ) repeating steps ( h ) to ( j ) until no new states can be created ; .( l ) parsing terminal symbols from the current grammar level as start symbols for the next lower grammar level unless at the lowest grammar level ; .", "label": "", "metadata": {}, "score": "73.33757"}
{"text": "Figure 1 : Calc.grm ( grammar file ) .Schooling Your Grammar .Now , it 's time to test the grammar !The results are shown in Figure 2 : LINGUIST List 14.887 .Thu Mar 27 2003 .Confs : Parsing Technologies , France .", "label": "", "metadata": {}, "score": "73.45123"}
{"text": "The present invention assigns probabilities to the hypotheses that it next wants to explore .It also employs a beam pruning technique , well - known in the art , and a delayed commitment in the score caluclation to determine the most probable correct response ( speech recognition ) .", "label": "", "metadata": {}, "score": "73.7806"}
{"text": "According to the first and second phases , we can detect two genes that interact with each other .Previous studies made many errors in attempts to recognize which of two genes was the agent or target .The incorrect detection of an agent and a target results in low precision .", "label": "", "metadata": {}, "score": "73.8185"}
{"text": "Parser - Transforms a linear sequence of tokens or characters into a tree structure called a parse tree .Tree transformer ( optional ) - Modifies the parse tree simplifying later steps .Tree visitor - Visits each node in the tree and performs some action or creates a new data structure .", "label": "", "metadata": {}, "score": "73.85674"}
{"text": "Parser - Transforms a linear sequence of tokens or characters into a tree structure called a parse tree .Tree transformer ( optional ) - Modifies the parse tree simplifying later steps .Tree visitor - Visits each node in the tree and performs some action or creates a new data structure .", "label": "", "metadata": {}, "score": "73.85674"}
{"text": "NN , NNP - NNP - NNP , NN - IN - NN , and IN - NN - NN .However , when we examine the coarse POS tags , which do not distinguish between nouns , these dif- ferences disappear .", "label": "", "metadata": {}, "score": "73.98619"}
{"text": "To improve recall , in the first phase , we construct syntactic encapsulation categories of agent and target .In the second phase , we construct interaction verbs that connect pairs of genes that interact with each other .To improve precision , in the third phase , we learn direction information to detect which of the two genes is the agent or target .", "label": "", "metadata": {}, "score": "74.13834"}
{"text": "One such defect involves the calculation of probabilities .For context - free grammars , a nonterminal symbol may rewrite to another nonterminal symbol without having to go through a terminal symbol .Probabilities can therefore occur from many directions in the grammar .", "label": "", "metadata": {}, "score": "74.16206"}
{"text": "With a few extra primitives you can actually writing node visitors as grammars as well , instead of hand coded .But it seems you and I think a lot alike !General News Suggestion Question Bug Answer Joke Praise Rant Admin .", "label": "", "metadata": {}, "score": "74.20627"}
{"text": "Through experimentation , we show that our proposed method significantly outperforms existing methods , and describe the contribution of each phase to its performance .This paper is organized as follows .Section 2 presents previous work on gene interactions .Section 3 explains our three - phase method in detail .", "label": "", "metadata": {}, "score": "74.29582"}
{"text": "The system for recognizing a spoken sentence of claim 11 , wherein said processing means includes an input means for recording spoken words and an acoustic device for tranforming spoken words into a medium readable by said processing means .The system for recognizing a spoken sentence of claim 11 , wherein said processing means is coupled to a translating means adapted to receive spoken input and transform said input into a medium readable by said processing means .", "label": "", "metadata": {}, "score": "74.33864"}
{"text": "We selected with replacement 2000 training examples from the training data and trained three parsers .Each parser then tagged the remain- ing 13 K sentences , yielding 39 K parsed sentences .We then shuffled these sentences and trained a final parser .", "label": "", "metadata": {}, "score": "74.34522"}
{"text": "A problem occurs here if a single sequence of tokens can ambiguously match more than one syntax rule .This ambiguity can happen in C if the lexer does not distinguish between variable and typedef identifiers .[ 1 ] For example , in the C expression : .", "label": "", "metadata": {}, "score": "74.36011"}
{"text": "First , we align the positive and negative rule sets .Here , \" align \" means the modification of any conflict in a rule set .Because the direction information is not trustworthy , we set direction \" ANY . \" \" ANY \" means any direction is okay .", "label": "", "metadata": {}, "score": "74.39924"}
{"text": "Yong - Jae Kwak So - Young Park Hoojung - Chung Young-Sook Hwang Hae - Chang .Rim , GLR Parser with Conditional Action Model using Surface Phrasal .Types For Korean .Souha Hammami Mezghani , Chafik Aloulou , Lamia Hadrich Belguith , Ahmed .", "label": "", "metadata": {}, "score": "74.50095"}
{"text": "The method for parsing of claim 25 , wherein said grammar incorporates stochastic unification grammars .The method of parsing of claim 25 , wherein said probability score for said completed state is the probability for completing states in the state set using already complete states in the state sets .", "label": "", "metadata": {}, "score": "74.62321"}
{"text": "The evaluator included implements only basic operators , and has a single built - in function \" alert \" .Built - in functions are implemented using the JSPrimitive class and are added to the global environment when an evaluator is initialized . public JavaScriptEvaluator ( ) .", "label": "", "metadata": {}, "score": "74.77757"}
{"text": "The evaluator included implements only basic operators , and has a single built - in function \" alert \" .Built - in functions are implemented using the JSPrimitive class and are added to the global environment when an evaluator is initialized . public JavaScriptEvaluator ( ) .", "label": "", "metadata": {}, "score": "74.77757"}
{"text": "For an interaction verb A , the relations not learned in the training data can appear in the test data .The default rule permits any direction is okay for other relations not appearing in the training data .Because the training data is so small , the default rule can resolve data sparseness problem .", "label": "", "metadata": {}, "score": "74.889694"}
{"text": "For ex- ample , trained on in - domain data , nouns that occur more often tend to be heads .However , none of these features transfered between domains .A final type of feature we added was based on the behavior of nouns , adjectives and verbs in each domain .", "label": "", "metadata": {}, "score": "75.012405"}
{"text": "Separates long binary expressions according to precedence rules .Converts while loops into for loops .Rewrites special assignment operators , so that the evaluator only has to consider the basic assignment operator .Replaces nodes which only ever have one child by the child node .", "label": "", "metadata": {}, "score": "75.09537"}
{"text": "Separates long binary expressions according to precedence rules .Converts while loops into for loops .Rewrites special assignment operators , so that the evaluator only has to consider the basic assignment operator .Replaces nodes which only ever have one child by the child node .", "label": "", "metadata": {}, "score": "75.09537"}
{"text": "This process is called evaluation .To do this , we create a new class called ArithmeticEvaluator that has two functions : Eval(string s ) and Eval(node n ) .For the sake of convenience , both functions return a dynamic value .", "label": "", "metadata": {}, "score": "75.14724"}
{"text": "This process is called evaluation .To do this , we create a new class called ArithmeticEvaluator that has two functions : Eval(string s ) and Eval(node n ) .For the sake of convenience , both functions return a dynamic value .", "label": "", "metadata": {}, "score": "75.14724"}
{"text": "JavaScript Functions .Unlike JSON , when implementing a JavaScript interpreter , we have to consider what data structure to use to represent functions .In JavaScript , functions are closures .This means the function can refer to variables declared outside of the function .", "label": "", "metadata": {}, "score": "75.25537"}
{"text": "JavaScript Functions .Unlike JSON , when implementing a JavaScript interpreter , we have to consider what data structure to use to represent functions .In JavaScript , functions are closures .This means the function can refer to variables declared outside of the function .", "label": "", "metadata": {}, "score": "75.25537"}
{"text": "Instead all operations are resolved at run - time . class ArithmeticEvaluator .public static dynamic Eval(Node n ) .Parse(n .Text ) ; case \" Float \" : return Double .Parse(n .Text ) ; case \" PrefixExpr \" : switch ( n [ 0 ] .", "label": "", "metadata": {}, "score": "75.32817"}
{"text": "Instead all operations are resolved at run - time . class ArithmeticEvaluator .public static dynamic Eval(Node n ) .Parse(n .Text ) ; case \" Float \" : return Double .Parse(n .Text ) ; case \" PrefixExpr \" : switch ( n [ 0 ] .", "label": "", "metadata": {}, "score": "75.32817"}
{"text": "Further experiments showed that any decrease in training data hurt parser perfor- mance .It would seem that the parser has no dif- ficulty learning important training sentences in the presence of unimportant training examples .A related idea focused on words , weighing highly tokens that appeared frequently in the target domain .", "label": "", "metadata": {}, "score": "75.32893"}
{"text": "The Match function accepts an instance of a ParserState class which holds the input string , a position in the input string , and the parse tree .You can create instances of rules from static member functions of the Grammar class .", "label": "", "metadata": {}, "score": "75.33472"}
{"text": "The Match function accepts an instance of a ParserState class which holds the input string , a position in the input string , and the parse tree .You can create instances of rules from static member functions of the Grammar class .", "label": "", "metadata": {}, "score": "75.33472"}
{"text": "The Clang parser handles the situation a completely different way , namely by using a non - reference lexical grammar .Clang 's lexer does not attempt to differentiate between type names and variable names : it simply reports the current token as an identifier .", "label": "", "metadata": {}, "score": "75.40721"}
{"text": "( g ) predicting initial and final probabilities for a current frame for each start symbol of grammar ; .( h ) predicting a valid next nonterminal symbol to thereby create at least one state from its corresponding at least one rule according to said at least one grammar ; .", "label": "", "metadata": {}, "score": "75.51076"}
{"text": "WS + CharToken ( ' ? ' )Writing a Source Code Printer .Given a parse tree generated from a JavaScript parser , one of the simplest tools we can build is a source code printer .This is a useful intermediate step when you are developing a language for validating that the parser is working as expected .", "label": "", "metadata": {}, "score": "75.5186"}
{"text": "WS + CharToken ( ' ? ' )Writing a Source Code Printer .Given a parse tree generated from a JavaScript parser , one of the simplest tools we can build is a source code printer .This is a useful intermediate step when you are developing a language for validating that the parser is working as expected .", "label": "", "metadata": {}, "score": "75.5186"}
{"text": "The cycle produces some terminal symbols that are hypothesized at the next lower grammar level .The processor hypothesizes the terminal symbols from this level as start symbols at the next lower grammar level .It returns a set of observations which are scanned into the waiting states .", "label": "", "metadata": {}, "score": "75.7029"}
{"text": "The \" output device \" may be a screen , another processor , an audio speaker , a robotic arm , etc .In the implementation of the preferred emmbodiment of the present invention , the input is spoken , the input device is a microphone , the output and output device involve a processor response written to a screen .", "label": "", "metadata": {}, "score": "75.93745"}
{"text": "Does it contain string constants ?And so on .Although you literally could write in ' + ' for the plus operator , I feel that spelling out the terminals ( \" PLUS \" ) both provides abstraction while supporting maintenance and readability .", "label": "", "metadata": {}, "score": "76.29994"}
{"text": "Generic language technology and compiler construction techniques are a prerequisite to build analysis and conversion tools that are needed for the re - engineering of large software systems .We argue that generic language technology is a crucial means to do fundamental re - engineering .", "label": "", "metadata": {}, "score": "76.486374"}
{"text": "Generic language technology and compiler construction techniques are a prerequisite to build analysis and conversion tools that are needed for the re - engineering of large software systems .We argue that generic language technology is a crucial means to do fundamental re - engineering .", "label": "", "metadata": {}, "score": "76.486374"}
{"text": "Harvard University Press .Koby Crammer , Ofer Dekel , Joseph Keshet , Shai Shalev-Shwartz , and Yoram Singer .Online passive- aggressive algorithms .Journal of Machine Learning Research , 7:551 - 585 , Mar. R. Johansson and P. Nugues .", "label": "", "metadata": {}, "score": "76.66319"}
{"text": "The CASE tool STATEMATE makes use of an ... . ... ons to access the STATEMATE database , replaces symbols with words ( like PLUS for ' + ' ) , and organizes the information in the above format .The event counters are generated by concatenating the name of the event ( EN , EV , etc ) with the state name or variable for the event .", "label": "", "metadata": {}, "score": "76.68723"}
{"text": ": return ! case \" ParanExpr \" : return Eval(n [ 0 ] ) ; case \" Expression \" : switch ( n .Count ) .Text ) .default : throw new Exception ( String .Writing a JSON Parser .", "label": "", "metadata": {}, "score": "76.699455"}
{"text": ": return ! case \" ParanExpr \" : return Eval(n [ 0 ] ) ; case \" Expression \" : switch ( n .Count ) .Text ) .default : throw new Exception ( String .Writing a JSON Parser .", "label": "", "metadata": {}, "score": "76.699455"}
{"text": "With natural language systems , N is traditionally words ; however with speech systems , N is equal to frames , which are the fundamental time units used in speech recognition .The algorithm was significant in that it provided a time synchronous algorithm for speech recognition which improved accuracy because the processor did not have to be concerned about how the words fit together .", "label": "", "metadata": {}, "score": "76.71399"}
{"text": "In the previous section we learned that GNU make works in two distinct phases : a read - in phase and a target - update phase ( see How make Reads a Makefile ) .GNU make also has the ability to enable a second expansion of the prerequisites ( only ) for some or all targets defined in the makefile .", "label": "", "metadata": {}, "score": "76.720795"}
{"text": "Formal methods include powerful tools like automatic model checking to exhaustively check a model against certain requirements .Integrating formal techniques into the system development process is an effective method of providing more thorough analysis of specifications than conventional approaches employed by Computer - Aided Software Engineering ( CASE ) tools .", "label": "", "metadata": {}, "score": "76.79596"}
{"text": "For comparison 's sake , you will now reverse - engineer the simple calculator you developed in GNU Bison .Fortunately , the GOLD Builder includes an import tool for legacy YACC / Bison grammars to get you started .For those of you starting from scratch , the New Grammar Wizard will give you a leg up on some standard types of grammars by quizzing you on some basic language characteristics : Do newlines terminate statements or not ?", "label": "", "metadata": {}, "score": "76.83521"}
{"text": "For example , a person 's average speech input is 4 - 5 seconds long , which corresponds to 400 - 500 frames .When cubed , those 400 - 500 frames yield 64,000,000 - 125,000,000 processing steps to recognize an input .", "label": "", "metadata": {}, "score": "77.07233"}
{"text": "Different Web Services containers are implemented in different programming languages , with different constraints and requirements placed on the programmer .Moreover , client side programmers must use the Web Service interface specified by the service developer .Therefore , the kinds of applications and uses for a Web Service are unnecessarily restrictive , constrained by the granularity of access defined by the interface and by the characteristics of the service functions .", "label": "", "metadata": {}, "score": "77.65885"}
{"text": "Label ) .Print ( \" return \" ) .Print(n [ 0 ] ) .Print ( \" ; \" ) .:Print ( \" return ; \" ) ; case \" ExprStatement \" : return Print(n [ 0 ] ) .", "label": "", "metadata": {}, "score": "77.73046"}
{"text": "Label ) .Print ( \" return \" ) .Print(n [ 0 ] ) .Print ( \" ; \" ) .:Print ( \" return ; \" ) ; case \" ExprStatement \" : return Print(n [ 0 ] ) .", "label": "", "metadata": {}, "score": "77.73046"}
{"text": "In Proc . of the 16th Nordic Conference on Computational Linguistics ( NODALIDA ) .Extended Sandra K\u00a8 ubler . schemes influence parsing results ? or how not to com- pare apples and oranges .In RANLP .How do treebank annotation 1054 .", "label": "", "metadata": {}, "score": "77.81172"}
{"text": "So , they do not consider the case that agent or target is encapsulated in another term , and indirectly connected with interaction verbs .In addition , there is a limit that they find agents and targets only from the subject and object relations .", "label": "", "metadata": {}, "score": "77.82828"}
{"text": "The sample JavaScript to expression compiler in the Jigsaw library , JavaScriptExpressionCompiler , provides two compilation functions , one that takes a string , and the other that takes a Node . public static Delegate CompileLambda ( string s ) .public static Delegate CompileLambda(Node n ) .", "label": "", "metadata": {}, "score": "77.887474"}
{"text": "The sample JavaScript to expression compiler in the Jigsaw library , JavaScriptExpressionCompiler , provides two compilation functions , one that takes a string , and the other that takes a Node . public static Delegate CompileLambda ( string s ) .public static Delegate CompileLambda(Node n ) .", "label": "", "metadata": {}, "score": "77.887474"}
{"text": "Computer - Aided Software Engineering ( CASE ) tools encourage users to codify the specification for the design of a system early in the development process .They often use graphical formalisms , simulation , and prototyping to help express ideas concisely and unambiguously .", "label": "", "metadata": {}, "score": "77.94092"}
{"text": "Introduction .This article introduces the basic concepts of programming language implementation for C # programmers .It is meant to provide a quick overview of the concepts of implementing programming languages using a number of examples including an arithmetic evaluator and a simple JavaScript interpreter .", "label": "", "metadata": {}, "score": "77.96443"}
{"text": "workshop series was initiated by Masaru Tomita in 1989 .The first .workshop , in Pittsburgh and Hidden Valley , was followed by workshops . in Cancun ( Mexico ) in 1991 ; Tilburg ( Netherlands ) and Durbuy ( Belgium ) .", "label": "", "metadata": {}, "score": "78.34665"}
{"text": "First , we find the syntactic chain from an agent to its target .In Figure 1 , depend(V ) is the verb that indicates an interaction between Spo0A ( agent ) and spoIIG ( target ) .In this paper , we call the verb that indicates the interaction between an agent and its target an \" interaction verb . \"", "label": "", "metadata": {}, "score": "78.38078"}
{"text": "It has been the goal of recent research to make machine understanding of spoken language possible through a tight coupling between speech and natural language systems .The difficulty posed by this coupling lies in trying to integrate statistical speech information with natural language grammars .", "label": "", "metadata": {}, "score": "78.479706"}
{"text": "This is especially important for left recursive rules .Subtracting the beginning probability from the ending probability , yields \u03b7 . sigma .-\u03c3.sub.\u03bf ) ] _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ .", "label": "", "metadata": {}, "score": "78.495316"}
{"text": "For a syntactic relation , direction is defined as follows .If a syntactic relation is relation(syntactic category , current node , next node ) , the direction is \" RIGHT , \" since the next node is written to the right of the current node .", "label": "", "metadata": {}, "score": "78.75689"}
{"text": "In ( 3.2 ) case , the direction information C in the positive rule is still used in the obtained direction rule .The case indicates that the negative rule set has \" OPPOSITE C \" direction .If C is \" RIGHT , \" then \" OPPOSITE C \" means \" LEFT .", "label": "", "metadata": {}, "score": "78.913605"}
{"text": "To hypothesize , the processor takes a terminal symbol b from a state needed to advance a given state or a set of states .For all terminals \" b \" at a given level 1 , the processor computes a new probability based on the ending probability \u03c1 of the state , \u03c1 ' .", "label": "", "metadata": {}, "score": "79.07854"}
{"text": "My experience has been that these kinds of parsers most closely correspond to my intuition of how a parser should work .Grammars .A grammar is a formal definition of the syntax of a language .Writing a grammar is a bit like writing a Regular Expression .", "label": "", "metadata": {}, "score": "79.2672"}
{"text": "My experience has been that these kinds of parsers most closely correspond to my intuition of how a parser should work .Grammars .A grammar is a formal definition of the syntax of a language .Writing a grammar is a bit like writing a Regular Expression .", "label": "", "metadata": {}, "score": "79.2672"}
{"text": "I will be updating this article in the near future ( for example adding a \" related work section \" ) , and tidying up the source files ( e.g. more comments and more tests ) .So please bookmark it and leave your suggestions .", "label": "", "metadata": {}, "score": "79.28146"}
{"text": "WriteLine(d.answer ) ; .For this article , the most interesting part of the implementation of JsonObject is the Parse ( ) function .public static JsonObject Parse ( string s ) .Object .To implement the parse function , we first need to define a JSON grammar . public class JsonGrammar : SharedGrammar .", "label": "", "metadata": {}, "score": "79.28807"}
{"text": "WriteLine(d.answer ) ; .For this article , the most interesting part of the implementation of JsonObject is the Parse ( ) function .public static JsonObject Parse ( string s ) .Object .To implement the parse function , we first need to define a JSON grammar . public class JsonGrammar : SharedGrammar .", "label": "", "metadata": {}, "score": "79.28807"}
{"text": "Experiments deduced 182 relations out of 492 sentences showing 48 % recall and 80 % precision .Many linguistic processes have been used to deduce gene interactions , including bidirectional incremental parsing , combinatory categorical grammar ( CCG ) , coordination , apposition , compound noun processing , and positive / negative predicate learning .", "label": "", "metadata": {}, "score": "79.757645"}
{"text": "UseCache constant to false , you can see how long it takes to parse certain grammars by running the tests in the JavaScriptTests class .Simplifying Grammars : Deriving from the Grammar Class .When defining a grammar , the following points are particularly annoying : .", "label": "", "metadata": {}, "score": "79.75852"}
{"text": "UseCache constant to false , you can see how long it takes to parse certain grammars by running the tests in the JavaScriptTests class .Simplifying Grammars : Deriving from the Grammar Class .When defining a grammar , the following points are particularly annoying : .", "label": "", "metadata": {}, "score": "79.75852"}
{"text": "The variables $ $ ?Secondary Expansion of Static Pattern Rules .As with explicit rules , $ $ ? is not available and expands to the empty string .Secondary Expansion of Implicit Rules .As make searches for an implicit rule , it substitutes the stem and then performs secondary expansion for every rule with a matching target pattern .", "label": "", "metadata": {}, "score": "80.013405"}
{"text": "The thesis describes novel techniques and algorithms for the practical parsing of realistic Natural Language ( NL ) texts with a wide - coverage unification - based grammar of English .The thesis tackles two of the major problems in this area : firstly , the fact that parsing realistic inputs with such gr ... \" .", "label": "", "metadata": {}, "score": "80.184265"}
{"text": "This indicates that most of the loss comes from missing these edges .The primary problem for nouns is the difference between structures in each domain . tion guidelines for the Penn Treebank flattened noun phrases to simplify annotation ( Marcus et al . , 1993 ) , so there is no complex structure to NPs . K\u00a8 ubler ( 2006 ) showed that it is difficult to compare the Penn Treebank to other treebanks with more com- plexnounstructures , suchasBIO.ConsidertheWSJ phrase \" the New York State Insurance Department \" .", "label": "", "metadata": {}, "score": "80.863266"}
{"text": "For example : .Interpreter - Transforms nodes into run - time values or executes a primitive action .Compiler - Transforms nodes into a machine - executable representation .Pretty printer - Transforms nodes into a human - readable form such as ASCII or HTML .", "label": "", "metadata": {}, "score": "81.54001"}
{"text": "For example : .Interpreter - Transforms nodes into run - time values or executes a primitive action .Compiler - Transforms nodes into a machine - executable representation .Pretty printer - Transforms nodes into a human - readable form such as ASCII or HTML .", "label": "", "metadata": {}, "score": "81.54001"}
{"text": "When the parser has predicted and completed as much as it can , it has a set of terminal symbols that it needs to see before it can go on and the set consists of one element which is \" boys \" .", "label": "", "metadata": {}, "score": "81.66697"}
{"text": "Publisher conditions are provided by RoMEO .Differing provisions from the publisher 's actual policy or licence agreement may be applicable .\" One of the main challenges in natural language processing ( NLP ) is to correct for biases in the manually annotated data available to system engineers .", "label": "", "metadata": {}, "score": "82.04765"}
{"text": "General News Suggestion Question Bug Answer Joke Praise Rant Admin .Use Ctrl+Left / Right to switch messages , Ctrl+Up / Down to switch threads , Ctrl+Shift+Left / Right to switch pages .", "label": "", "metadata": {}, "score": "82.24945"}
{"text": "History .Oct. 22 , 2011 - First submission .Oct. 23 , 2011 - Removed superfluous files from download package , and added missing link to download .Oct. 28 , 2011 - Made a large number of edits thanks to a wonderfully detailed review by Tracey Houston .", "label": "", "metadata": {}, "score": "82.32909"}
{"text": "History .Oct. 22 , 2011 - First submission .Oct. 23 , 2011 - Removed superfluous files from download package , and added missing link to download .Oct. 28 , 2011 - Made a large number of edits thanks to a wonderfully detailed review by Tracey Houston .", "label": "", "metadata": {}, "score": "82.32909"}
{"text": "The cause for this is clear when the annotation guide- lines are considered .The proper nouns in WSJ are names of companies , people and places , while in BIO they are names of genes , proteins and chemi- cals .", "label": "", "metadata": {}, "score": "82.61334"}
{"text": "Processor 14 communicates with processor memory 16 via connecting element 18 .After processor 14 has completed the algorithm and has identified the input from input device 10 , processor 14 transmits an output to output device 22 via connecting element 20 .", "label": "", "metadata": {}, "score": "82.96596"}
{"text": "One problem with using code generators is that the learning curve is quite steep .They each have their own syntax and rules .I had to implement my own hand - written parser before I could understand how to use these tools .", "label": "", "metadata": {}, "score": "83.03265"}
{"text": "One problem with using code generators is that the learning curve is quite steep .They each have their own syntax and rules .I had to implement my own hand - written parser before I could understand how to use these tools .", "label": "", "metadata": {}, "score": "83.03265"}
{"text": "When you write an evaluator for a programming language , you have to track values associated with names ( e.g. , function names , variable names , argument names ) .The binding of values to names is collectively called the environment .", "label": "", "metadata": {}, "score": "83.16545"}
{"text": "When you write an evaluator for a programming language , you have to track values associated with names ( e.g. , function names , variable names , argument names ) .The binding of values to names is collectively called the environment .", "label": "", "metadata": {}, "score": "83.16545"}
{"text": "multi - agent .Sanghamitra Mohanty , Rakesh Chandra Balabantaray , Intelligent Parsing . in Natural Language Processing .[ canceled ] .So - Young Park Yong - Jae Kwak Hoo - Jung Chung Young - Sook Hwang Hae - Chang .", "label": "", "metadata": {}, "score": "83.215775"}
{"text": "A proof - of - concept language , XL , is described which embodies this mechanism .Sponsored by the Defense Advanced Research Projects Agency ( DoD ) , monitored by Spac ... . ... tractions are conveniently packaged in \" little languages , \" implemented conventionally with preprocessors at the expense of smooth integration and security .", "label": "", "metadata": {}, "score": "83.49488"}
{"text": "The method of claim 3 , wherein said probability score for said completed state is the probability for completing states in the state set using already complete states in the state sets .The method of claim 3 , wherein said score is calculated by summing the ending probability of the active state with the difference between the ending and initial probabilities of the complete state , wherein the active state is the state requiring the symbol which the complete state defines .", "label": "", "metadata": {}, "score": "83.911804"}
{"text": "Technologies ( IWPT'03 ) from 23 to 25 April , 2003 .IWPT'03 continues the tradition of biennial workshops on parsing . technology organised by SIGPARSE , the Special Interest Group on .Parsing of the Association for Computational Linguistics ( ACL ) .", "label": "", "metadata": {}, "score": "84.172104"}
{"text": "This is discussed in the \" Writing a Tree Transformer \" section .A Simple Arithmetic Grammar .Putting together everything we have learned so far , here is a simple grammar for parsing arithmetic expressions : . class ArithmeticGrammar : SharedGrammar .", "label": "", "metadata": {}, "score": "84.90015"}
{"text": "This is discussed in the \" Writing a Tree Transformer \" section .A Simple Arithmetic Grammar .Putting together everything we have learned so far , here is a simple grammar for parsing arithmetic expressions : . class ArithmeticGrammar : SharedGrammar .", "label": "", "metadata": {}, "score": "84.90015"}
{"text": "This is marginally more exciting , but the true power of this feature only becomes apparent when you discover that secondary expansions always take place within the scope of the automatic variables for that target .All you have to do is defer the expansion by escaping the $ .", "label": "", "metadata": {}, "score": "85.08867"}
{"text": "As a donor you are automatically entered into this prize draw .The moderators , staff , and student editors at LINGUIST would like to take this opportunity to thank you for your continuous support .Please keep conferences announcement as short as you can ; LINGUIST will not post conference announcements which in our opinion are excessively long .", "label": "", "metadata": {}, "score": "85.67713"}
{"text": "Another problem concerns appositives .For ex- ample , the phrase \" Howard Mosher , president and chief executive officer , \" has \" Mosher \" as the head of \" Howard \" and of the appositive NP delimited by commas .", "label": "", "metadata": {}, "score": "85.906044"}
{"text": "For example , the fundamental time unit may be 20 milliseconds .This means that every 20 milliseconds the processor will characterize speech data with a vector of length 18 or so , floating point features of various characteristics of the speech signal and will match those characteristics to the expected data or symbols which correspond to words .", "label": "", "metadata": {}, "score": "87.09384"}
{"text": "Thanks David , sorry it took so long for me to add them !There are a few differences , including the fact that I have used my grammar to make a grammar grammar !But a lot of the primitives you have created actually have the same names even Another idea you might find interesting is the idea of parsing objects and not just strings .", "label": "", "metadata": {}, "score": "87.21273"}
{"text": "Thanks David , sorry it took so long for me to add them !There are a few differences , including the fact that I have used my grammar to make a grammar grammar !But a lot of the primitives you have created actually have the same names even Another idea you might find interesting is the idea of parsing objects and not just strings .", "label": "", "metadata": {}, "score": "87.21273"}
{"text": "There are several other samples included with the Jigsaw library that you may find interesting : .ILCompiler.cs - An implementation of an IL assembly code .SchemeExpressionCompiler.cs - A simple expression compiler that works for a small subset of the Scheme language .", "label": "", "metadata": {}, "score": "87.37069"}
{"text": "There are several other samples included with the Jigsaw library that you may find interesting : .ILCompiler.cs - An implementation of an IL assembly code .SchemeExpressionCompiler.cs - A simple expression compiler that works for a small subset of the Scheme language .", "label": "", "metadata": {}, "score": "87.37069"}
{"text": "The lexer hack .In computer programming , the lexer hack ( as opposed to \" a lexer hack \" ) describes a common solution to the problems in parsing ANSI C , due to the reference grammar being context - sensitive .", "label": "", "metadata": {}, "score": "87.6214"}
{"text": "Pattern ( @ \" \\s+ \" ) ; . eos ) .SetName ( \" sentence \" ) ; .You stole my pen .Hey you stole my pen ! \" ) Console .WriteLine(n ) ; foreach ( var n2 in n .", "label": "", "metadata": {}, "score": "88.053955"}
{"text": "Pattern ( @ \" \\s+ \" ) ; . eos ) .SetName ( \" sentence \" ) ; .You stole my pen .Hey you stole my pen ! \" ) Console .WriteLine(n ) ; foreach ( var n2 in n .", "label": "", "metadata": {}, "score": "88.053955"}
{"text": "Without added context , the lexer can not distinguish type identifiers from other identifiers because all identifiers have the same format .With the hack in the above example , when the lexer finds the identifier A it should be able to classify the token as a type identifier .", "label": "", "metadata": {}, "score": "88.50655"}
{"text": "o : % .o : $ $ ( addsuffix /% .c , foo bar ) foo.h @echo $ ^ .The prerequisite list printed , after the secondary expansion and directory prefix reconstruction , will be /tmp / foo / foo .", "label": "", "metadata": {}, "score": "89.15546"}
{"text": "You can build compound rules that succeed only if a sequence of child rules match successfully using the plus ( \" + \" ) operator .rule .Match ( \" catnip \" ) ; // false rule .Match ( \" dogfish \" ) ; // false rule .", "label": "", "metadata": {}, "score": "89.16871"}
{"text": "You can build compound rules that succeed only if a sequence of child rules match successfully using the plus ( \" + \" ) operator .rule .Match ( \" catnip \" ) ; // false rule .Match ( \" dogfish \" ) ; // false rule .", "label": "", "metadata": {}, "score": "89.16871"}
{"text": "Throughout , we discuss the implementation of predicates in ANTLR --- the parser generator of The Purdue Compiler - Con ... . ...@acm .org 2 Purdue University School of Electrical Engineering quong@ecn.purdue.edu Abstract .However , there are language constructs that defy almost all parsing strategy commonly in use .", "label": "", "metadata": {}, "score": "89.251564"}
{"text": "Good to hear from you my man !You made an excellent point .That whole paragraph could be removed without hurting the article .We share the same passion , Christopher : design and implementation of programming languages .Unlike you , however , I 'm far from being done with my own project ( IronLua , over at codeplex - no external libs for the moment ) .", "label": "", "metadata": {}, "score": "89.32968"}
{"text": "Print ( \" if ( \" ) .Print(n [ 0 ] ) .Print ( \" ) \" ) .Indent ( ) .Print(n [ 1 ] ) .Print(n [ 2 ] ) .: this ; case \" Else \" : return Print ( \" else \" ) .", "label": "", "metadata": {}, "score": "89.43271"}
{"text": "Print ( \" if ( \" ) .Print(n [ 0 ] ) .Print ( \" ) \" ) .Indent ( ) .Print(n [ 1 ] ) .Print(n [ 2 ] ) .: this ; case \" Else \" : return Print ( \" else \" ) .", "label": "", "metadata": {}, "score": "89.43271"}
{"text": "Proceedings of the CoNLL Shared Task Session of EMNLP - CoNLL 2007 , pp .1051 - 1055 , Prague , June 2007 .c ?upenn.edu 2L2F - INESC - ID Lisboa / IST , Rua Alves Redol 9 , 1000 - 029 , Lisboa , Portugal javg@l2f.inesc-id.pt Abstract We describe some challenges of adaptation in the 2007 CoNLL Shared Task on Domain Adaptation .", "label": "", "metadata": {}, "score": "90.00653"}
{"text": "Since the parser has probabilites of -0.09 on state 13 and 0.06 on state 14 , it chooses the best one , which is -0.06 , and traces back through the parse state to find \" boys leap \" .This phrase will then be outputted as the speech recognition processor 's best explanation for the spoken input given .", "label": "", "metadata": {}, "score": "90.38516"}
{"text": "NET compilers .That said , I 'm confident you are here because you want to learn the black arts of implementing programming languages , so continue on brave reader !Anatomy of a Language Tool .Most language tools follow the same basic architecture : .", "label": "", "metadata": {}, "score": "90.45333"}
{"text": "NET compilers .That said , I 'm confident you are here because you want to learn the black arts of implementing programming languages , so continue on brave reader !Anatomy of a Language Tool .Most language tools follow the same basic architecture : .", "label": "", "metadata": {}, "score": "90.45333"}
{"text": "Match ( \" swordfish \" ) ; // false rule .Match ( \" cat \" ) ; // false .Rules can be defined as optional using the Grammar .Opt ( ) function : .Grammar .MatchString ( \" nap \" ) ) ; . rule .", "label": "", "metadata": {}, "score": "91.62038"}
{"text": "Match ( \" swordfish \" ) ; // false rule .Match ( \" cat \" ) ; // false .Rules can be defined as optional using the Grammar .Opt ( ) function : .Grammar .MatchString ( \" nap \" ) ) ; . rule .", "label": "", "metadata": {}, "score": "91.62038"}
{"text": "Boston / Cambridge ( Massachusetts ) in 1997 ; Trento ( Italy ) in 2000 , and .Beijing ( China ) in 2001 .Program : .Three days of invited talks , long papers , short papers and posters and . discussions .", "label": "", "metadata": {}, "score": "92.11159"}
{"text": "c foo.h .Let Your Parser Go for the GOLD .A Parser Generator that Speaks YOUR Language .In a previous installment , you visited the inner workings of the Yet Another Compiler - Compiler ( YACC ) parsing system .", "label": "", "metadata": {}, "score": "94.50722"}
{"text": "The difference between a PEG and a CFG is subtle but important .Frank !The man who made me want to learn C # properly !Remembers that IL to JavaScript compiler you wrote ?I never told you how inspiring that project was to me .", "label": "", "metadata": {}, "score": "96.32625"}
{"text": "MatchString ( \" fox \" ) .Match ( \" fox \" ) ) ; // true Grammar .MatchString ( \" fox \" ) .Match ( \" foxy \" ) ) ; // true Grammar .MatchString ( \" fox \" ) .", "label": "", "metadata": {}, "score": "97.84906"}
{"text": "MatchString ( \" fox \" ) .Match ( \" fox \" ) ) ; // true Grammar .MatchString ( \" fox \" ) .Match ( \" foxy \" ) ) ; // true Grammar .MatchString ( \" fox \" ) .", "label": "", "metadata": {}, "score": "97.84906"}
{"text": "Match ( \" catfish \" ) ; // true .Repeated rules can also be created using Grammar .ZeroOrMore ( ) and Grammar .OneOrMore ( ) .For example : . rule .Match ( \" badger badger badger badger snake ! \" ) ; // true .", "label": "", "metadata": {}, "score": "100.37767"}
{"text": "Match ( \" catfish \" ) ; // true .Repeated rules can also be created using Grammar .ZeroOrMore ( ) and Grammar .OneOrMore ( ) .For example : . rule .Match ( \" badger badger badger badger snake ! \" ) ; // true .", "label": "", "metadata": {}, "score": "100.37767"}
{"text": "IWPT'03 Organization : .General Chair : Harry Bunt ( Tilburg University , Netherlands ) .Programme Chair : Gertjan van Noord ( University of Groningen , .Netherlands ) .Local Organization Chair : Guy Perrier ( LORIA , Nancy , France ) .", "label": "", "metadata": {}, "score": "101.59061"}
{"text": "Detection of Gene Interactions Based on Syntactic Relations .School of Computer Science and Engineering , Sungshin Women 's University , Seoul 136 - 742 , Korea .Received 29 August 2007 ; Accepted 19 December 2007 .Copyright \u00a9 2008 Mi - Young Kim .", "label": "", "metadata": {}, "score": "101.709564"}
{"text": "Nancy , \" City of Art and History \" , the historical capital of Lorraine .( the north - eastern part of France ) welcomes you to the 8th .International Workshop on Parsing Technologies .The Laboratoire .Lorrain de Recherche en Informatique et ses Applications ( LORIA ) in .", "label": "", "metadata": {}, "score": "110.99403"}
{"text": "rule .Match ( \" catfish \" ) ; // true rule .Match ( \" doggedly \" ) ; // true .Rules operators can be combined to create even more sophisticated rules .rule .Match ( \" dogfish \" ) ; // true rule .", "label": "", "metadata": {}, "score": "112.73163"}
{"text": "rule .Match ( \" catfish \" ) ; // true rule .Match ( \" doggedly \" ) ; // true .Rules operators can be combined to create even more sophisticated rules .rule .Match ( \" dogfish \" ) ; // true rule .", "label": "", "metadata": {}, "score": "112.73163"}
{"text": "The output of the above program is : . sentence : Hey ! word : Hey sentence : You stole my pen .word : You word : stole word : my word : pen sentence : Hey you stole my pen ! word : Hey word : you word : stole word : my word : pen .", "label": "", "metadata": {}, "score": "140.81883"}
{"text": "The output of the above program is : . sentence : Hey ! word : Hey sentence : You stole my pen .word : You word : stole word : my word : pen sentence : Hey you stole my pen ! word : Hey word : you word : stole word : my word : pen .", "label": "", "metadata": {}, "score": "140.81883"}
