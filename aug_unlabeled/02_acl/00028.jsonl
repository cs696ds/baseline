{"text": "CL - RDFXML - An RDF / XML Parser for Common Lisp .Abstract .There are now a number of libraries for processing some of the technologies upon which RDF / XML is built .Particularly , Closure XML is a robust , mature XML parser , and manipulation of URIs is easy using Puri .This RDF / XML parser builds upon these libraries so as to minimize the amount of code that is not directly related to parsing RDF / XML , and provides a simple interface for extracting triples from RDF / XML documents .GitHub : CL - RDFXML source is hosted on GitHub .", "label": "", "metadata": {}}
{"text": "A boolean ( whose default value is true ) that controls whether a warning is signalled when a permitted non - namespaced attribute is encountered .The only attributes which may appear without namespaces are ID , about , resource , parseType , and type .New documents should not use unqualified forms , though they may appear in legacy documents .See Section 6.1.4 of the RDF / XML Syntax Specification .A boolean ( whose default value is false ) that controls whether a warning is signalled when an element is encountered that specifies the rdf : parseType attribute with a value other than \" Literal \" , \" Resource \" , or \" Collection \" .", "label": "", "metadata": {}}
{"text": "Nonetheless , it seems likely that one might be interested in knowing when it occurs .According to to Section 5.1 , The RDF Namespace and Vocabulary of the RDF / XML Syntax Specification , warnings SHOULD be generated when a name is encountered that begins with the RDF namespace name , but is not an RDF name .RDF Concepts .Literals .The literal class is the superclass of both the plain - literal and the typed literal .Every literal has some lexical form , and the slot storing this form is defined in the literal class , and may be read with literal - string .", "label": "", "metadata": {}}
{"text": "The plain - literal class is the class comprising all plain - literals .These literals have a lexical form , inherited from the superclass literal , and an optional language tag .The language tag , when provided , should be of the form specified by RFC 3066 , and is normalized to lowercase .Calls to intern - plain - literal with strings that are equal and languages that are equal return the same literal object .Calls to intern - plain - literal with strings that are equal and designators for the same URI return the same literal object .", "label": "", "metadata": {}}
{"text": "Blank Nodes .The blank - node class represents blank nodes in a graph .Blanks nodes are local to a graph , and can be identified within a graph by their ID .The blank - node i d is used for refering to the same blank node in an RDF / XML document , and so in general , blank - nodes ought to compared using object equality , i.e. , eq .If i d is specified , then if there is already a blank node in namespace whose i d is equal to i d , then that blank node is returned .", "label": "", "metadata": {}}
{"text": "If i d is not specified , then a new blank node is returned , and namespace is not modified .Blank - node - ids are intended to be used for readability purposes .Blank - nodes should be compared directly using object equality .Conditions . rdf - prefixed - non - rdf - name is the class of warnings that are signalled in such situations .According to 6.1.4 of the RDF / XML Syntax Specification , the attributes ID , about , resource , parseType , and type may appear without a namespace prefix , and are interpreted as the corresponding RDF names .", "label": "", "metadata": {}}
{"text": "\" non - namespaced - name is the class of warnings that are signalled in such situations .The rdf : parseType attribute has three explicitly meaning values , \" Resource \" , \" Literal \" , and \" Collection \" .If rdf : parseType is encountered with a different value , the element is processed as though the value had been \" Literal \" .The specification does not indicate that a warning should be signalled , and so such warnings are not generated in the default case , but if the user requests warnings on such attribute values , a warning of type other - parse - type is signalled .", "label": "", "metadata": {}}
{"text": "This kind of situation may happen , for instance , if a xml : lang value is not RFC 3066 compliant , or if an rdf : ID or rdf : nodeID value is not an XML NCName .Note that these situations are distinct from those in which an attribute appears where it should not .Language tags in RDF / XML ( and more generally , XML ) must be in accordance with RFC 3066 .When a language tag is specified that is not of the proper form , an error of type invalid - language - tag is signalled .", "label": "", "metadata": {}}
{"text": "When non - whitespace character data is encountered where whitespace is expected , an error of type unexpected characters is signalled .Errors of type duplicate - attribute are signalled when attributes are specified more than once and the XML parser did not flag the error .This happens when , according to the RDF / XML specification , certain non - namespaced attributes are interpreted as being in the RDF namespace .A duplicate attribute can appear , for instance , when rdf : ID is specified in conjunction with ID , which is interpreted as rdf : ID .", "label": "", "metadata": {}}
{"text": "When an attribute appears on an element but is not allowed there , an prohibited - attribute error is signalled .Errors of type datatyped - empty - property are signaled when the parser is attempting to parser an empty property , but an rdf : datatype attribute is specified .rdf : datatype is not a permissible attribute on on empty properties , but it is expected that this case will most likely arise when the intent was to generate a literal element with an empty string .When this type of error is signalled , it is expected that one of the available restarts will make an attempt to parse the element as a literal with a null string .", "label": "", "metadata": {}}
{"text": "Certain attribute , namely rdf : ID , rdf : about , rdf : resource , rdf : parseType , and rdf : type are permitted to appear without a namespace specified .These attributes are automatically treated as though they had appeared with the RDF namespace prefix .Any other attributes without namespaces , however , must not appear .Some elements are permitted to contain one of a set of attributes , but no more than one of the set .That is , there are attributes that are permitted on an element , but are mutually exclusive .", "label": "", "metadata": {}}
{"text": "Restart Functions .This is intended for use when an attribute appears in a place where it is prohibited , but parsing would continue successfully if the attribute had not been specified .This is intended for use when duplicate attributes are provided and all can be ignored , or when mutually exclusive attributes appear , and all can be ignored .This is intended for use when character data appears in a place that should have been whitespace .This occurs by invoking the restart ignore - language .This is intended to be used when an rdf : datatype attribute is present on an empty property element .", "label": "", "metadata": {}}
{"text": "Vocabulary .Each of the following so - called constants is actually a variable defined with defvar , so there will be no error from the Lisp implementation if you try to rebind it .However , these should not be modified ( as their surrounding + 's indicate ) .They are defvar s rather than defconstant s only because of limitations in the serialization of interned URIs and the desire for fast URI comparison .Modifying these values will break CL - RDFXML .( So do n't modify them . )Syntactic parsing is a fundamental problem in computational linguistics and natural language processing .", "label": "", "metadata": {}}
{"text": "Recently , Sutskever et al .( 2014 ) presented a task - agnostic method for learning to map input sequences to output sequences that achieved strong results on a large scale machine translation problem .In this work , we show that precisely the same sequence - to - sequence method achieves results that are close to state - of - the - art on syntactic constituency parsing , whilst making almost no assumptions about the structure of the problem .To achieve these results we need to mitigate the lack of domain knowledge in the model by providing it with a large amount of automatically parsed data .", "label": "", "metadata": {}}
{"text": "We do this by experimenting with novel features , additional transition systems and by testing on a wider array of languages .In particular , we introduce set - valued features to encode the predicted morphological properties and part - of - speech confusion sets of the words being parsed .We also investigate the use of joint parsing and part - of - speech tagging in the neural paradigm .Finally , we conduct a multi - lingual evaluation that demonstrates the robustness of the overall structured neural approach , as well as the benefits of the extensions proposed in this work .", "label": "", "metadata": {}}
{"text": "We present structured perceptron training for neural network transition - based dependency parsing .We learn the neural network representation using a gold corpus augmented by a large number of automatically parsed sentences .Given this fixed network representation , we learn a final layer using the structured perceptron with beam - search decoding .On the Penn Treebank , our parser reaches 94.26 % unlabeled and 92.41 % labeled attachment accuracy , which to our knowledge is the best accuracy on Stanford Dependencies to date .We also provide in - depth ablative analysis to determine which aspects of our model provide the largest gains in accuracy .", "label": "", "metadata": {}}
{"text": "Existing methods incrementally expand the lexicon by greedily adding entries , considering a single training datapoint at a time .We propose using corpus - level statistics for lexicon learning decisions .We introduce voting to globally consider adding entries to the lexicon , and pruning to remove entries no longer required to explain the training data .Our methods result in state - of - the - art performance on the task of executing sequences of natural language instructions , achieving up to 25 % error reduction , with lexicons that are up to 70 % smaller and are qualitatively less noisy .", "label": "", "metadata": {}}
{"text": "The new Viewer adds three features for more powerful search : wildcards , morphological inflections , and capitalization .These additions allow the discovery of patterns that were previously difficult to find and further facilitate the study of linguistic trends in printed text .We present a simple and novel classifier - based preordering approach .Unlike existing preordering models , we train feature - rich discriminative classifiers that directly predict the target - side word order .Our approach combines the strengths of lexical reordering and syntactic preordering models by performing long - distance reorderings using the structure of the parse tree , while utilizing a discriminative model with a rich set of features , including lexical features .", "label": "", "metadata": {}}
{"text": "We obtain improvements of up to 1.4 BLEU on language pairs in the WMT 2010 shared task .For languages from different families the improvements often exceed 2 BLEU .Many of these gains are also significant in human evaluations .We present a new collection of treebanks with homogeneous syntactic dependency annotation for six languages : German , English , Swedish , Spanish , French and Korean .To show the usefulness of such a resource , we present a case study of cross - lingual transfer parsing with more reliable evaluation than has been possible before .This ' universal ' treebank is made freely available in order to facilitate research on multilingual dependency parsing .", "label": "", "metadata": {}}
{"text": "Recently , manually constructed tag dictionaries from Wiktionary and dictionaries projected via bitext have been used as type constraints to overcome the scarcity of annotated data in this setting .In this paper , we show that additional token constraints can be projected from a resource- rich source language to a resource - poor target language via word - aligned bitext .We present several models to this end ; in particular a partially observed conditional random field model , where coupled token and type constraints provide a partial signal for training .Averaged across eight previously studied Indo - European languages , our model achieves a 25 % relative error reduction over the prior state of the art .", "label": "", "metadata": {}}
{"text": "We present a new edition of the Google Books Ngram Corpus , which describes how often words and phrases were used over a period of five centuries , in eight languages ; it reflects 6 % of all books ever published .This new edition introduces syntactic annotations : words are tagged with their part - of - speech , and head - modifier relationships are recorded .The annotations are produced automatically with statistical models that are specifically adapted to historical text .The corpus will facilitate the study of linguistic trends , especially those related to the evolution of syntax .", "label": "", "metadata": {}}
{"text": "We propose a simple , efficient procedure in which part - of - speech tags are transferred from retrieval - result snippets to queries at training time .Unlike previous work , our final model does not require any additional resources at run - time .Compared to a state - of - the - art approach , we achieve more than 20 % relative error reduction .Additionally , we annotate a corpus of search queries with part - of - speech tags , providing a resource for future work on syntactic query analysis .We describe a shared task on parsing web text from the Google Web Treebank .", "label": "", "metadata": {}}
{"text": "There was a constituency and a dependency parsing track and 11 sites submitted a total of 20 systems .System combination approaches achieved the best results , however , falling short of newswire accuracies by a large margin .The best accuracies were in the 80 - 84\\% range for F1 and LAS ; even part - of - speech accuracies were just above 90\\% .Coarse - to - fine inference has been shown to be a robust approximate method for improving the efficiency of structured prediction models while preserving their accuracy .We propose a multi - pass coarse - to - fine architecture for dependency parsing using linear - time vine pruning and structured prediction cascades .", "label": "", "metadata": {}}
{"text": "We observe speed - ups of up to two orders of magnitude compared to exhaustive search .Our pruned third - order model is twice as fast as an unpruned first - order model and also compares favorably to a state - of - the - art transition - based parser for multiple languages .To facilitate future research in unsupervised induction of syntactic structure and to standardize best - practices , we propose a tagset that consists of twelve universal part - of - speech categories .In addition to the tagset , we develop a mapping from 25 different treebank tagsets to this universal set .", "label": "", "metadata": {}}
{"text": "We highlight the use of this resource via two experiments , including one that reports competitive accuracies for unsupervised grammar induction without gold standard part - of - speech tags .We present an online learning algorithm for training structured prediction models with extrinsic loss functions .This allows us to extend a standard supervised learning objective with additional loss - functions , either based on intrinsic or task - specific extrinsic measures of quality .We present experiments with sequence models on part - of - speech tagging and named entity recognition tasks , and with syntactic parsers on dependency parsing and machine translation reordering tasks .", "label": "", "metadata": {}}
{"text": "Unfortunately , most state - of - the - art constituency parsers employ large probabilistic context - free grammars for disambiguation , which renders them impractical for real - time use .Meanwhile , Graphics Processor Units ( GPUs ) have become widely available , offering the opportunity to alleviate this bottleneck by exploiting the fine - grained data parallelism found in the CKY algorithm .In this paper , we explore the design space of parallelizing the dynamic programming computations carried out by the CKY algorithm .We use the Compute Unified Device Architecture ( CUDA ) programming model to reimplement a state - of - the - art parser , and compare its performance on two recent GPUs with different architectural features .", "label": "", "metadata": {}}
{"text": "We present a simple method for transferring dependency parsers from source languages with labeled training data to target languages without labeled training data .We first demonstrate that delexicalized parsers can be directly transferred between languages , producing significantly higher accuracies than unsupervised parsers .We then use a constraint driven learning algorithm where constraints are drawn from parallel corpora to project the final parser .Unlike previous work on projecting syntactic resources , we show that simple methods for introducing multiple source languages can significantly improve the overall quality of the resulting parsers .The projected parsers from our system result in state - of - the - art performance when compared to previously studied unsupervised and projected parsing systems across eight different languages .", "label": "", "metadata": {}}
{"text": "We apply our method to train parsers that excel when used as part of a reordering component in a statistical machine translation system .We use a corpus of weakly - labeled reference reorderings to guide parser training .Our best parsers contribute significant improvements in subjective translation quality while their intrinsic attachment scores typically regress .We describe a novel approach for inducing unsupervised part - of - speech taggers for languages that have no labeled training data , but have translated text in a resource - rich language .Our method does not assume any knowledge about the target language ( in particular no tagging dictionary is assumed ) , making it applicable to a wide array of resource - poor languages .", "label": "", "metadata": {}}
{"text": "2010 ) .Across eight European languages , our approach results in an average absolute improvement of 10.4 % over a state - of - the - art baseline , and 16.7 % over vanilla hidden Markov models induced with the Expectation Maximization algorithm .We describe a new scalable algorithm for semi - supervised training of conditional random fields ( CRF ) and its application to part - of - speech ( POS ) tagging .The algorithm uses a similarity graph to encourage similar n - grams to have similar POS tags .We demonstrate the efficacy of our approach on a domain adaptation task , where we assume that we have access to large amounts of unlabeled data from the target domain , but no additional labeled data .", "label": "", "metadata": {}}
{"text": "Standard inference can be used at test time .Our approach is able to scale to very large problems and yields significantly improved target domain accuracy .It is well known that parsing accuracies drop significantly on out - of - domain data .What is less known is that some parsers suffer more from domain shifts than others .We show that dependency parsers have more difficulty parsing questions than constituency parsers .In particular , deterministic shift - reduce dependency parsers , which are of highest interest for practical applications because of their linear running time , drop to 60 % labeled accuracy on a question test set .", "label": "", "metadata": {}}
{"text": "With 100 K unlabeled and 2 K labeled questions , uptraining is able to improve parsing accuracy to 84 % , closing the gap between in - domain and out - of - domain performance .We study self - training with products of latent variable grammars in this paper .We show that increasing the quality of the automatically parsed data used for self - training gives higher accuracy self - trained grammars .Our generative self - trained grammars reach F scores of 91.6 on the WSJ test set and surpass even discriminative reranking systems without self - training .", "label": "", "metadata": {}}
{"text": "The product model is most effective when the individual underlying grammars are most diverse .Combining multiple grammars that were self - trained on disjoint sets of unlabeled data results in a final test accuracy of 92.5\\% on the WSJ test set and 89.6\\% on our Broadcast News test set .This work shows how to improve state - of - the - art monolingual natural language processing models using unannotated bilingual text .We build a multiview learning objective that enforces agreement between monolingual and bilingual models .In our method the first , monolingual view consists of supervised predictors learned separately for each language .", "label": "", "metadata": {}}
{"text": "Our training procedure estimates the parameters of the bilingual model using the output of the monolingual model , and we show how to combine the two models to account for dependence between views .For syntactic parsing , our bilingual predictor increases F1 by 2.1 % absolute , and retraining a monolingual model on its output gives an improvement of 2.0 % .We show that the automatically induced latent variable grammars of Petrov et al .2006 vary widely in their underlying representations , depending on their EM initialization point .We use this to our advantage , combining multiple automatically learned grammars into an unweighted product model , which gives significantly improved performance over state - of - the - art individual grammars .", "label": "", "metadata": {}}
{"text": "Despite its simplicity , a product of eight automatically learned grammars improves parsing accuracy from 90.2 % to 91.8 % on English , and from 80.3 % to 84.5 % on German .Pruning can massively accelerate the computation of feature expectations in large models .However , any single pruning mask will introduce bias .We present a novel approach which employs a randomized sequence of pruning masks .Formally , we apply auxiliary variable MCMC sampling to generate this sequence of masks , thereby gaining theoretical guarantees about convergence .Because each mask is generally able to skip large portions of an underlying dynamic program , our approach is particularly compelling for high - degree algorithms .", "label": "", "metadata": {}}
{"text": "Latent variable grammars take an observed ( coarse ) treebank and induce more fine - grained grammar categories , that are better suited for modeling the syntax of natural languages .Estimation can be done in a generative or a discriminative framework , and results in the best published parsing accuracies over a wide range of syntactically divergent languages and domains .In this paper we highlight the commonalities and the differences between the two learning paradigms .State - of - the - art natural language processing models are anything but compact .Syntactic parsers have huge grammars , machine translation systems have huge transfer tables , and so on across a range of tasks .", "label": "", "metadata": {}}
{"text": "First , how can we learn highly complex models ?Second , how can we efficiently infer optimal structures within them ?Hierarchical coarse - to - fine methods address both questions .Coarse - to - fine approaches exploit a sequence of models which introduce complexity gradually .At the top of the sequence is a trivial model in which learning and inference are both cheap .Each subsequent model refines the previous one , until a final , full - complexity model is reached .Because each refinement introduces only limited complexity , both learning and inference can be done in an incremental fashion .", "label": "", "metadata": {}}
{"text": "In the domain of syntactic parsing , complexity is in the grammar .We present a latent variable approach which begins with an X - bar grammar and learns to iteratively refine grammar categories .For example , noun phrases might be split into subcategories for subjects and objects , singular and plural , and so on .This splitting process admits an efficient incremental inference scheme which reduces parsing times by orders of magnitude .Furthermore , it produces the best parsing accuracies across an array of languages , in a fully language - general fashion .In the domain of acoustic modeling for speech recognition , complexity is needed to model the rich phonetic properties of natural languages .", "label": "", "metadata": {}}
{"text": "Our approaches reduces error rates compared to other baseline approaches , while streamlining the learning procedure .In the domain of machine translation , complexity arises because there and too many target language word types .To manage this complexity , we translate into target language clusterings of increasing vocabulary size .This approach gives dramatic speed - ups while additionally increasing final translation quality .The intersection of tree transducer - based translation models with n - gram language models results in huge dynamic programs for machine translation decoding .We propose a multipass , coarse - to - fine approach in which the language model complexity is incrementally introduced .", "label": "", "metadata": {}}
{"text": "Moreover , our entire decoding cascade for trigram language models is faster than the corresponding bigram pass alone of a bigram - to - trigram decoder .We present a discriminative , latent variable approach to syntactic parsing in which rules exist at multiple scales of refinement .The model is formally a latent variable CRF grammar over trees , learned by iteratively splitting grammar productions ( not categories ) .Different regions of the grammar are refined to different degrees , yielding grammars which are three orders of magnitude smaller than the single - scale baseline and 20 times smaller than the split - and - merge grammars of Petrov et al .", "label": "", "metadata": {}}
{"text": "In addition , our discriminative approach integrally admits features beyond local tree configurations .We present a multi - scale training method along with an efficient CKY - style dynamic program .On a variety of domains and languages , this method produces the best published parsing accuracies with the smallest reported grammars .To enable downstream language processing , automatic speech recognition output must be segmented into its individual sentences .Previous sentence segmentation systems have typically been very local , using low - level prosodic and lexical features to independently decide whether or not to segment at each word boundary position .", "label": "", "metadata": {}}
{"text": "While some previous work has included syntactic features , ours is the first to do so in a tractable , lattice - based way , which is crucial for scaling up to long - sentence contexts .Specifically , an ini- tial hypothesis lattice is constrcuted using local features .Candidate sentences are then assigned syntactic language model scores .These global syntactic scores are combined with local low - level scores in a log - linear model .The resulting system significantly outperforms the most popular long - span model for sentence segmentation ( the hidden event language model ) on both reference text and automatic speech recognizer output from news broadcasts .", "label": "", "metadata": {}}
{"text": "In our method , a minimal initial grammar is hierarchically refined using an adaptive split - and - merge EM procedure , giving compact , accurate grammars .The learning procedure directly maximizes the likelihood of the training treebank , without the use of any language specific or linguistically constrained features .Nonetheless , the resulting grammars encode many linguistically interpretable patterns and give the best published parsing accuracies on three German treebanks .We demonstrate that log - linear grammars with latent variables can be practically trained using discriminative methods .Central to efficient discriminative training is a hierarchical pruning procedure which allows feature expectations to be efficiently approximated in a gradient - based procedure .", "label": "", "metadata": {}}
{"text": "On full - scale treebank parsing experiments , the discriminative latent models outperform both the comparable generative latent models as well as the discriminative non - latent baselines .We present a maximally streamlined approach to learning HMM - based acoustic models for automatic speech recognition .In our approach , an initial monophone HMM is iteratively refined using a split - merge EM procedure which makes no assumptions about subphone structure or context - dependent structure , and which uses only a single Gaussian per HMM state .Despite the much simplified training process , our acoustic model achieves state - of - the - art results on phone classification ( where it outperforms almost all other methods ) and competitive performance on phone recognition ( where it outperforms standard CD triphone / subphone / GMM approaches ) .", "label": "", "metadata": {}}
{"text": "We present a nonparametric Bayesian model of tree structures based on the hierarchical Dirichlet process ( HDP ) .Our HDP - PCFG model allows the complexity of the grammar to grow as more training data is available .In addition to presenting a fully Bayesian model for the PCFG , we also develop an efficient variational inference procedure .On synthetic data , we recover the correct grammar without having to specify its complexity in advance .We also show that our techniques can be applied to full - scale parsing applications by demonstrating its effectiveness in learning state - split grammars .", "label": "", "metadata": {}}
{"text": "We describe a method in which a minimal grammar is hier- archically refined using EM to give accurate , compact gram- mars .The resulting grammars are extremely compact com- pared to other high - performance parsers , yet the parser gives the best published accuracies on several languages , as well as the best generative parsing numbers in English .In addi- tion , we give an associated coarse - to - fine inference scheme which vastly improves inference time with no loss in test set accuracy .We present several improvements to unlexicalized parsing with hierarchically state - split PCFGs .", "label": "", "metadata": {}}
{"text": "In our experiments , hierarchical pruning greatly accelerates parsing with no loss in empirical accuracy .Second , we compare various inference procedures for state - split PCFGs from the standpoint of risk minimization , paying particular attention to their practical tradeoffs .Finally , we present multilingual experiments which show that parsing with hierarchical state - splitting is fast and accurate in multiple languages and domains , even without any language - specific tuning .This work describes systems for detecting semantic categories present in news video .The multimedia data was processed in three ways : the audio signal was converted to a sequence of acoustic features , automatic speech recognition provided a word - level transcription , and image features were computed for selected frames of the video signal .", "label": "", "metadata": {}}
{"text": "Higher - level systems exploited correlations among the categories , incorporated sequential context , and combined the joint evidence from the three information sources .We present experimental results from the TREC video retrieval evaluation .We present an automatic approach to tree annotation in which basic nonterminal symbols are alternately split and merged to maximize the likelihood of a training treebank .Starting with a simple Xbar grammar , we learn a new grammar whose nonterminals are subsymbols of the original nonterminals .In contrast with previous work , we are able to split various terminals to different degrees , as appropriate to the actual complexity in the data .", "label": "", "metadata": {}}
{"text": "On the other hand , our grammars are much more compact and substantially more accurate than previous work on automatic annotation .Despite its simplicity , our best grammar achieves an F1 of 89.9 % on the Penn Treebank , higher than most fully lexicalized systems .While most work on parsing with PCFGs has focused on local correlations between tree configurations , we attempt to model non - local correlations using a finite mixture of PCFGs .A mixture grammar fit with the EM algorithm shows improvement over a single PCFG , both in parsing accuracy and in test data likelihood .", "label": "", "metadata": {}}
{"text": "Hand gestures are examples of fast and complex motions .Computers fail to track these in fast video , but sleight of hand fools humans as well : what happens too quickly we just can not see .We show a 3D tracker for these types of motions that relies on the recognition of familiar configurations in 2D images ( classification ) , and fills the gaps in - between ( interpolation ) .We illustrate this idea with experiments on hand motions similar to finger spelling .The penalty for a recognition failure is often small : if two con- figurations are confused , they are often similar to each other , and the illusion works well enough , for instance , to drive a graphics animation of the moving hand .", "label": "", "metadata": {}}
{"text": "This Master 's thesis describes parts of the control software used by the soccer robots of the Free University of Berlin , the so called FU - Fighters .The FU - Fighters compete in the Middle Sized League of RoboCup and reached the semi - finals during the 2004 RoboCup World Cup in Lisbon , Portugal .The thesis covers several independent topics : - Automatic White Balance : It is shown how to improve the white balancing of an omni - directional camera by using a reference color and a PID - controller . -Ball Tracking :", "label": "", "metadata": {}}
{"text": "Therefore a Kalman - filter based system for estimating the ball position and velocity in the presence of occlusions is developped . -Sensor Fusion : The robot perceives its environment through several independent sensors ( camera , odometer , etc . ) , which have different delays .We propose a novel method for fusing the sensor data and show our results through examples of selflocalization . -Behavior Control : Finally we show how all these elements can be incorporated into a goal keeping robot .We develop simple behaviors that can be used in a layered architecture and enable the robot to block most balls that are being shot at the goal .", "label": "", "metadata": {}}
{"text": "Introduction .This document provides a description of the format of dependency structures that are used as the input for the Alpino chart generator .Dependency structures describe grammatical dependency relations between lexical items , and the constituents dominating over lexical items .Since dependency structures for generation can contain less information than dependency trees that are produced as a side effect of parsing , we call them abstract dependency trees ( ADTs ) .While different input formalisms have been proposed for sentence realization in the past , such as minimal recursion semantics ( MRS ) , we have chosen to use a different input format that describes the grammatical dependencies of the to - be generated sentence .", "label": "", "metadata": {}}
{"text": "ADTs can be derived from ( Alpino ) dependency trees with ease .Most other input formalisms would require rather extensive changes to the lexicon and grammar .Prior work with Alpino dependency trees has shown that ( abstract ) dependency trees provide sufficient abstraction for tasks where a generation component is desired .This document describes the format of ADTs , including the representation of ADTs as Prolog terms and XML documents .The procedure for deriving an ADT from a normal Alpino dependency tree is also described .ADT is an abstraction of the dependency structure format of Alpino ( and the Lassy corpora ) .", "label": "", "metadata": {}}
{"text": "ADT .Introduction .An abstract dependency is a directed acyclic graph that models the grammatical relations between lexical items and categories built from lexical items .The generator creates realizations for abstract dependency trees that describe at least one possible sentence .An abstract dependency tree can consist of four node types : .Category ( interior ) nodes .Lexical ( leaf ) nodes .Indexed nodes .Reference nodes .Edges between nodes have a dependency label , where hd indicates the head of a grammatical relation .Figure [ dtree ] shows a dependency tree for the sentence \" De boeken kosten ons een klein fortuin \" .", "label": "", "metadata": {}}
{"text": "Category .All nodes are associated with a category .All possible categories are listed in table [ categories ] .Note that this is different from Alpino dependency structures , in which only interior nodes are associated with a category .Attributes .In addition to the Alpino part of speech tag , some additional information is normally required to determine the semantics embodied by an ADT .In particular , the number for nouns , and the tense and inflection for verbs should be known .The number of a noun may be specified with the rnum attribute , which can have one of the following values : sg , pl .", "label": "", "metadata": {}}
{"text": "The tense of the ( finite ) verb should be specified with the tense attribute , which can have one of the following values : present , past , subjunctive .If the attribute is not specified , the generator will attempt to produce both present and past tense , but not subjunctive .The sentence type can be specified using the attribute stype associated with the head of the sentence ( the finite verb ) .Possible values are ynquestion , whquestion , declarative , imparative , topic_drop .If the attribute is not specified , the generator will attempt to generate any sentence type .", "label": "", "metadata": {}}
{"text": "The attribute def has values def , indef .The attribute per has values fir , je , thi , u , u_thi .The attribute refl has a single possible value refl .The attribute wk has a single attribute yes to indicate that the pronominal is in reduced form ( as in we versus wij , me versus mij , etc . ) .If the attributes are not given , the generator will attempt to generate all consistent pronominals .Adjectives can be associated with the attribute aform with values base , compar and super to differentiate neutral , comparative and superlative adjectives .", "label": "", "metadata": {}}
{"text": "Names can be associated with the attribute neclass with values ' LOC ' , ' PER ' , ' ORG ' , and ' MISC ' .Unfortunately , the single quotes are currently part of the value .Currently , the category , relation name , and postag must be specified for any category .Some attributes need to be specified in the input , in order that Alpino will allow corresponding lexical entries to be considered for generation .These attributes are : . iets personalized pron .TODO : table of attributes with allowed values .TODO : table of attributes with default values .", "label": "", "metadata": {}}
{"text": "Indexed nodes are nodes associated with a specific index so that the node can be referred to by a reference node .For instance , in the sentence Ik heb de trein gemist both ik - heb and ik - gemist have a subject - head relation , while gemist is the head of a vc of heb .To allow for such representations , co - indexation is required .Reference nodes .Reference nodes only have an index , and no additional content nor sub - structure .The additional content can be found at the Index node with the same index .", "label": "", "metadata": {}}
{"text": "The current assumption is , that no punctuation is specified in the ADT .The generator will add a minimum amount of obligatory punctuation for a given ADT .Separable Verb Prefixes .To allow for an abstract description of verbs that have a separable particle , it is allowed to omit particles with the svp relation in an ADT .If such particles are not included as nodes in the ADT , the generator will attempt both to generate sentences with a separate particle as in ik bel hem op and a sentences in which the particle is not separated as in omdat ik hem opbel .", "label": "", "metadata": {}}
{"text": "Prolog .An ADT can be stored as a Prolog term that consists of recursive tree terms .The basic format is : .tree(Relation , Daughters ) .Where Relation is a relation term , and Daughters is a list of daughter nodes , or the empty list for leaf nodes .A relation has the following form : . r(Type , Label ) .Type indicates the type of relation , such as su , obj1 , or mod .The label comes in four types : interior nodes , leaf nodes , index nodes and reference nodes .", "label": "", "metadata": {}}
{"text": "tree(r(vc , p(ppart ) ) , [ ... ] ) .is a node of the category ppart with a vc relation .Lexical nodes use a adt_lex/5 term as their label : . adt_lex(Cat , Root , Sense , PosTag , Attributes ) .Here the category , root , sense , POS tag , and attributes of a lexical item are noted .The sense of a lexical item can contain additional information about a lexical item to select for a specific reading .For instance , for words with fixed parts , the fixed parts are often listed in the sense .", "label": "", "metadata": {}}
{"text": "The sense can be omitted by replacing it with a variable ( e.g. , _ ) .This is an example of a lexical node : .An index node is represented as : . i(Number , Label ) .where Label is an interior node or a leaf node .Reference nodes are represented by .i(Number ) .For instance , we can refer to .with : .i(1 ) .Combined , we can construct ADTs as Prolog terms for all grammatical sentences .E.g. , the ADT term for the sample discussed above is : . XML .", "label": "", "metadata": {}}
{"text": "The dependency tree is represented in XML as a recursive structure of node elements .Each node has an identifier ( i d ) and relation ( rel ) .Category nodes have a cat attribute that specifies the category .For instance : .Every lexical node has the root , sense , and postag attributes for respectively describing the word root , sense , and part of speech tag .E.g. : .Lexical nodes have other attributes , as described in the previous sections .For instace , here the num and gen attributes are also listed for the noun number and gender .", "label": "", "metadata": {}}
{"text": "The referring node also contains an index attribute , but no other information specific to a lexical node .For example : .As an example of a full ADT , we include an ADT for the same sentence used in the Prolog ADT : .How to obtain ADT structures .There are two approaches .First , you can take a dependency structure , as produced by Alpino , and convert it to a ADT ( using Alpino ) .Second , you can parse sentences with Alpino , and request an ADT as output .The format of the ADT is either Prolog or XML - as explained in a previous section .", "label": "", "metadata": {}}
{"text": "The ADT uses the Prolog format in this case .ADT from DT .This is currently not functioning properly .Perhaps this is not such a good idea anyway .[ Show abstract ] [ Hide abstract ] ABSTRACT : Parallel corpora are crucial for statistical machine translation ( SMT ) ; however , they are quite scarce for most language pairs and domains .As comparable corpora are far more available , many studies have been conducted to extract parallel sentences from them for SMT .Parallel sentence extraction relies highly on bilingual lexicons that are also very scarce .", "label": "", "metadata": {}}
{"text": "Our bilingual lexicon extraction method is based on a combination of topic model and context based methods in an iterative process .The proposed method does not rely on any prior knowledge , and the performance can be improved iteratively .The parallel sentence extraction method uses a binary classifier for parallel sentence identification .The extracted bilingual lexicons are used for the classifier to improve the performance of parallel sentence extraction .Experiments conducted with the Wikipedia data indicate that the proposed bilingual lexicon extraction method greatly outperforms existing methods , and the extracted bilingual lexicons significantly improve the performance of parallel sentence extraction for SMT .", "label": "", "metadata": {}}
{"text": "In this work , we focus on dependency grammar , which models syntax by encoding transparent predicate - argument structures .Recent advances in dependency parsing have shown that employing higher - order subtree structures in graph - based parsers can substantially improve the parsing accuracy .However , the inefficiency of this approach increases with the order of the subtrees .This work explores a new reranking approach for dependency parsing that can utilize complex subtree representations by applying efficient subtree selection methods .We demonstrate the effectiveness of the approach in experiments conducted on the Penn Treebank and the Chinese Treebank .", "label": "", "metadata": {}}
{"text": "No preview \u00b7 Article \u00b7 Jul 2014 \u00b7 IEEE / ACM Transactions on Audio , Speech , and Language Processing .[ Show abstract ] [ Hide abstract ] ABSTRACT : The focus of recent studies on Chinese word segmentation , part - of - speech ( POS ) tagging and parsing has been shifting from words to characters .However , existing methods have not yet fully utilized the potentials of Chinese characters .In this paper , we investigate the usefulness of character - level part - of - speech in the task of Chinese morphological analysis .", "label": "", "metadata": {}}
{"text": "We propose a method that performs character - level POS tagging jointly with word segmentation and word - level POS tagging .Through experiments , we demonstrate that by introducing character - level POS information , the performance of a baseline morphological analyzer can be significantly improved .[ Show abstract ] [ Hide abstract ] ABSTRACT : This article proposes a new distortion model for phrase - based statistical machine translation .In decoding , a distortion model estimates the source word position to be translated next ( subsequent position ; SP ) given the last translated source word position ( current position ; CP ) .", "label": "", "metadata": {}}
{"text": "Our model considers rich context by discriminating label sequences that specify spans from the CP to each SP candidate .It enables our model to learn the effect of relative word order among SP candidates as well as to learn the effect of distances from the training data .In contrast to the learning strategy of existing methods , our learning strategy is that the model learns preference relations among SP candidates in each sentence of the training data .This leaning strategy enables consideration of all of the rich context simultaneously .In our experiments , our model had higher BLUE and RIBES scores for Japanese - English , Chinese - English , and German - English translation compared to the lexical reordering models .", "label": "", "metadata": {}}
{"text": "[ Show abstract ] [ Hide abstract ] ABSTRACT : Many knowledge acquisition tasks are tightly dependent on fundamental analysis technologies , such as part of speech ( POS ) tagging and parsing .Dependency parsing , in particular , has been widely employed for the acquisition of knowledge related to predicate - argument structures .For such tasks , the dependency parsing performance can determine quality of acquired knowledge , regardless of target languages .Therefore , reducing dependency parsing errors and selecting high quality dependencies is of primary importance .In this study , we present a language - independent approach for automatically selecting high quality dependencies from automatic parses .", "label": "", "metadata": {}}
{"text": "Experimental results on seven languages show that our approach can effectively select high quality dependencies from dependency parses .[ Show abstract ] [ Hide abstract ] ABSTRACT : In Japanese , zero references often occur and many of them are categorized into zero ex - ophora , in which a referent is not mentioned in the document .However , previous studies have focused on only zero endophora , in which a referent explicitly appears .We present a zero reference resolution model considering zero exophora and author / reader of a document .To deal with zero exophora , our model adds pseudo entities corresponding to zero exophora to candidate referents of zero pronouns .", "label": "", "metadata": {}}
{"text": "We represent their particular behavior in a discourse as a feature vector of a machine learning model .The experimental results demonstrate the effectiveness of our model for not only zero exophora but also zero endophora .[ Show abstract ] [ Hide abstract ] ABSTRACT : We propose a method for automatically acquiring knowledge about case alternations between the passive / causative and active voices .Our method leverages large lexical case frames obtained from a large Web corpus , and several alternation patterns .We then use the acquired knowledge to a case alternation task and show its usefulness .", "label": "", "metadata": {}}
{"text": "We present a method that uses not only the information of surface words but also that of latent words that are inferred from texts .We infer latent word distribution in each document in the search results using latent Dirichlet allocation ( LDA ) .When feedback is given , we also infer the latent word distribution in the feedback using LDA .We calculate the similarities between the user feedback and each document in the search results using both the surface and latent word distributions and re - rank the search results on the basis of the similarities .", "label": "", "metadata": {}}
{"text": "Additionally , it proves that the proposed method can perform well even when only a small amount of user feedback is available .For example , an improvement of 5.3 % in P@10 was achieved when user feedback constituted only 57 words .[ Show abstract ] [ Hide abstract ] ABSTRACT : This paper presents a simple but effective approach to unknown word processing in Japanese morphological analysis , which handles 1 ) unknown words that are derived from words in a pre - defined lexicon and 2 ) unknown onomatopoeias .Our approach leverages derivation rules and onomatopoeia patterns , and correctly recognizes certain types of unknown words .", "label": "", "metadata": {}}
{"text": "[ Show abstract ] [ Hide abstract ] ABSTRACT : The Chinese and Japanese languages share Chinese characters .Since the Chinese characters in Japanese originated from ancient China , many common Chinese characters exist between these two languages .Since Chinese characters contain significant semantic information and common Chinese characters share the same meaning in the two languages , they can be quite useful in Chinese - Japanese machine translation ( MT ) .We therefore propose a method for creating a Chinese character mapping table for Japanese , traditional Chinese , and simplified Chinese , with the aim of constructing a complete resource of common Chinese characters .", "label": "", "metadata": {}}
{"text": "We also propose a statistical method for detecting other semantically equivalent Chinese characters other than the common ones and a method for exploiting shared Chinese characters in phrase alignment .Results of the experiments carried out on a state - of - the - art phrase - based statistical MT system and an example - based MT system show that our proposed approaches can improve MT performance significantly , thereby verifying the effectiveness of shared Chinese characters for Chinese - Japanese MT . .No preview \u00b7 Article \u00b7 Oct 2013 \u00b7 ACM Transactions on Asian Language Information Processing .", "label": "", "metadata": {}}
{"text": "In decoding , a distortion model estimates the source word position to be translated next ( NP ) given the last translated source word position ( CP ) .We propose a distortion model that can consider the word at the CP , a word at an NP candidate , and the context of the CP and the NP candidate simultaneously .Moreover , we propose a further improved model that considers richer context by discriminating label sequences that specify spans from the CP to NP candidates .It enables our model to learn the effect of relative word order among NP candidates as well as to learn the effect of distances from the training data .", "label": "", "metadata": {}}
{"text": "[ Show abstract ] [ Hide abstract ] ABSTRACT :In this paper , we propose the use of spans in addition to edges in noun compound analysis .A span is a sequence of words that can represent a noun compound .Compared with edges , spans have good properties in terms of semi - supervised parsing .They can be reliably extracted from a huge amount of unannotated text .In addition , while the combinations of edges such as sibling and grandparent interactions are , in general , difficult to handle in parsing , it is quite easy to utilize spans with arbitrary width .", "label": "", "metadata": {}}
{"text": "We create a semi - supervised discriminative parser that combines edge and span features .Experiments show that span features improve accuracy and that further gain is obtained when they are combined with edge features .[ Show abstract ] [ Hide abstract ] ABSTRACT : This article proposes a predicate - argument structure based Textual Entailment Recognition system exploiting wide - coverage lexical knowledge .Different from conventional machine learning approaches where several features obtained from linguistic analysis and resources are utilized , our proposed method regards a predicate - argument structure as a basic unit , and performs the matching / alignment between a text and hypothesis .", "label": "", "metadata": {}}
{"text": "No preview \u00b7 Article \u00b7 Dec 2012 \u00b7 ACM Transactions on Asian Language Information Processing .[ Show abstract ] [ Hide abstract ] ABSTRACT : Sentence compression is important in a wide range of applications in natural language processing .Previous approaches of Japanese sentence compression can be divided into two groups .Word - based methods extract a subset of words from a sentence to shorten it , while bunsetsubased methods extract a subset of bunsetsu ( where a bunsetsu is a text unit that consists of content words and following function words ) .Basically , bunsetsu - based methods perform better than word - based methods .", "label": "", "metadata": {}}
{"text": "In this paper , we propose a novel compression method to overcome this disadvantage .Our method relaxes the constraints using Lagrangian relaxation and shortens each bunsetsu if it contains unimportant words .Experimental results show that our method effectively compresses a sentence while preserving its important information and grammaticality .We describe a method for recording lists of labelled values in a text string , called Dublin Core Structured Values , with the label DCSV .The notation is intended for structured information within attribute values in markup - languages such as HTML and XML .This is likely to be useful in recording complex element values in metadata systems based on the qualified Dublin Core model .", "label": "", "metadata": {}}
{"text": "The syntax examples included in this document are provisional , and are currently under review as part of the DCMI work on recommending coordinated syntax recommendations for HTML , XML , and RDF .These recommendations and minor editorial changes in this document can be expected to take place in the near future .Table of Contents .It is highly desirable to be able to encode or serialise structured values within a plain - text string .Some generic methods are in common use .Inheriting conventions from natural languages , commas ( , ) and semi - colons ( ;) are frequently used as list separators .", "label": "", "metadata": {}}
{"text": "Dots ( . ) and dashes ( - ) are sometimes used to imply hierarchies , particularly in thesaurus applications .A number of named encoding schemes use punctuation characters within a text string to indicate specific components .For example , a colon ( :) terminates the protocol label , and slashes ( / ) , question - marks ( ? ) , ampersands ( & ) and hashes ( # ) are used to separate other fields in identifiers coded as URI 's [ URI ] .Colons ( :) separate specified labels from values within a field , and semi - colons ( ;) separate fields within a personal description according to a common implementation of vCard [ vCard ] .", "label": "", "metadata": {}}
{"text": "For some schemes - vCard and W3C - DTF , for example - the punctuation indicates a very formal structure to the value , and is expected to be parsed automatically .Element attributes in markup languages , such as HTML [ HTML4 ] and XML [ XML ] , provide a position for recording data .In other cases there may be good reasons to store data in element attributes rather than element content .This syntax trick can be used to embed XML - RDF encoded data safely in current versions of HTML [ RDF - in - HTML ] .", "label": "", "metadata": {}}
{"text": "However , the use of element attributes for storing data has some technical limitations : . attributes may occur no more than once .values are constrained to a set of types which restricts the permissible character - strings [ HTML4 ] in some contexts .In general , strings containing these characters are prone to misinterpretation by some user - agents ( e.g. browsers ) .Note that there is no intrinsic way to indicate structure within the values of attributes of HTML elements .Our intention in this recommendation is to define a compact human - readable data - structuring method for HTML attribute values of content type CDATA , avoiding certain punctuation characters which are prone to cause difficulties in some encoding environments .", "label": "", "metadata": {}}
{"text": "It is based on methods used and found successful elsewhere , but is more generalised than the preceding standards .It may be used as the basis of profiles designed to encode particular data types [ Profiles ] .Structured Values - the DCSV scheme .To allow the recording of generic Structured Values , we introduce the Dublin Core Structured Values ( DCSV ) scheme .We distinguish between two types of substring - labels and values , where a label is the name of the type of a value , and a value is the data itself .", "label": "", "metadata": {}}
{"text": "A value that is comprised of components in this way is called a structured value .Punctuation characters are used in recording a structured value as follows : . colons ( :) separate plain - text labels of structured value - components from the values themselves . semi - colons ( ;) separate ( optionally labelled ) value - components within a list . dots ( . ) indicate hierachical structure in labels , if required .The labels and the component values themselves each consist of a text - string .The intention is that the label will be a word or code corresponding to the name of the value - component .", "label": "", "metadata": {}}
{"text": "The following patterns show how structured values may be recorded in strings using DCSV : . \" u1 ; u2 ; u3 \" . \"cA : v1 \" . \"cA : v1 ; cB.part1:v2 ; cB.part2:v3 \" . \"cA : v1 ; u2 ; u3 \" .where u1 , u2 and u3 are unlabelled components , cA and cB are the labels of Structured Value components , .part1 and part2 are sub - components of , and v1 , v2 and v3 are values of the components .The use of specific punctuation characters in DCSV coded values means that care must be exercised if these characters are to be used directly within strings which comprise the content ( either labels or values ) of the components .", "label": "", "metadata": {}}
{"text": "There should be no ambiguity regarding the dot , full - stop or period ( . ) within strings : when it is part of a label , a dot indicates some hierachy ; when part of a value , it has the conventional meaning for the context .This method of escaping special characters largely preserves readability and the ability to enter DCSV coded metadata values easily using a text - editor if required .Software written to process DCSV coded values must make the necessary substitutions .Note that in HTML the double - quote ( \") character can be used directly within a CDATA attribute value if the full string is delimited by single - quotes ( ' ) , but in XML the double - quote must be encoded as a character entity in element attributes .", "label": "", "metadata": {}}
{"text": "DCSV is only intended to be used for relatively simple structured values , probably as an interim approach , pending more general support for syntaxes such as XML which allow recording of more complex hierarchical structures .However , it is more compact than the XML equivalent , and is more easily read and constructed in some common contexts , such as within HTML elements .Parsing DCSV .A simple method can be used to parse metadata values recorded according to the DCSV scheme .For a single value recorded using the DCSV scheme : . split the text - string into a list of substrings on any unescaped semi - colons ( ;) ; if no semi - colon is present , there is a single substring .", "label": "", "metadata": {}}
{"text": "within each value replace the escaped characters with the actual character required .A short Perl program which performs this parsing operation is included at the end of this recommendation .Examples .\" name.given:Renato;name.family:Iannella ; employer : DSTC ; Contact : Level 7 , Gehrmann Labs , The University of Queensland , Qld .4072 , Australia \" .\" rows:200 ; cols:450 \" .DCSV does not support the full structure available using more complete notations such as XML , but nevertheless relatively rich information may be stored in DCSV and then migrated into fully structured notations when appropriate .", "label": "", "metadata": {}}
{"text": "Sample Code for parsing DCSV coded values .The following Perl program reads a DCSV coded string entered on stdin , and prints a formatted version of the structured result .This code is provided for demonstration purposes only and contains no error - checking ./usr / local / bin / perl . print \" Enter string to be parsed:\\n \" ; . print \" \\nString to be parsed is [ $ string]\\n \" ; . unpack('C',\"% \" ) .\" % \" /eg ; .unpack('C',$1 ) .\" % \" /eg ; . print \" \\nEscaped string is [ $ string]\\n \" ; . # if there is no : $ value is empty so copy $ name into $ value and empty $ name if ( !", "label": "", "metadata": {}}
{"text": "John Kunze encouraged us to write up this proposal formally .Kim Covil wrote the perl code .Eric Miller nagged regarding the overlap with XML .Google Maps APIs Web Services .The Google Maps web services are a collection of HTTP interfaces to Google services providing geographic data for your maps applications .This guide serves only to introduce the web services and host information common to all of the different services .Individual documentation for each service is located below : .Find out which API you need .More about the web services .The remainder of this guide discusses techniques for setting up web service requests and parsing the responses .", "label": "", "metadata": {}}
{"text": "What is a web service ?The Google Maps API provides these web services as an interface for requesting Maps API data from external services and using them within your Maps applications .These services are designed to be used in conjunction with a map , as per the Maps API Terms of Service License Restrictions .These web services use HTTP requests to specific URLs , passing URL parameters as arguments to the services .Generally , these services return data in the HTTP request as either JSON or XML for parsing and/or processing by your application .A typical web service request is generally of the following form : . parameters .", "label": "", "metadata": {}}
{"text": "Full documentation of each service is contained within the particular developer guides for those services .However , this guide serves to hold some common practices useful for setting up your web service requests and processing your web service responses .SSL Access .HTTPS is required for all Maps API web service requests containing user data , or developer identifiers .Requests made over HTTP that include sensitive data may be rejected .Building a Valid URL .You may think that a \" valid \" URL is self - evident , but that 's not quite the case .", "label": "", "metadata": {}}
{"text": "This process is called URL - encoding .We need to translate special characters because all URLs need to conform to the syntax specified by the W3 Uniform Resource Identifier specification .In effect , this means that URLs must contain only a special subset of ASCII characters : the familiar alphanumeric symbols , and some reserved characters for use as control characters within URLs .The table below summarizes these characters : .Summary of Valid URL Characters .Set . characters .URL usage .Alphanumeric .Text strings , scheme usage ( http ) , port ( 8080 ) , etc . .", "label": "", "metadata": {}}
{"text": "_ .Text strings .Reserved . % # [ ] .Control characters and/or Text Strings .When building a valid URL , you must ensure that it contains only those characters shown above .Conforming a URL to use this set of characters generally leads to two issues , one of omission and one of substitution : .Characters that you wish to handle exist outside of the above set .By popular convention , spaces ( which are not allowed within URLs ) are often represented using the plus ' + ' character as well .Characters exist within the above set as reserved characters , but need to be used literally .", "label": "", "metadata": {}}
{"text": "All characters to be URL - encoded are encoded using a ' % ' character and a two - character hex value corresponding to their UTF-8 character .The string ? and the Mysterians would be URL - encoded as % 3F+and+the+Mysterians .% 3C . % 3E . %7C .Converting a URL that you receive from user input is sometimes tricky .For example , a user may enter an address as \" 5th&Main St. \" Generally , you should construct your URL from its parts , treating any user input as literal characters .Additionally , URLs are limited to 2048 characters for all web services .", "label": "", "metadata": {}}
{"text": "However , note that certain services have several parameters that may result in long URLs .Polite Use of Google APIs .Poorly designed API clients can place more load than necessary on both the Internet and Google 's servers .This section contains some best practices for clients of the APIs .Following these best practices can help you avoid your application being blocked for inadvertent abuse of the APIs .Exponential Backoff .In rare cases something may go wrong serving your request ; you may receive a 4XX or 5XX HTTP response code , or the TCP connection may simply fail somewhere between your client and Google 's server .", "label": "", "metadata": {}}
{"text": "However , it is important not to simply loop repeatedly making requests to Google 's servers .This looping behavior can overload the network between your client and Google causing problems for many parties .A better approach is to retry with increasing delays between attempts .Usually the delay is increased by a multiplicative factor with each attempt , an approach known as Exponential Backoff .For example , consider an application that wishes to make this request to the Google Maps Time Zone API : .The following Python example shows how to make the request with exponential backoff : . import json import time import urllib import urllib2 def timezone(lat , lng , timestamp ) : # The maps_key defined below is n't a valid Google Maps API key .", "label": "", "metadata": {}}
{"text": "while True : try : # Get the API response . read ( ) ) except IOError : pass # Fall through the to the retry loop .else : # If we did n't get an IOError then parse the result .There is no point retrying these requests .print ' Waiting ' , current_delay , ' seconds before retrying . 'You should also be careful that there is n't retry code higher in the application call chain that leads to repeated requests in quick succession .Synchronized Requests .Large numbers of synchronized requests to Google 's APIs can look like a Distributed Denial of Service ( DDoS ) attack on Google 's infrastructure , and be treated accordingly .", "label": "", "metadata": {}}
{"text": "For example , consider an application that displays the time in the current time zone .This application will probably set an alarm in the client operating system waking it up at the start of the minute so that the displayed time can be updated .The application should not make any API calls as part of the processing associated with that alarm .Making API calls in response to a fixed alarm is bad as it results in the API calls being synchronized to the start of the minute , even between different devices , rather than being distributed evenly over time .", "label": "", "metadata": {}}
{"text": "Instead , one possible good design is to have a second alarm set to a randomly chosen time .When this second alarm fires the application calls any APIs it needs and stores the results .When the application wants to update its display at the start of the minute , it uses previously stored results rather than calling the API again .With this approach , API calls are spread evenly over time .Further , the API calls do not delay rendering when the display is being updated .Aside from the start of the minute , other common synchronization times you should be careful not to target are at the start of an hour , and the start of each day at midnight .", "label": "", "metadata": {}}
{"text": "As the exact format of individual responses with a web service request is not guaranteed ( some elements may be missing or in multiple locations ) , you should never assume that the format returned for any given response will be the same for different queries .Instead , you should process the response and select appropriate values via expressions .This section discusses how to extract these values dynamically from web service responses .The Google Maps web services provide responses which are easy to understand , but not exactly user friendly .When performing a query , rather than display a set of data , you probably want to extract a few specific values .", "label": "", "metadata": {}}
{"text": "The parsing scheme you use depends on whether you are returning output in XML or JSON .JSON responses , being already in the form of Javascript objects , may be processed within Javascript itself on the client ; XML responses should be processed using an XML processor and an XML query language to address elements within the XML format .We use XPath in the following examples , as it is commonly supported in XML processing libraries .Processing XML with XPath .XML is a relatively mature structured information format used for data interchange .Although it is not as lightweight as JSON , XML does provide more language support and more robust tools .", "label": "", "metadata": {}}
{"text": "When processing XML responses , you should use an appropriate query language for selecting nodes within the XML document , rather than assume the elements reside at absolute positions within the XML markup .XPath is a language syntax for uniquely describing nodes and elements within an XML document .XPath expressions allow you to identify specific content within the XML response document . XPathExpressions .Some familiarity with XPath goes a long way towards developing a robust parsing scheme .This section will focus on how elements within an XML document are addressed with XPath , allowing you to address multiple elements and construct complex queries . XPath uses expressions to select elements within an XML document , using a syntax similar to that used for directory paths .", "label": "", "metadata": {}}
{"text": "Generally , XPath expressions are greedy , indicating that they will match all nodes which match the supplied criteria .We 'll use the following abstract XML to illustrate our examples : .OK sample Sample XML 37.4217550 -122.0846330 The secret message .Node Selection in Expressions .XPath selections select nodes .The root node encompasses the entire document .You select this node using the special expression \" / \" .Note that the root node is not the top - level node of your XML document ; actually , it resides one level above this top - level element and includes it .", "label": "", "metadata": {}}
{"text": "You select individual nodes either via absolute or relative paths , indicated by the presence or absence of a leading \" / \" character .( Note that both of these elements descend from the root node \" / \" . )Generally , you should n't have to worry about context , as you 're usually processing web service results via a single expression .Either of these expressions may be augmented through addition of a wildcard path , indicated with a double - slash ( \" // \") .This wildcard indicates that zero or more elements may match in the intervening path .", "label": "", "metadata": {}}
{"text": "By default , XPath expressions match all elements .You can restrict the expression to match a certain element by providing a predicate , which is enclosed in square brackets ( [ ] ) .The XPath expression \" /GeocodeResponse / result[2 ] always returns the second result , for example .Type of Expression .Root node . XPathExpression : \" / \" .Selection : .OK sample Sample XML 37.4217550 -122.0846330 The secret message .Absolute Path . XPathExpression : \" /WebServiceResponse / result \" .Selection : . sample Sample XML 37.4217550 -122.0846330 The secret message . XPath", "label": "", "metadata": {}}
{"text": "Selection : .Path with Predicate . XPathExpression : \" /WebServiceResponse / result[2]/message \" .Selection : .The secret message .All direct children of the first result .Selection : . sample Sample XML 37.4217550 -122.0846330 .The name of a result whose type text is \" sample .Selection : .Sample XML .It is important to note that when selecting elements , you select nodes , not just the text within those objects .Generally , you will want to iterate over all matched nodes and extract the text .You may also match text nodes directly ; see Text Nodes below .", "label": "", "metadata": {}}
{"text": "Text Selection in Expressions .Text within an XML document is specified in XPath expressions via a text node operator .This operator \" text ( ) \" indicates extraction of text from the indicated node .Type of Expression .All text nodes ( including whitespace ) . XPathExpression : \" //text ( ) \" .Selection : .Text Selection . XPathExpression : \" /WebServiceRequest / result[2]/message / text ( ) \" .Context Sensitive Selection .Sample XML .Alternatively , you may evaluate an expression and return a set of nodes and then iterate over that \" node set , \" extracting the text from each node .", "label": "", "metadata": {}}
{"text": "Evaluating XPath in Java .Java has wide support for parsing XML and using XPath expressions within the javax.xml.xpath .For that reason , the sample code in this section uses Java to illustrate how to handle XML and parse data from XML service responses .To use XPath in your Java code , you will first need to instantiate an instance of an XPathFactory and call newXPath ( ) on that factory to create an XPath object .This object can then process passed XML and XPath expressions using the evaluate ( ) method .When evaluating XPath expressions , make sure that you iterate over any possible \" node sets \" which may be returned .", "label": "", "metadata": {}}
{"text": "The following code illustrates how to create an XPath object , assign it XML and an XPath expression , and evaluate the expression to print out the relevant content . import org.xml.sax.InputSource ; import org.w3c.dom .// Here we simply access an existing file .// The xpath evaluator requires the XML be in the format of an InputSource .// Because the evaluator may return multiple entries , we specify that the expression .// return a NODESET and place the result in a NodeList .// We can then iterate over the NodeList and extract the content via getTextContent ( ) .", "label": "", "metadata": {}}
{"text": "getTextContent ( ) ; .System.out.print(nodeString ) ; .Processing JSON with Javascript .JSON ( Javascript Object Notation ) has an obvious advantage over XML in that the response is lightweight .Parsing such a result is trivial in JavaScript as the format is already a valid Javascript object .For example , to extract the value of the ' formatted_address ' keys within a JSON result object , simply access them using the following code : .Note that because JSON may contain multiple values , it 's wisest to iterate over the length of the results array if you want to capture all possible values .", "label": "", "metadata": {}}
{"text": "Parsing JSON in other languages is only moderately more difficult .The following Python example initiates a Geocoding Web Service request and displays all resulting formatted_address values to the user within an array : .Output : . [ . \" San Francisco , CA , USA \" . ]The sensor Parameter .The Google Maps API previously required that you include the sensor parameter to indicate whether your application used a sensor to determine the user 's location .This parameter is no longer required .Developer Consoles .Explore .Google Maps APIs Web Services .The Google Maps web services are a collection of HTTP interfaces to Google services providing geographic data for your maps applications .", "label": "", "metadata": {}}
{"text": "Individual documentation for each service is located below : .Find out which API you need .More about the web services .The remainder of this guide discusses techniques for setting up web service requests and parsing the responses .For particular documentation for each service , however , you must consult the appropriate documentation .What is a web service ?The Google Maps API provides these web services as an interface for requesting Maps API data from external services and using them within your Maps applications .These services are designed to be used in conjunction with a map , as per the Maps API Terms of Service License Restrictions .", "label": "", "metadata": {}}
{"text": "Generally , these services return data in the HTTP request as either JSON or XML for parsing and/or processing by your application .A typical web service request is generally of the following form : . parameters .where service indicates the particular service requested and output indicates the response format ( usually json or xml ) .Full documentation of each service is contained within the particular developer guides for those services .However , this guide serves to hold some common practices useful for setting up your web service requests and processing your web service responses .SSL Access .", "label": "", "metadata": {}}
{"text": "Requests made over HTTP that include sensitive data may be rejected .Building a Valid URL .You may think that a \" valid \" URL is self - evident , but that 's not quite the case .By the same token , any code that generates or accepts UTF-8 input might treat URLs with UTF-8 characters as \" valid \" , but would also need to translate those characters before sending them out to a web server .This process is called URL - encoding .We need to translate special characters because all URLs need to conform to the syntax specified by the W3 Uniform Resource Identifier specification .", "label": "", "metadata": {}}
{"text": "The table below summarizes these characters : .Summary of Valid URL Characters .Set . characters .URL usage .Alphanumeric .Text strings , scheme usage ( http ) , port ( 8080 ) , etc . .Unreserved . -_ .Text strings .Reserved . % # [ ] .Control characters and/or Text Strings .When building a valid URL , you must ensure that it contains only those characters shown above .Conforming a URL to use this set of characters generally leads to two issues , one of omission and one of substitution : .", "label": "", "metadata": {}}
{"text": "By popular convention , spaces ( which are not allowed within URLs ) are often represented using the plus ' + ' character as well .Characters exist within the above set as reserved characters , but need to be used literally .For example , ? is used within URLs to indicate the beginning of the query string ; if you wish to use the string \" ? and the Mysterions , \" you 'd need to encode the ' ? ' character .All characters to be URL - encoded are encoded using a ' % ' character and a two - character hex value corresponding to their UTF-8 character .", "label": "", "metadata": {}}
{"text": "% 3C . % 3E . %7C .Converting a URL that you receive from user input is sometimes tricky .For example , a user may enter an address as \" 5th&Main St. \" Generally , you should construct your URL from its parts , treating any user input as literal characters .Additionally , URLs are limited to 2048 characters for all web services .For most services , this character limit will seldom be approached .However , note that certain services have several parameters that may result in long URLs .Polite Use of Google APIs .", "label": "", "metadata": {}}
{"text": "This section contains some best practices for clients of the APIs .Following these best practices can help you avoid your application being blocked for inadvertent abuse of the APIs .Exponential Backoff .In rare cases something may go wrong serving your request ; you may receive a 4XX or 5XX HTTP response code , or the TCP connection may simply fail somewhere between your client and Google 's server .Often it is worthwhile re - trying the request as the followup request may succeed when the original failed .However , it is important not to simply loop repeatedly making requests to Google 's servers .", "label": "", "metadata": {}}
{"text": "A better approach is to retry with increasing delays between attempts .Usually the delay is increased by a multiplicative factor with each attempt , an approach known as Exponential Backoff .For example , consider an application that wishes to make this request to the Google Maps Time Zone API : .The following Python example shows how to make the request with exponential backoff : . import json import time import urllib import urllib2 def timezone(lat , lng , timestamp ) : # The maps_key defined below is n't a valid Google Maps API key .# You need to get your own API key .", "label": "", "metadata": {}}
{"text": "else : # If we did n't get an IOError then parse the result .There is no point retrying these requests .print ' Waiting ' , current_delay , ' seconds before retrying . 'You should also be careful that there is n't retry code higher in the application call chain that leads to repeated requests in quick succession .Synchronized Requests .Large numbers of synchronized requests to Google 's APIs can look like a Distributed Denial of Service ( DDoS ) attack on Google 's infrastructure , and be treated accordingly .To avoid this , you should make sure that API requests are not synchronized between clients .", "label": "", "metadata": {}}
{"text": "This application will probably set an alarm in the client operating system waking it up at the start of the minute so that the displayed time can be updated .The application should not make any API calls as part of the processing associated with that alarm .Making API calls in response to a fixed alarm is bad as it results in the API calls being synchronized to the start of the minute , even between different devices , rather than being distributed evenly over time .A poorly designed application doing this will produce a spike of traffic at sixty times normal levels at the start of each minute .", "label": "", "metadata": {}}
{"text": "When this second alarm fires the application calls any APIs it needs and stores the results .When the application wants to update its display at the start of the minute , it uses previously stored results rather than calling the API again .With this approach , API calls are spread evenly over time .Further , the API calls do not delay rendering when the display is being updated .Aside from the start of the minute , other common synchronization times you should be careful not to target are at the start of an hour , and the start of each day at midnight .", "label": "", "metadata": {}}
{"text": "As the exact format of individual responses with a web service request is not guaranteed ( some elements may be missing or in multiple locations ) , you should never assume that the format returned for any given response will be the same for different queries .Instead , you should process the response and select appropriate values via expressions .This section discusses how to extract these values dynamically from web service responses .The Google Maps web services provide responses which are easy to understand , but not exactly user friendly .When performing a query , rather than display a set of data , you probably want to extract a few specific values .", "label": "", "metadata": {}}
{"text": "The parsing scheme you use depends on whether you are returning output in XML or JSON .JSON responses , being already in the form of Javascript objects , may be processed within Javascript itself on the client ; XML responses should be processed using an XML processor and an XML query language to address elements within the XML format .We use XPath in the following examples , as it is commonly supported in XML processing libraries .Processing XML with XPath .XML is a relatively mature structured information format used for data interchange .Although it is not as lightweight as JSON , XML does provide more language support and more robust tools .", "label": "", "metadata": {}}
{"text": "When processing XML responses , you should use an appropriate query language for selecting nodes within the XML document , rather than assume the elements reside at absolute positions within the XML markup .XPath is a language syntax for uniquely describing nodes and elements within an XML document .XPath expressions allow you to identify specific content within the XML response document . XPathExpressions .Some familiarity with XPath goes a long way towards developing a robust parsing scheme .This section will focus on how elements within an XML document are addressed with XPath , allowing you to address multiple elements and construct complex queries . XPath uses expressions to select elements within an XML document , using a syntax similar to that used for directory paths .", "label": "", "metadata": {}}
{"text": "Generally , XPath expressions are greedy , indicating that they will match all nodes which match the supplied criteria .We 'll use the following abstract XML to illustrate our examples : .OK sample Sample XML 37.4217550 -122.0846330 The secret message .Node Selection in Expressions .XPath selections select nodes .The root node encompasses the entire document .You select this node using the special expression \" / \" .Note that the root node is not the top - level node of your XML document ; actually , it resides one level above this top - level element and includes it .", "label": "", "metadata": {}}
{"text": "You select individual nodes either via absolute or relative paths , indicated by the presence or absence of a leading \" / \" character .( Note that both of these elements descend from the root node \" / \" . )Generally , you should n't have to worry about context , as you 're usually processing web service results via a single expression .Either of these expressions may be augmented through addition of a wildcard path , indicated with a double - slash ( \" // \") .This wildcard indicates that zero or more elements may match in the intervening path .", "label": "", "metadata": {}}
{"text": "By default , XPath expressions match all elements .You can restrict the expression to match a certain element by providing a predicate , which is enclosed in square brackets ( [ ] ) .The XPath expression \" /GeocodeResponse / result[2 ] always returns the second result , for example .Type of Expression .Root node . XPathExpression : \" / \" .Selection : .OK sample Sample XML 37.4217550 -122.0846330 The secret message .Absolute Path . XPathExpression : \" /WebServiceResponse / result \" .Selection : . sample Sample XML 37.4217550 -122.0846330 The secret message . XPath", "label": "", "metadata": {}}
{"text": "Selection : .Path with Predicate . XPathExpression : \" /WebServiceResponse / result[2]/message \" .Selection : .The secret message .All direct children of the first result .Selection : . sample Sample XML 37.4217550 -122.0846330 .The name of a result whose type text is \" sample .Selection : .Sample XML .It is important to note that when selecting elements , you select nodes , not just the text within those objects .Generally , you will want to iterate over all matched nodes and extract the text .You may also match text nodes directly ; see Text Nodes below .", "label": "", "metadata": {}}
{"text": "Text Selection in Expressions .Text within an XML document is specified in XPath expressions via a text node operator .This operator \" text ( ) \" indicates extraction of text from the indicated node .Type of Expression .All text nodes ( including whitespace ) . XPathExpression : \" //text ( ) \" .Selection : .Text Selection . XPathExpression : \" /WebServiceRequest / result[2]/message / text ( ) \" .Context Sensitive Selection .Sample XML .Alternatively , you may evaluate an expression and return a set of nodes and then iterate over that \" node set , \" extracting the text from each node .", "label": "", "metadata": {}}
{"text": "Evaluating XPath in Java .Java has wide support for parsing XML and using XPath expressions within the javax.xml.xpath .For that reason , the sample code in this section uses Java to illustrate how to handle XML and parse data from XML service responses .To use XPath in your Java code , you will first need to instantiate an instance of an XPathFactory and call newXPath ( ) on that factory to create an XPath object .This object can then process passed XML and XPath expressions using the evaluate ( ) method .When evaluating XPath expressions , make sure that you iterate over any possible \" node sets \" which may be returned .", "label": "", "metadata": {}}
{"text": "The following code illustrates how to create an XPath object , assign it XML and an XPath expression , and evaluate the expression to print out the relevant content . import org.xml.sax.InputSource ; import org.w3c.dom .// Here we simply access an existing file .// The xpath evaluator requires the XML be in the format of an InputSource .// Because the evaluator may return multiple entries , we specify that the expression .// return a NODESET and place the result in a NodeList .// We can then iterate over the NodeList and extract the content via getTextContent ( ) .", "label": "", "metadata": {}}
{"text": "getTextContent ( ) ; .System.out.print(nodeString ) ; .Processing JSON with Javascript .JSON ( Javascript Object Notation ) has an obvious advantage over XML in that the response is lightweight .Parsing such a result is trivial in JavaScript as the format is already a valid Javascript object .For example , to extract the value of the ' formatted_address ' keys within a JSON result object , simply access them using the following code : .Note that because JSON may contain multiple values , it 's wisest to iterate over the length of the results array if you want to capture all possible values .", "label": "", "metadata": {}}
{"text": "Parsing JSON in other languages is only moderately more difficult .The following Python example initiates a Geocoding Web Service request and displays all resulting formatted_address values to the user within an array : .Output : . [ . \" San Francisco , CA , USA \" . ]The sensor Parameter .The Google Maps API previously required that you include the sensor parameter to indicate whether your application used a sensor to determine the user 's location .This parameter is no longer required .D\u00e9couvrir .Navigation .This Page .Examples .The output from all the example programs from PyMOTW has been generated with Python 2.7.8 , unless otherwise noted .", "label": "", "metadata": {}}
{"text": "Navigation .In addition to its parsing capabilities , xml.etree.ElementTree also supports creating well - formed XML documents from Element objects constructed in an application .The Element class used when a document is parsed also knows how to generate a serialized form of its contents , which can then be written to a file or other data stream .There are three helper functions useful for creating a hierarchy of Element nodes .Element ( ) creates a standard node , SubElement ( ) attaches a new node to a parent , and Comment ( ) creates a node that serializes using XML 's comment syntax .", "label": "", "metadata": {}}
{"text": "The output contains only the XML nodes in the tree , not the XML declaration with version and encoding .$ python ElementTree_create.py This child contains text .This child has regular text .A nd \" tail \" text .This & that .The & character in the text of child_with_entity_ref is converted to the entity reference & amp ; automatically .ElementTree makes no effort to \" pretty print \" the output produced by tostring ( ) , since adding extra whitespace changes the contents of the document .To make the output easier to follow for human readers , the rest of the examples below will use a tip I found online and re - parse the XML with xml.dom.minidom then use its toprettyxml ( ) method .", "label": "", "metadata": {}}
{"text": "parseString ( rough_string ) return reparsed .The updated example now looks like : .child_with_tail . and the output is easier to read : .$ python ElementTree_create_pretty.py This child contains text .This child has regular text .And \" tail \" text .This & that .In addition to the extra whitespace for formatting , the xml.dom.minidom pretty - printer also adds an XML declaration to the output .The previous example created nodes with tags and text content , but did not set any attributes of the nodes .Many of the examples from Parsing XML Documents worked with an OPML file listing podcasts and their feeds .", "label": "", "metadata": {}}
{"text": "ElementTree can be used to construct a similar XML file from a CSV input file , setting all of the element attributes as the tree is constructed . datetime . set ( ' version ' , ' 1.0 ' ) root .The attribute values can be configured one at a time with set ( ) ( as with the root node ) , or all at once by passing a dictionary to the node factory ( as with each group and podcast node ) .$ python ElementTree_csv_to_xml.py My Podcasts 2013 - 02 - 21 06:38:01.4940662013 - 02 - 21 06:38:01.494066 .", "label": "", "metadata": {}}
{"text": "The argument to extend ( ) is any iterable , including a list or another Element instance . extend ( children ) print prettify ( top ) .When a list is given , the nodes in the list are added directly to the new parent .$ python ElementTree_extend.py .When another Element instance is given , the children of that node are added to the new parent . extend ( children ) print prettify ( top ) .In this case , the node with tag root created by parsing the XML string has three children , which are added to the parent node .", "label": "", "metadata": {}}
{"text": "$ python ElementTree_extend_node.py .It is important to understand that extend ( ) does not modify any existing parent - child relationships with the nodes .If the values passed to extend exist somewhere in the tree already , they will still be there , and will be repeated in the output . for c in children : c . set ( ' i d ' , str ( i d ( c ) ) ) # Add to first parent parent_a . extend ( children ) print ' A : ' print prettify ( top ) print # Copy nodes to second parent parent_b . extend ( children ) print ' B : ' print prettify ( top ) print .", "label": "", "metadata": {}}
{"text": "$ python ElementTree_extend_node_copy.py A : B : . tostring ( ) is implemented to write to an in - memory file - like object and then return a string representing the entire element tree .When working with large amounts of data , it will take less memory and make more efficient use of the I / O libraries to write directly to a file handle using the write ( ) method of ElementTree .child_with_tail . write ( sys . stdout ) .The example uses sys.stdout to write to the console , but it could also write to an open file or socket .", "label": "", "metadata": {}}
{"text": "This child has regular text .A nd \" tail \" text .This & that . write ( ) takes a method argument to control the handling for empty nodes . write ( sys .Three methods are supported : . xml . html . text .Prints only the text of nodes , and skips empty tags entirely .$ python ElementTree_write_method.py xml This child contains text .html This child contains text .text This child contains text .System and method for dynamically displaying application shortcut icons of an electronic device US 8151217 B2 .Abstract .", "label": "", "metadata": {}}
{"text": "The method further computes a weight value of each node in the dependency relation graph for ranking the applications to display application shortcut icons of the applications on the electronic device according to the rank .A method for dynamically displaying application shortcut icons of an electronic device , the electronic device comprising a storage device storing applications , the method comprising : .( b ) detecting a currently invoked application , and identifying a browsing path to the currently invoked application , and storing the browsing path into the storage device ; .( c ) accessing an invoked frequency of the currently invoked application from the storage device ; .", "label": "", "metadata": {}}
{"text": "( e ) storing an identifier of the currently invoked application into a queue of the storage device upon the condition that the updated invoked frequency of the currently invoked application is equal to or more than the predetermined frequency value ; .( f ) constructing a first dependency relation graph for the applications whose identifiers are in the queue upon the condition that the count of the browsing path to the currently invoked application is equal to or more than the dependency rule ; .( g ) computing a weight value of each node in the first dependency relation graph using the algorithm : . PR .", "label": "", "metadata": {}}
{"text": "i . )d . )n .d . )I .j .i .E .PR .P .j . )Out . degree .P .j . )d . )n .d . )PR .P .Out . degree .P .PR .P .Out . degree .P .PR .P .j . )Out . degree .P .j . )( h ) ranking the applications of the first dependency relation graph according to the weight values ; and .( i ) displaying application shortcut icons of the applications according to the rank on a display screen of the electronic device .", "label": "", "metadata": {}}
{"text": "claim 1 , wherein the invoked frequency is updated by incrementing a value of the invoked frequency by one .The method as described in .claim 1 , further comprising : . constructing a second dependency relation graph according to the browsing paths which are only from the currently invoked application and whose count are equal to or more than the predetermined frequency value ; and .computing a weight value of each node in the second dependency relation graph .The method as described in .claim 1 , wherein in block ( h ) the applications are ranked in a descending order according to the weight values .", "label": "", "metadata": {}}
{"text": "claim 1 , the electronic device is a mobile phone , a computer , or a personal digital assistant .A storage device medium having stored thereon instructions that , when executed by a processor , causing the processor to perform a method for dynamically displaying application shortcut icons of an electronic device , the electronic device comprising a storage device storing applications , wherein the method comprises : .( b ) detecting a currently invoked application , and identifying a browsing path to the currently invoked application , and storing the browsing path into the storage device ; .", "label": "", "metadata": {}}
{"text": "( d ) updating the invoked frequency , and saving the updated invoked frequency in the storage device ; .( e ) storing an identifier of currently invoked application into a queue of the storage device upon the condition that the updated invoked frequency of the currently invoked application is equal to or more than the predetermined frequency value ; .( f ) constructing a first dependency relation graph for the applications whose identifiers are in the queue upon the condition that the count of the browsing path to the current application is equal to or more than the dependency rule ; .", "label": "", "metadata": {}}
{"text": "P .i . )d . )n .d . )I .j .i .E .PR .P .j . )Out . degree .P .j . )d . )n .d . )PR .P .Out . degree .P .PR .P .Out . degree .P .PR .P .j . )Out . degree .P .j . )( h ) ranking the applications of the first dependency relation graph according to the weight values ; and .", "label": "", "metadata": {}}
{"text": "The storage device medium as described in .claim 6 , wherein the invoked frequency is updated by incrementing a value of the invoked frequency by one .The storage device medium as described in .claim 6 , further comprising : . constructing a second dependency relation graph according to the browsing paths which are only from the currently invoked application and whose count are equal to or more than the predetermined frequency value ; and .computing a weight value of each node in the second dependency relation graph .The storage device medium as described in .", "label": "", "metadata": {}}
{"text": "The storage device medium as described in .claim 6 , wherein the electronic device is a mobile phone , a computer , or a personal digital assistant .A system for dynamically displaying application shortcut icons of an electronic device , the electronic device being installed with applications , the system comprising : . a storage device ; . a detecting module operable to detect a currently invoked application , and identify a browsing path to the currently invoked application , and store the browsing path into the storage device ; . a frequency computing module operable to access an invoked frequency of the currently invoked application from the storage device , update the invoked frequency , and save the updated invoked frequency in the storage device ; . a storing module operable to store an identifier of the currently invoked application into a queue of the storage device , upon the condition that the updated invoked frequency of the currently invoked application equals or is more than the predetermined frequency value ; . a dependency relation graph constructing module operable to construct a first dependency relation graph for the applications whose identifiers are in the queue upon the condition that the count of the browsing path to the current application is equal to or more than the dependency rule ; . a weight value computing module operable to compute a weight value of each node in the first dependency relation graph using the algorithm : . PR .", "label": "", "metadata": {}}
{"text": "i . )d . )n .d . )I .j .i .E .PR .P .j . )Out . degree .P .j . )d . )n .d . )PR .P .Out . degree .P .PR .P .Out . degree .P .PR .P .j . )Out . degree .P .j . ) a ranking module operable to rank the applications of the first dependency relation graph according to the weight values ; and .", "label": "", "metadata": {}}
{"text": "The system as described in .claim 11 , wherein the frequency computing module updates the invoked frequency by incrementing a value of the invoked frequency by one .The system as described in .claim 11 , wherein the dependency relation graph constructing module is further operable to construct a second dependency relation graph according to the browsing paths which are only from the currently invoked application and whose count are equal to or more than the predetermined frequency value .The system as described in . claim 13 , wherein the weight value computing module is further operable to compute a weight value of each node in the second dependency relation graph .", "label": "", "metadata": {}}
{"text": "claim 11 , wherein the ranking module ranks the applications in a descending order according to the weight values .The system as described in .claim 11 , wherein the electronic device is a mobile phone , a computer , or a personal digital assistant .The system as described in .claim 11 , wherein the storage device is a hard disk drive , a compact disk drive , or a floppy disk drive .Description .BACKGROUND .Technical Field .Embodiments of the present disclosure generally relate to systems and methods for tracking and recording data , and more particularly to a system and method for dynamically displaying application shortcut icons of an electronic device by tracking and recording operations on the electronic device .", "label": "", "metadata": {}}
{"text": "A smart phone is a mobile phone offering advanced capabilities .Smart phones may be installed with applications offering different functionalities .Navigation of applications in a smart phone may prove inconvenient and tiring if the smart phone comprises many applications .FIG .1 illustrates an example of a software system tree structure of a smart phone .According to .The above longsome selection and opening brings the user great inconvenience .Conventionally , for overcoming the above disadvantage , two methods are often used .One such method is to preset shortcut keys for the applications of the software system using a keypad of the smart phone .", "label": "", "metadata": {}}
{"text": "However , the above two methods are faulty because it may be difficult for users to remember all the shortcut keys , and a display size of the electronic device limits how many application shortcut icons can be displayed on a display of the electronic device .BRIEF DESCRIPTION OF THE DRAWINGS .FIG .1 illustrates an example of a software system tree structure .FIG .2 is a block diagram of one embodiment of a system for dynamically displaying application shortcut icons of an electronic device .FIG .3 and .FIG .4 respectively illustrates an example of a first dependency relation graph .", "label": "", "metadata": {}}
{"text": "5 illustrates an example of weight values of nodes of the dependency relation graph in .FIG .4 .FIG .6 illustrates an example of a second dependency relation graph .FIG .7 is a flowchart illustrating one embodiment of a method for dynamically displaying application shortcut icons of an electronic device .FIG .8 illustrates an example of an PageRank algorithm .DETAILED DESCRIPTION .The disclosure is illustrated by way of example and not by way of limitation in the figures of the accompanying drawings in which like references indicate similar elements .It should be noted that references to \" an \" or \" one \" embodiment in this disclosure are not necessarily to the same embodiment , and such references mean at least one .", "label": "", "metadata": {}}
{"text": "One or more software instructions in the modules may be embedded in firmware .It will be appreciated that modules may comprised connected logic units , such as gates and flip - flops , and may comprise programmable units , such as programmable gate arrays or processors .The modules described herein may be implemented as either software and/or hardware modules and may be stored in any type of computer - readable medium or other computer storage device .FIG .2 is a block diagram of one embodiment of a tracking system 1 .The tracking system 1 is included in an electronic device 100 .", "label": "", "metadata": {}}
{"text": "It may be understood that , the electronic device 100 is installed with a plurality of applications .In one embodiment , the electronic device 100 may be a mobile phone , a computer , a personal digital assistant ( PDA ) , for example .At least one processor 3 , a storage device 4 , and a display screen 5 , in the electronic device 100 , are in data communication with the tracking system 1 via one or more standards - based bus system .The processor 3 may be used to execute one or more computerized codes of the modules 10 - 18 , to dynamically display application shortcut icons of the applications that are frequently used .", "label": "", "metadata": {}}
{"text": "In one embodiment , the storage device 4 may comprise one or more hard disk drives , optical drive , networked drive , or some combination of various digital storage systems .The display screen 5 may be used to display a plurality of application shortcut icons of the electronic device 100 .The parameter receiving module 10 is operable to receive a predetermined frequency value and a dependency rule .In one embodiment , the frequency value and the dependency rule may be inputted by a user .The frequency value is a count that how many times an application has been invoked within a predetermined time interval .", "label": "", "metadata": {}}
{"text": "If a count that an application has been executed in the predetermined time interval is equal to or more than the predetermined frequency value , the application is considered as a frequently used application of the user .The dependency rule is a count of a taken browsing path to an application .Referring to .FIG .1 , in one example , if after using the application \" App 1 , \" the user returns to \" Boot directory , \" then selects the sub - directory \" Dir 2 \" to use the application \" App 6 . \" In this example , a taken browsing path to the application \" App 6 \" is from \" App 1 .", "label": "", "metadata": {}}
{"text": "The detecting module 11 is operable to detect an application currently invoked by the electronic device 100 , identify a browsing path to the currently invoked application , and store the browsing path into the storage device 4 .The frequency computing module 12 is operable to access an invoked frequency of the currently invoked application from the storage device 4 , update the invoked frequency , and save the updated invoked frequency in the storage device 4 .In one embodiment , the invoked frequency of an application is incremented by 1 after every time the application is invoked .", "label": "", "metadata": {}}
{"text": "The determining module 13 is further operable to determine whether the count of the browsing path to the currently invoked application is equal to or more than the dependency rule for tracking operations on the electronic device 100 .The storing module 14 is operable to store an identifier of the currently invoked application into a queue of the storage device 4 , if the updated invoked frequency of the currently invoked application is equal to or more than the predetermined frequency value .In one embodiment , the queue stores identifiers of all the applications frequently used by the user .", "label": "", "metadata": {}}
{"text": "It may be understood that , the dependency relation graph can be used to track operations on the electronic device 100 .In one embodiment , the first dependency relation graph includes all the applications whose identifiers are in the queue .FIG .3 and .FIG .4 illustrate two examples of a constructed first dependency relation graph .In one embodiment , there are six browsing paths stored in the storage device 4 equal to or more than the dependency rule .Thus , it can be seen that , in .FIG .3 and .", "label": "", "metadata": {}}
{"text": "Thus , a node \" App 3 \" is placed in the first dependency relation graphs of .FIG .3 and .FIG .4 , but is not connected to any node .In addition , the dependency relation graph constructing module 15 is also operable to construct a second dependency relation graph for the currently invoked application .In one embodiment , the second dependency relation graph only shows the browsing paths which are from the currently invoked application and whose counts are equal to or more than the dependency rule .Assuming that \" App 4 \" is the currently invoked application , .", "label": "", "metadata": {}}
{"text": "6 is an example illustrating a constructed second dependency relation graph for the currently invoked application \" App 4 . \" The weight value computing module 16 is operable to compute a weight value of each node in the first or second dependency relation graph .FIG .5 illustrates an example of weight values of nodes of the first dependency relation graph in .FIG .4 .It may be understood that , a sum of the weight values is 1 .In one embodiment , the weight value computing module 16 computes a weight value PR(P i ) of a node P i using the PageRank algorithm .", "label": "", "metadata": {}}
{"text": "FIG . 8 .In the formula illustrated in .FIG .8 , \" P 1 \" , \" P 2 \" , \" P j \" arc nodes connected to the node P i .For example , in .FIG .4 , \" App 1 \" \" App 4 \" and \" App 2 \" are nodes connected to the node \" Boot directory .\" PR(p j ) means a weight value of the node \" P j \" . \"Outdegree(P j ) \" indicates a count of nodes that the node \" P j \" is connected to .", "label": "", "metadata": {}}
{"text": "FIG .4 , the node \" App 4 \" is connected to the \" App 1 \" and \" Boot directory , \" thus , a count of nodes , which the node \" App 4 \" is connected to , is 2 . \" d \" is a probability value , which may be 0.15 for example . \" n \" is a count of nodes in the first dependency relation graph .In .FIG .4 , for example , n is 5 .The ranking module 17 is operable to rank applications of the first or second dependency relation graph according to the weight values .", "label": "", "metadata": {}}
{"text": "The displaying module 18 is operable to display application shortcut icons of the applications according to the rank on the display screen 5 of the electronic device 100 .FIG .7 is a flowchart illustrating one embodiment of a method for dynamically displaying application shortcut icons of the electronic device 100 .Depending on the embodiment , additional blocks in the flow of .FIG .7 may be added , others removed , and the ordering of the blocks may be changed .In block S 10 , the parameter receiving module 10 receives a predetermined frequency value and a dependency rule .", "label": "", "metadata": {}}
{"text": "As mentioned above , the frequency value is a count that how many times an application has been invoked within a predetermined time interval .The dependency rule is a count of a browsing path to an application taken .In block S 11 , the detecting module 11 detects an application currently invoked by the electronic device 100 , identifies a browsing path to the currently invoked application , and stores the browsing path into the storage device 4 .In block S 12 , the frequency computing module 12 access an invoked frequency of the currently invoked application from the storage device 4 .", "label": "", "metadata": {}}
{"text": "In one embodiment , the frequency computing module 12 updates an invoked frequency of an application by increasing 1 after every time the application is invoked .In block S 14 , the determining module 13 determines whether the updated invoked frequency of the currently invoked application is equal to or more than the predetermined frequency value .The flow goes to block S 15 if the updated invoked frequency is equal to or more than the predetermined frequency value .Otherwise , the flow ends if the updated invoked frequency is less than the predetermined frequency value .In block S 15 , the storing module 14 stores an identifier of the currently invoked application into a queue of the storage device 4 .", "label": "", "metadata": {}}
{"text": "In block S 16 , the determining module 13 further determines whether the count of the browsing path to the currently invoked application equal to or more than the dependency rule .The flow goes to block S 17 , if the count of the browsing path to the current application is equal to or more than the dependency rule .Otherwise , the flow ends , if the count of the browsing path to the current application is less than the dependency rule .In block S 17 , the dependency relation graph constructing module 15 constructs a first dependency relation graph for the applications whose identifiers are in the queue .", "label": "", "metadata": {}}
{"text": "In block S 18 , the weight value computing module 16 computes a weight value of each node in the first dependency relation graph .As mentioned above , in one embodiment , the weight value computing module 16 computes the weight value using the PageRank algorithm .In block S 19 , the dependency relation graph constructing module 15 determines whether to construct a second dependency relation graph for the currently invoked application .In an embodiment , the determination of whether to construct a second dependency relation graph is made by the user .The second dependency relation graph is a figurative expression of the browsing paths which are only from the currently invoked application .", "label": "", "metadata": {}}
{"text": "Otherwise , if not constructing a second dependency relation graph , the flow goes to block S 21 described below .In block S 20 , the dependency relation graph constructing module 15 further constructs a second dependency relation graph for the currently invoked application , and the weight value computing module 16 computes a weight value of each node in the second dependency relation graph .In block S 21 , the ranking module 17 ranks applications of the first or second dependency relation graph according to the weight values .In one embodiment , the applications are ranked in a descending order according to the weight values .", "label": "", "metadata": {}}
{"text": "Although certain inventive embodiments of the present disclosure have been specifically described , the present disclosure is not to be construed as being limited thereto .Various changes or modifications may be made to the present disclosure without departing from the scope and spirit of the present disclosure .XForms is an XML application that represents the next generation of forms for the Web .By splitting traditional XHTML forms into three parts - XForms model , instance data , and user interface - it separates presentation from content , allows reuse , gives strong typing - reducing the number of round - trips to the server , as well as offering device independence and a reduced need for scripting .", "label": "", "metadata": {}}
{"text": "Status of this Document .This section describes the status of this document at the time of its publication .Other documents may supersede this document .This document has been reviewed by W3C Members , by software developers , and by other W3C groups and interested parties , and is endorsed by the Director as a W3C Recommendation .It is a stable document and may be used as reference material or cited from another document .W3C 's role in making the Recommendation is to draw attention to the specification and to promote its widespread deployment .This enhances the functionality and interoperability of the Web .", "label": "", "metadata": {}}
{"text": "Web applications and electronic commerce solutions have sparked the demand for better Web forms with richer interactions .XForms 1.0 is the response to this demand , and provides a new platform - independent markup language for online interaction between a person ( through an XForms Processor ) and another , usually remote , agent .XForms are the successor to HTML forms , and benefit from the lessons learned from HTML forms .This specification has been written with various types of readers in mind - in particular XForms authors and XForms implementors .We hope the specification will provide authors with the tools they need to write efficient , attractive and accessible documents without overexposing them to the XForms implementation details .", "label": "", "metadata": {}}
{"text": "Processors .The specification begins with a general presentation of XForms before specifying the technical details of the various XForms components .The specification has been written with various modes of presentation in mind .In case of a discrepancy , the online electronic version is considered the authoritative version of the document .This document uses the terms optional , required , recommended , may , must , and should in accord with [ RFC 2119 ] . 1.3 How the Specification is Organized .The specification is organized into the following chapters : .Chapters 1 and 2 .", "label": "", "metadata": {}}
{"text": "The introduction outlines the design principles and includes a brief tutorial on XForms .Chapters 3 and up .XForms reference manual .The bulk of the reference manual consists of the specification of XForms .This reference defines XForms and how XFormsProcessors must interpret the various components in order to claim conformance .Appendixes .Appendixes contain a normative description of XForms described in XML Schema , information on references , and other useful information . 1.4 Documentation Conventions .Throughout this document , the following namespace prefixes and corresponding namespace identifiers are used : .This is only a convention ; any namespace prefix may be used in practice .", "label": "", "metadata": {}}
{"text": "Official terms are defined in the following manner : [ Definition : You can find most terms in chapter 13 Glossary Of Terms ] .Links to term s may be specially highlighted where necessary .The XML representations of various elements within XForms are presented using the syntax for Abstract Modules in XHTML Modularization [ XHTML Modularization ] .Examples are set off typographically : .Example item .Example Item .References to external documents appear as follows : [ Sample Reference ] with links to the references section of this document .Sample Reference .Reference - linked to from above .", "label": "", "metadata": {}}
{"text": "Note : .A gentle explanation or admonition to readers .2 Introduction to XForms .XForms has been designed on the basis of several years ' experience with HTML forms .HTML Forms have formed the backbone of the e - commerce revolution , and having shown their worth , have also indicated numerous ways they could be improved .The primary difference when comparing XForms with HTML Forms , apart from XForms being in XML , is the separation of the data being collected from the markup of the controls collecting the individual values .By doing this , it not only makes XForms more tractable by making it clear what is being submitted where , it also eases reuse of forms , since the underlying essential part of a Form is no longer irretrievably bound to the page it is used in .", "label": "", "metadata": {}}
{"text": "XForms has striven to improve authoring , reuse , internationalization , accessibility , usability , and device independence .Here is a summary of the primary benefits of using XForms : .Strong typing .Submitted data is strongly typed and can be checked using off - the - shelf tools .This speeds up form filling since it reduces the need for round trips to the server for validation .XML submission .This obviates the need for custom server - side logic to marshal the submitted data to the application back - end .The received XML instance document can be directly validated and processed by the application back - end .", "label": "", "metadata": {}}
{"text": "This obviates duplication , and ensures that updating the validation rules as a result of a change in the underlying business logic does not require re - authoring validation constraints within the XForms application .External schema augmentation .This enables the XForms author to go beyond the basic set of constraints available from the back - end .Providing such additional constraints as part of the XFormsModel enhances the overall usability of the resulting Web application .Internationalization .Using XML 1.0 for instance data ensures that the submitted data is internationalization ready .Enhanced accessibility .XForms separates content and presentation .", "label": "", "metadata": {}}
{"text": "XForms user interface controls are generic and suited for device - independence .Multiple device support .The high - level nature of the user interface controls , and the consequent intent - based authoring of the user interface makes it possible to re - target the user interaction to different devices .Less use of scripting .By defining XML - based declarative event handlers that cover common use cases , the majority of XForms documents can be statically analyzed , reducing the need for imperative scripts for event handlers .2.1 An Example .In the XForms approach , forms are comprised of a section that describes what the form does , called the XForms Model , and another section that describes how the form is to be presented .", "label": "", "metadata": {}}
{"text": "It is clear that we are collecting a value that represents whether cash or credit card is being used , and if a credit card , its number and expiration date .This can be represented in the XForms model element , which in XHTML would typically be contained within the head section : .This simply says that we are collecting three pieces of information ( note that we have as yet not said anything about their types ) , and that they will be submitted using the URL in the action attribute .XForms 1.0 defines a device - neutral , platform - independent set of form controls suitable for general - purpose use .", "label": "", "metadata": {}}
{"text": "Model via the XForms binding mechanism , in this simple case using the ref attribute on the controls .In XHTML , this markup would typically appear within the body section ( note that we have intentionally defaulted the XForms namespace prefix here ) : .Select Payment Method : Cash cash Credit cc Credit Card Number : Expiration Date : Submit .Notice the following features of this design : .The user interface is not hard - coded to use radio buttons .Different devices ( such as voice browsers ) can render the concept of \" select one \" as appropriate .", "label": "", "metadata": {}}
{"text": "There is no need for an enclosing form element , as in HTML .( See 2.4 Multiple Forms per Document for details on how to author multiple forms per document ) .Markup for specifying form controls has been simplified in comparison with HTML forms .The fact that you can bind form controls to the model like this simplifies integrating XForms into other host languages , since any form control markup may be used to bind to the model . 2.2 Providing XML Instance Data .The XFormsProcessor can directly submit the data collected as XML .", "label": "", "metadata": {}}
{"text": "Submitted Data .cc 1235467789012345 2001 - 08 .XForms processing keeps track of the state of the partially filled form through this instance data .Initial values for the instance data may be provided or left empty as in the example .Element instance essentially holds a skeleton XML document that gets updated as the user fills out the form .It gives the author full control on the structure of the submitted XML data , including namespace information .When the form is submitted , the instance data is serialized as an XML document .Here is an alternative version of the earlier example : .", "label": "", "metadata": {}}
{"text": "In this case the submitted data would look like this : .Submitted Data .This design has features worth calling out : .There is complete flexibility in the structure of the XML instance data , including the use of attributes .Notice that XML namespaces are used , and that a wrapper element of the author 's choosing contains the instance data .Empty elements number and expiry serve as place - holders in the XML structure , and will be filled in with form data provided by the user .An initial value ( \" cc \" ) for the form control is provided through the instance data , in this case an attribute method .", "label": "", "metadata": {}}
{"text": "To connect this instance data with form controls , the ref attributes on the form controls need to be changed to point to the proper part of the instance data , using binding expressions : .Binding Form Controls to Instance Nodes with ref .Binding expressions are based on XPath [ XPath 1.0 ] , including the use of the @ character to refer to attributes , as seen here .Note that for illustrative purposes , the first two expressions make use of the XPath context node , which defaults to the top - level element ( here my : payment ) .", "label": "", "metadata": {}}
{"text": "Constraining Values .XForms allows data to be checked for validity as the form is being filled .In the absence of specific information about the types of values being collected , all values are returned as strings , but it is possible to assign types to values in the instance data .In this example , number should accept digits only , and should have between 14 and 18 digits and expiry should accept only valid month / date combinations .Furthermore , the credit card information form controls for number and expiry are only relevant if the \" cc \" option is chosen for method , but are required in that case .", "label": "", "metadata": {}}
{"text": "Such information can be taken from XML Schemas as well as XForms - specific additions , such as relevant .Such properties appear on bind elements , while Schema constraint s are expressed in an XML Schema fragment , either inline or external .For example : .Declarative Validation with Model Item Properties .Note : . 2.4Multiple Forms per Document .XForms processing places no limits on the number of individual forms that can be placed in a single containing document .When a single document contains multiple forms , each form needs a separate model element , each with an i d attribute so that they can be referenced from elsewhere in the containing document .", "label": "", "metadata": {}}
{"text": "This is accomplished through a model attribute that is part of the binding attributes .If no model attribute is specified on the binding element , the nearest ancestor binding element 's model attribute is used , and failing that , the first XForms Model in document order is used .This technique is called ' scoped resolution ' , and is used frequently in XForms .The next example adds an opinion poll to our electronic commerce form .Adding a poll model . ... payment instance data ... .Additionally , the following markup would appear in the body section of the document : .", "label": "", "metadata": {}}
{"text": "How useful is this page to you ?Not at all helpful 0 Barely helpful 1 Somewhat helpful 2 Very helpful 3 Submit .Note that submit refers to the submission element by ID and does not require binding attributes .XForms 1.0 is an application of XML [ XML 1.0 ] and has been designed for use within other XML vocabularies - in particular within a future version of XHTML [ XHTML 1.0 ] .XForms always requires such a host language .This chapter discusses the structure of XForms that allow XForms to be used with other document types .", "label": "", "metadata": {}}
{"text": "XFormsProcessors must use the XML namespaces mechanism [ XML Names ] to recognize elements and attributes from this namespace .3.2 XForms Core Attribute Collections .3.2.1 Common Attributes .The Common Attribute Collection applies to every element in the XForms namespace .i d .The optional i d attribute of type xsd : ID assigns an identity to the containing element .anyAttribute .Foreign attributes are allowed on all XForms elements .3.2.2 Linking Attributes .The Linking Attributes Collection applies to XForms elements which include a link to a remote resource . src .The src attribute assigns a URI to be automatically retrieved .", "label": "", "metadata": {}}
{"text": "Since linking attribute URIs are defined in terms of the XML Schema datatype xsd : anyURI , the same internationalization benefits and white space cautions apply as discussed in [ XML Schema part 2 ] .Behavior of relative URIs in links is determined by the host language , although [ XML Base ] processing is strongly recommended .Note : .The Forms Working Group is tracking with the HTML Working Group on a method of describing link structures .3.2.3 Single - Node Binding Attributes .The following attributes define a binding between an XForms element such as a form control or an action and an instance data node defined by an XPath expression .", "label": "", "metadata": {}}
{"text": "Binding expression interpreted as XPath .This attribute has no meaning when a bind attribute is present . model .Optional XFormsModel selector .Specifies the ID of an XForms Model to be associated with this binding element .This attribute has no meaning for the current binding element when a bind attribute is present .Rules for determining the context XFormsModel are located at 7.4 Evaluation Context . bind .Reference to a bind element .In this specification , when an XForms element is declared to have a Single - Node Binding , then the Single - Node Binding is required unless the element explicitly states that it is optional .", "label": "", "metadata": {}}
{"text": "When bind is used , the node is determined by the referenced bind .See 4.7.2 References to Elements within a bind Element for details on selecting an identified bind that is iterated by one or more containing bind elements .It is an exception ( 4.5.1 The xforms - binding - exception Event ) if the XFormsProcessor encounters a model IDREF value that refers to an ID not on a model element , or a bind IDREF value that refers to an ID not on a bind element .3.2.4 Node - Set Binding Attributes .The following attributes define a binding between an XForms element such as a form control or an action and a node - set defined by the XPath expression . nodeset .", "label": "", "metadata": {}}
{"text": "This attribute has no meaning when a bind attribute is present . model .Optional XFormsModel selector .Specifies the ID of an XForms Model to be associated with this binding element .This attribute has no meaning for the current binding element when a bind attribute is present .Rules for determining the context XFormsModel are located at 7.4 Evaluation Context . bind .Reference to a bind element .In this specification , when an XForms element is declared to have a Node - Set Binding , then the Node - Set Binding is required unless the element explicitly states that it is optional .", "label": "", "metadata": {}}
{"text": "When bind is used , the node - set is determined by the referenced bind .See 4.7.2 References to Elements within a bind Element for details on selecting an identified bind that is iterated by one or more containing bind elements .It is an exception ( 4.5.1 The xforms - binding - exception Event ) if the XFormsProcessor encounters a model IDREF value that refers to an i d not on a model element , or a bind IDREF value that refers to an i d not on a bind element .3.2.5 Model Item Property Attributes .", "label": "", "metadata": {}}
{"text": "The XForms Core Module .The XForms Core Module defines the major structural elements of XForms , intended for inclusion in a containing document .The elements and attributes included in this module are : .Elements defined in the XFormsActions module , when that module is included , are also allowed in the content model of model and submission , as shown above .Within the containing document , these structural elements are typically not rendered .The XFormsProcessor must ignore any foreign - namespaced attributes that are unrecognized , and must process unrecognized foreign - namespaced elements according to the 3.4 The XForms MustUnderstand Module rules .", "label": "", "metadata": {}}
{"text": "3.3.1 The model Element .This element represents a form definition and is used as a container for elements that define the XForms Model .No restriction is placed on how many model elements may exist within a containing document .Attributes from XML Events are allowed on this element to facilitate creating observers .This element is not an XFormsAction , and has no predefined behavior event - based behavior .Special Attributes : .Optional space - separated list of XPath extension functions ( represented by QNames ) required by this XForms Model .Guidance on the use of this attribute is at 7.12 Extension Functions . schema .", "label": "", "metadata": {}}
{"text": "The XFormsProcessor must process all Schemas listed in this attribute .Within each XForms Model , there is a limit of one Schema per namespace declaration , including inline and linked Schemas .Note : .The schema list may include URI fragments referring to elements located elsewhere in the containing document ; e.g. \" # myschema \" .version .Optional attribute with a default value of empty string and legal values defined by the datatype xforms : versionList .Examples are \" 1.0 \" and \" 1.0 1.1 \" .If one or more versions are indicated by this attribute on the default model , then an XForms", "label": "", "metadata": {}}
{"text": "Otherwise , the XFormsProcessor must terminate processing after dispatching the event xforms - version - exception to the default model .If any non - default model has a version setting that is incompatible with the language version selected by the XFormsProcessor , or if any model contains an illegal version attribute value , then the XFormsProcessor must terminate processing after dispatching the event xforms - version - exception to the default model .The version attribute is optional to implement , but future versions of XForms are expected to support it , so implementation support is strongly encouraged .", "label": "", "metadata": {}}
{"text": "Model .If the initial instance data is given by a link , then the instance data is formed by creating an XPath data model of the linked resource .If the initial instance data is given by inline content , then instance data is obtained by first creating a detached copy of the inline content ( including namespaces inherited from the enveloping ancestors ) , then creating an XPath data model over the detached copy .The detached copy must consist of content that would be well - formed XML if it existed in a separate document .Note that this restricts the element content of instance to a single child element .", "label": "", "metadata": {}}
{"text": "This could happen , for example , if the inline content had two element nodes , which would imply creating an XML document with two document elements .Note : .All data relevant to the XPath data model must be preserved during processing and submission , including processing instructions , comment nodes and all whitespace .Note : .XForms authors who need additional control over the serialization of namespace nodes can use the includenamespaceprefixes attribute on the submission element .3.3.3 The submission Element .This element represents declarative instructions on what to submit , and how .", "label": "", "metadata": {}}
{"text": "Optional reference to a bind element .When present , the binding reference on this attribute is used in preference to any binding reference from the ref attribute . ref .Optional selector binding expression enabling submission of a portion of the instance data .The selected node , and all descendants , are selected for submission .The default value is \" / \" . action .Optional attribute indicating the destination URI for submitting instance data .Behavior of relative URIs in links is determined by the host language , although [ XML Base ] processing is strongly recommended .", "label": "", "metadata": {}}
{"text": "Required attribute specifying the protocol to be used to transmit the serialized instance data .There is no default value . version .Optional attribute specifying the version of XML to be serialized . indent .Optional attribute specifying whether the serializer should add extra white space nodes for readability . mediatype .Optional attribute specifying the mediatype for XML instance serialization .Authors should ensure that the type specified is compatible with application / xml . encoding .Optional attribute specifying an encoding for serialization .omit - xml - declaration .Optional attribute specifying whether to omit the XML declaration on the serialized instance data . standalone .", "label": "", "metadata": {}}
{"text": "cdata - section - elements .Optional attribute specifying element names to be serialized with CDATA sections . replace .Optional attribute specifying how the information returned after submit should be applied .In the absence of this attribute , \" all \" is assumed . instance .Optional attribute specifying the instance to replace when the replace attribute value is \" instance \" .When the attribute is absent , then the default is the instance that contains the submission data .An xforms - binding - exception ( 4.5.1 The xforms - binding - exception Event ) occurs if this attribute does not indicate an instance in the same model as the submission . separator .", "label": "", "metadata": {}}
{"text": "The default value is ' ; ' .includenamespaceprefixes .Optional attribute providing control over namespace serialization .If absent , all namespace nodes present in the instance data are considered for serialization .If present , specifies list of namespace prefixes to consider for serialization , in addition to those visibly utilized .As in [ Exc - C14N ] , the special value # default specifies the default namespace .The following examples show how various options on element submission can affect serialization as application / xml .Given the following XForms fragment : . my : sample .", "label": "", "metadata": {}}
{"text": "In particular , note that the XForms namespace has been serialized .When this attribute is present , the author takes responsibility to list all namespace prefixes not visibly utilized by the submitted instance data .version indent encoding omit - xml - declaration cdata - section - elements .Note : .The following XSLT attributes have no counterpart in XForms : . doctype - system doctype - public .Elements defined in the XFormsActions module , when that module is included , are also allowed in the content model of submission .3.3.4 The bind Element .", "label": "", "metadata": {}}
{"text": "Other attributes on element bind encode model item properties to be applied to each node in the node - set .When bind has an attribute of type xsd : ID , the bind then associates that identifier with the selected node - set .An optional attribute containing a model binding expression that selects the set of nodes on which this bind operates .See 7.4 Evaluation Context for details on how the evaluation context is determined for each attribute of the bind element . . .3.4 The XForms MustUnderstand Module .Certain elements , such as extension or foreign namespaced elements defined in a host language might be critical to the operation of a particular form .", "label": "", "metadata": {}}
{"text": "Element .Attributes .Minimal Content Model .ANY .xforms : mustUnderstand ( xsd : boolean ) .n / a .3.5 The XForms Extension Module .There are many different ways a host language might include XForms .One approach uses only well - formed processing , disregarding validation .Another case uses strict validation , for example XHTML 1.0 , in which only predefined elements are allowed .Another common approach is to allow unregulated content in a few selected places .A host language that chooses this option can use the Extension module .Optional element extension is a container for application - specific extension elements from any namespace other than the XForms namespace .", "label": "", "metadata": {}}
{"text": "For example , RDF metadata could be attached to an individual form control as follows : .Enter your email address personal .4 Processing Model .This chapter defines the XFormsProcessing Model declaratively by enumerating the various states attained by an XForms Processor and the possible state transitions that exist in each of these states .The chapter enumerates the pre - conditions and post - conditions that must be satisfied in each of these states .XFormsProcessors may be implemented in any manner , so long as the end results are identical to that described in this chapter .", "label": "", "metadata": {}}
{"text": "The XFormsProcessing Model consists of events in the following categories : .Initialization .Interaction .Notification .Error Conditions .4.1 Events Overview .XForms processing is defined in terms of events , event handlers , and event responses .XForms uses the events system defined in [ DOM2 Events ] [ XML Events ] , with an event capture phase , arrival of the event at its Target , and finally the event bubbling phase .Throughout this chapter , each reference to \" form control \" as a target element is a shorthand for any of the following elements : input , secret , textarea , output , upload , trigger , range , submit , select , select1 , or group .", "label": "", "metadata": {}}
{"text": "The processor begins initialization by dispatching an event xforms - model - construct to each XForms Model in the containing document .How the XFormsProcessor itself is requested to initialize is implementation dependent .If an external source for the initial instance data is given , an XPath data model [ 7 XPath Expressions in XForms ] is constructed from it ; otherwise if inline initial instance data is given , that is used instead .If the external initial instance data is not well - formed XML or can not be retrieved , processing halts with an exception ( 4.5.2 The xforms - link - exception Event ) .", "label": "", "metadata": {}}
{"text": "The xforms - model - construct - done Event ) .Perform the behaviors of xforms - rebuild , xforms - recalculate , and xforms - revalidate in sequence on this model element without dispatching events to invoke the behaviors .The notification event markings for these operations are discarded , and the xforms - refresh behavior is not performed since the user interface has not yet been initialized .After all XFormsModels have been initialized , an xforms - model - construct - done event is dispatched to each model element .4.2.2The xforms - model - construct - done Event .", "label": "", "metadata": {}}
{"text": "Target : model .Bubbles : Yes .Cancelable : No .Context Info : None .The default action for this event happens once , no matter how many XForms Models are present in the containing document , and results in the following , for each form control : .Processing can proceed in one of two different ways depending on whether an instance in a model exists when the first form control is processed .If the instance referenced on the form control existed when the first form control was processed : .The binding expression is evaluated to ensure that it points to a node that exists .", "label": "", "metadata": {}}
{"text": "If the instance referenced on the form control did not exist when the first form control for the same instance was processed : .For the first reference to an instance a default instance is created by following the rules described below .A root instanceData element is created .An instance data element node will be created using the binding expression from the user interface control as the name .If the name is not a valid QName , processing halts with an exception ( 4.5.1 The xforms - binding - exception Event ) .For the second and subsequent references to an instance which was automatically created the following processing is performed : .", "label": "", "metadata": {}}
{"text": "If a matching instance data node is not found , an instance data node will be created using the binding expression from the user interface control as the name .If the name is not a valid QName , processing halts with an exception ( 4.5.1 The xforms - binding - exception Event ) .The above steps comprise the default processing of xforms - model - construct - done .After all form controls have been initialized and all xforms - model - construct - done events have been processed , an xforms - ready event is dispatched to each model element .", "label": "", "metadata": {}}
{"text": "Dispatched as part of xforms - model - construct - done processing .Target : model .Bubbles : Yes .Cancelable : No .Context Info : None .The default action for this event results in the following : None ; notification event only .4.2.4 The xforms - model - destruct Event .Dispatched by the processor to advise of imminent shutdown of the XFormsProcessor , which can occur from user action , or from the load XFormsAction , or as a result of form submission .Target : model .Bubbles : No .", "label": "", "metadata": {}}
{"text": "Context Info : None .The default action for this event results in the following : None ; notification event only .4.3 Interaction Events .4.3.1 The xforms - next and xforms - previous Events .Dispatched in response to : user request to navigate to the next or previous form control .Target : form control .Bubbles : No .Cancelable : Yes .Context Info : None .The default action for these events results in the following : Navigation according to the default navigation order .For example , on a keyboard interface , \" tab \" might generate an xforms - next event , while \" shift+tab \" might generate an xforms - previous event .", "label": "", "metadata": {}}
{"text": "The host language is responsible for defining overall navigation order .The navigation sequence is determined as follows : .Form controls that have a navindex specified and assign a positive value to it are navigated first .Outermost form controls are navigated in increasing order of the navindex value .Values need not be sequential nor must they begin with any particular value .Form controls that have identical navindex values are to be navigated in document order .All form controls within a local sequence are navigated , in increasing order of the navindex value , before any outside the local sequence are navigated .", "label": "", "metadata": {}}
{"text": "Those form controls that do not specify navindex or supply a value of \" 0 \" are navigated next .These form controls are navigated in document order .Those form controls that are disabled , hidden , or not relevant are assigned a relative order in the overall sequence but do not participate as navigable controls .The navigation sequence past the last form control ( or before the first ) is undefined .XFormsProcessors may cycle back to the first / last control , remove focus from the form , or other possibilities .4.3.2 The xforms - focus Event .", "label": "", "metadata": {}}
{"text": "Target : form control .Bubbles : No .Cancelable : Yes .Context Info : None .The default action for these events results in the following : .Focus is given to the target form control if the form control is able to accept focus .Setting focus to a repeating structure sets the focus to the repeat item represented by the repeat index .4.3.3 The xforms - help and xforms - hint Events .Dispatched in response to : a user request for help or hint information .Target : form control .Bubbles : Yes .", "label": "", "metadata": {}}
{"text": "Context Info : None .The default action for these events results in the following : If the form control has help / hint elements supplied , these are used to construct a message that is displayed to the user .Otherwise , user agents may provide default help or hint messages , but are not required to .4.3.4 The xforms - refresh Event .Dispatched in response to : a request to update all form controls associated with a particular XForms Model .Target : model .Bubbles : Yes .Cancelable : Yes .Context Info : None .", "label": "", "metadata": {}}
{"text": "All UI bindings should be reevaluated as necessary .A node can be changed by confirmed user input to a form control , by xforms - recalculate ( section 4.3.6 ) or by the setvalue ( section 10.1.9 ) action .If the value of an instance data node was changed , then the node must be marked for dispatching the xforms - value - changed event .If the xforms - value - changed event is marked for dispatching , then all of the appropriate model item property notification events must also be marked for dispatching ( xforms - optional or xforms - required , xforms - readwrite or xforms - readonly , and xforms - enabled or xforms - disabled ) .", "label": "", "metadata": {}}
{"text": "The notification events xforms - out - of - range or xforms - in - range must also be dispatched as appropriate .This specification does not specify an ordering for the events .The user interface reflects the state of the model , which means that all forms controls reflect for their corresponding bound instance data : . its current value . its validity .whether it is required , readonly or relevant .4.3.5 The xforms - revalidate Event .Dispatched in response to : a request to revalidate a particular XForms Model .Target : model .", "label": "", "metadata": {}}
{"text": "Cancelable : Yes .Context Info : None .An instance node is valid if and only if the following conditions hold : . the constraint model item property is true .the node satisfies all applicable XML schema definitions ( including those associated by the type model item property , by an external or an inline schema , or by xsi : type ) .Note : .A node that satifies the above conditions is valid even if it is required but empty .The default action for this event results in the following : .All instance data nodes in all instance elements in the model are checked for validity according to the above definition .", "label": "", "metadata": {}}
{"text": "Marking one of these events for dispatch unmarks the other .4.3.6 The xforms - recalculate Event .Dispatched in response to : a request to recalculate all calculations associated with a particular XForms Model .Target : model .Bubbles : Yes .Cancelable : Yes .Context Info : None .The default action for this event results in the following : .The values of all instance data items match their associated ' calculate ' constraints , if any .All model item properties that can contain computed expressions are resolved .In addition to contributing further node value changes that will cause xforms - value - changed notifications in xforms - refresh , the model item properties that change are marked to help xforms - refresh to determine the notification events to dispatch .", "label": "", "metadata": {}}
{"text": "Marking one of these events for dispatch unmarks the other .If the readonly model item property changes , then either the xforms - readonly event must be marked for dispatch if readonly is true or the xforms - readwrite event must be marked for dispatch if readonly is false .Marking one of these events for dispatch unmarks the other .If the relevant model item property changes , then either the xforms - enabled event must be marked for dispatch if relevant is true or the xforms - disabled event must be marked for dispatch if relevant is false .", "label": "", "metadata": {}}
{"text": "An XPath expression is bound either to the value or to a model item property ( e.g. , required , relevant ) of one or more instance nodes .The combination of an XPath expression with a single instance node 's value or model item property is considered as a single computational unit , a compute , for the purposes of recalculation .When it is time to recalculate a model item property , the XPath expression is evaluated .The evaluation context is determined from the model binding expression that applied the model item property , as defined for computed expressions in 7.4 Evaluation Context .", "label": "", "metadata": {}}
{"text": "Each referenced instance node has as dependents those computes which directly refer to the instance node .References to the current node 's value in calculate expressions are explicitly ignored , i.e. , if an expression associated with a compute refers to the instance node associated with the compute , then the instance node does not take itself as a dependent .A compute is computationally dependent on an instance node ( whose value may or may not be computed ) if there is a path of dependents leading from the instance node through zero or more other instance nodes to the compute .", "label": "", "metadata": {}}
{"text": "Note : .Authors should not refer to the current node 's value in calculate expressions because the effect is not well - defined .Other model item properties , such as required or readonly , however , are well - defined in the presence of self - references .When a recalculation event begins , there will be a list L of one or more instance nodes whose values may have been changed , e.g. , by user input being propagated to the instance .An XFormsProcessor must recalculate computes for nodes in L and nodes that are computationally dependent on nodes in L .", "label": "", "metadata": {}}
{"text": "Processor must perform only a single recalculation of each compute that is computationally dependent on one or more of the elements in L .An XFormsProcessor must recalculate a compute C after recalculating all computes of instance nodes on which C is computationally dependent .( Equivalently , an XFormsProcessor must recalculate a compute C before recalculating any compute that is computationally dependent on the instance node associated with C . )Finally , if a compute is part of a circular dependency and also computationally dependent on an element in L , then an XForms processor must report an exception ( 4.5.4 The xforms - compute - exception Event ) .", "label": "", "metadata": {}}
{"text": "Target : model .All model item properties are initialized by processing all bind elements in document order .For each bind : .If the attribute nodeset is attached to the bind , it is evaluated to select an XPath node - set .Otherwise , if the bind does not have a nodeset attribute , then the selected XPath node - set consists of the in - scope evaluation context .For each node in the selected XPath node - set , model item properties are applied according to the remaining attributes on the bind element ( for details on the model item properties , see 6 Model Item Properties ) .", "label": "", "metadata": {}}
{"text": "For each node in the selected XPath node - set , any child bind elements are recursively processed as described in the three points of this list .4.3.8 The xforms - reset Event .Dispatched in response to : a user request to reset the model .Target : model .Bubbles : Yes .Cancelable : Yes .Context Info : None .The default action for this event results in the following : .The instance data is reset to the tree structure and values it had immediately after having processed the xforms - ready event .", "label": "", "metadata": {}}
{"text": "The default action for this event results in the following : None ; notification event only .4.4.2 The xforms - value - changed Event .Dispatched in response to : a change to an instance data node bound to a form control .Target : form control .The default action for this event results in the following : None ; notification event only .This event is dispatched during 4.3.4 The xforms - refresh Event if the bound instance data node has been marked for dispatching this event due to a change .Note : .For incremental processing , this specification does not define how often XForms", "label": "", "metadata": {}}
{"text": "Implementations are expected to optimize processing ( for instance not flashing the entire screen for each character entered , etc . ) .Note : .The change to the instance data associated with this event happens before the event is dispatched .4.4.3 The xforms - select and xforms - deselect Events .Dispatched in response to : an item in a select , select1 , or switch becoming selected or deselected .Target : item or case .Bubbles : Yes .Cancelable : No .Context Info : None .The default action for this event results in the following : None ; notification event only .", "label": "", "metadata": {}}
{"text": "Dispatched in response to : a setindex action attempting to set an index outside the range of a repeat .Target : repeat .Bubbles : Yes .Cancelable : No .Context Info : None .The default action for this event results in the following : None ; notification event only .4.4.5 The xforms - insert and xforms - delete Events .Dispatched in response to : A event handler invoking an XFormsAction insert or delete , successfully adding or deleting a repeat item .Target : instance .Bubbles : Yes .Context Info : Path expression used for insert / delete ( xsd : string ) .", "label": "", "metadata": {}}
{"text": "4.4.6 The xforms - valid Event .Dispatched in response to : an instance data node either changing and being or becoming valid .Context Info : None .The default action for this event results in the following : None ; notification event only .Dispatched in response to : the value of an instance data node has changed such that the value can now be represented by the form control .Target : form control .The default action for this event results in the following : None ; notification event only .This event is dispatched whenever the value of an instance data node that was not possible to represent given the constraints specified on a form control has changed such that the value can now be represented by the form control .", "label": "", "metadata": {}}
{"text": "Dispatched in response to : the value of an instance data node has changed such that the value can not be represented by the form control .Target : form control .Bubbles : Yes .Cancelable : No .Context Info : None .The default action for this event results in the following : None ; notification event only .This event is dispatched whenever the value of an instance data node can not be represented given the constraints specified on a form control .4.4.18The xforms - submit - done Event .Dispatched in response to : completion of submit processing , including processing any returned document .", "label": "", "metadata": {}}
{"text": "Bubbles : Yes .Cancelable : No .Context Info : None .The default action for this event results in the following : None ; notification event only .4.4.19 The xforms - submit - error Event .Dispatched as an indication of : a failure of the submit process , as defined at 11 Submit .Target : submission .Bubbles : Yes .Cancelable : No .Context Info : The submit method URI that failed ( xsd : anyURI ) .The default action for this event results in the following : None ; notification event only .", "label": "", "metadata": {}}
{"text": "Error indications happen as a result of unusual conditions in the XForms Processor .Some of these are \" fatal \" errors , which halt processing , and bear the suffix \" exception \" .Others are simply for notification , and bear the suffix \" error \" .For all events in this section , it is permissible for the XFormsProcessor to perform some kind of default handling , for example logging error messages to a file .4.5.1 The xforms - binding - exception Event .Target : any element that can contain a binding expression .", "label": "", "metadata": {}}
{"text": "Cancelable : No .Context Info : None .The default action for this event results in the following : Fatal error .4.5.2 The xforms - link - exception Event .Dispatched as an indication of : a failure in link traversal of a linking attribute .Target : model .Bubbles : Yes .Cancelable : No .Context Info : The URI that failed to load ( xsd : anyURI ) .The default action for this event results in the following : Fatal error .4.5.3 The xforms - link - error Event .Dispatched as an indication of : a failure in link traversal of a linking attribute , in a situation not critical to form processing .", "label": "", "metadata": {}}
{"text": "Bubbles : Yes .Cancelable : No .Context Info : The URI that failed to load ( xsd : anyURI ) .The default action for this event results in the following : None ; notification event only .4.5.4 The xforms - compute - exception Event .Dispatched as an indication of : an error occurring during XPath evaluation .Target : model .Bubbles : Yes .Cancelable : No .Context Info : Implementation - specific error string .The default action for this event results in the following : Fatal error .4.5.5 The xforms - version - exception Event .", "label": "", "metadata": {}}
{"text": "Target : the default model .Bubbles : Yes .Cancelable : No .Context Info : None .The default action for this event results in the following : Fatal error . 4.6 Event Sequencing .The previous sections describe processing associated with individual events .This section gives the overall sequence of related events that must occur in several common situations .In the following lists , events that may be fired more than once are prefixed with [ n].4.6.1 For input , secret , textarea , range , or upload Controls .The element of a document for which an IDREF must be resolved is called the source element , and the element bearing the matching ID , if there is one , is called the target element .", "label": "", "metadata": {}}
{"text": "This section describes how XFormsIDREF resolution works to accommodate such repetition of the originating document 's content .Each run - time occurrence of the source element is called a source object , and each run - time occurrence of the target element is called a target object .It is the source object that performs the IDREF resolution , and the result of the search is either null or a target object .Whether or not repeated content is involved , a null search result for an IDREF resolution is handled differently depending on the source object .", "label": "", "metadata": {}}
{"text": "Similarly , a submit form control does not dispatch xforms - submit if its submission attribute does not indicate an existing submission element .Likewise , when an XPath function associated with the source object performs the IDREF search and a null result is obtained , the function returns an empty result such as NaN for the index ( ) function or empty nodeset for the instance ( ) function .However , an xforms - binding - exception occurs if there is a null search result for the target object indicated by attributes bind , model and instance .", "label": "", "metadata": {}}
{"text": "This is true regardless of whether or not the source object is repeated .However , if the target element is repeated , then additional information must be used to help select a target object from among those associated with the identified target element .4.7.1 References to Elements within a repeat Element .When the target element that is identified by the IDREF of a source object has one or more repeat elements as ancestors , then the set of ancestor repeats are partitioned into two subsets , those in common with the source element and those that are not in common .", "label": "", "metadata": {}}
{"text": "For the repeat elements that are in common , the desired target object exists in the same set of run - time objects that contains the source object .Then , for each ancestor repeat of the target element that is not in common with the source element , the current index of the repeat determines the set of run - time objects that contains the desired target object .4.7.2 References to Elements within a bind Element .When a source object expresses a Single Node Binding or Node Set Binding with a bind attribute , the IDREF of the bind attribute is resolved to a target bind object whose associated nodeset is used by the Single Node Binding or Node Set Binding .", "label": "", "metadata": {}}
{"text": "Otherwise , the in - scope evaluation context node of the source object containing the bind attribute is used to help select the appropriate target bind object from among those associated with the target bind element .From among the bind objects associated with the target bind element , if there exists a bind object created with the same in - scope evaluation context node as the source object , then that bind object is the desired target bind object .Otherwise , the IDREF resolution produced a null search result .XForms supports all XML Schema datatypes except for xsd : duration , xsd : ENTITY , xsd : ENTITIES , and xsd : NOTATION .", "label": "", "metadata": {}}
{"text": "XForms includes datatypes derived by restriction and derived by list from these base types .XFormsProcessors must treat the datatypes listed in the chapter as in - scope without requiring the inclusion of an XML Schema .Built - in primitive types : .Note : .The built - in datatype xsd : duration is not supported , except as an abstract datatype .Instead , either xforms : dayTimeDuration or xforms : yearMonthDuration should be used .Built - in derived types : . 5.2 XForms Datatypes .The Schema for XForms derives the following types to facilitate defining model in XForms .", "label": "", "metadata": {}}
{"text": "This datatype serves as a base for the xforms : listItems datatype .The value space for listItem permits one or more characters valid for xsd : string , except white space characters .5.2.2 xforms : listItems .XForms includes form controls that produce simpleType list content .This is facilitated by defining a derived - by - list datatype .The value space for listItems is defined by list - derivation from listItem .XForms includes a totally ordered duration datatype that can represent a duration of days , hours , minutes , and fractional seconds .The value space for this datatype is the set of fractional second values .", "label": "", "metadata": {}}
{"text": "5.2.4 xforms : yearMonthDuration .XForms includes a totally ordered duration datatype that can represent a duration of a whole number of months and years .The value space for this datatype is the set of integer month values .This datatype is derived from xsd : duration .Fixed properties are static values that the XFormsProcessor evaluates only once .Such properties consist of literals , and are not subject to XPath evaluation .Computed expressions are XPath expressions that provide a value to the XForms Processor .Such values are recalculated at certain times as specified by the XForms", "label": "", "metadata": {}}
{"text": "These expressions encode dynamic properties , often constraints , such as the dependency among various data items .Computed expressions are not restricted to examining the value of the instance data node to which they apply . XPath expressions provide the means to traverse the instance data ; more complex computations may be encoded as call - outs to external scripts .Inheritance rules : .Note : .The sample recalculation algorithm defined in D Recalculation Sequence Algorithm is defined to operate only on the local values of a model item property .It assumes that an implementation propagates the combined values to a node 's descendants .", "label": "", "metadata": {}}
{"text": "Local values are assigned by processing all bind elements in an XForms Model in document order .It is an error to attempt to set a model item property twice on the same node .The details of this process are given at 4.2.1 The xforms - model - construct Event .The following sections list the model item properties available as part of all model items .For each , the following information is provided : .Description Computed Expression ( yes or no ) Legal Values Default Value Inheritance Rules .6.1.1 The type Property .Description : The type model item property can be applied to both elements and attributes .", "label": "", "metadata": {}}
{"text": "The type model item property associates a datatype ( as defined in [ XML Schema part 2 ] ) with the string - value ( as defined in [ XPath 1.0 ] ) of an instance node .The datatype being associated can be obtained from a simpleType definition or a simpleContent definition from a complexType .If the datatype can not be obtained as just described , then the Default Value of xsd : string is used .Computed Expression : No .Legal Values : Any xsd : QName representing a datatype definition in an XML Schema .", "label": "", "metadata": {}}
{"text": "Default Value : xsd : string .Inheritance Rules : does not inherit .Associating datatypes with instance nodes .Hello , world ! 100.00 abc 100.00 abc 100.00 abc 100.00 abc .The first bind expresses the default datatype of xsd : string .The second and third binds place type model item properties on each of the four price element children of the elements simpleType and complexType .Both binds associate the datatype xsd : double with the nodes .In both cases , the first and third nodes are considered valid according to the type model item property because their content matches the xsd : double datatype constraint .", "label": "", "metadata": {}}
{"text": "The fourth bind places a type model item property on the currency attribute of the third price element .According to this association , the currency attribute node is not valid because its content does not match the enumeration given for my : Currency .Note that the containing element price is valid according to its type model item property .The fifth bind attempts to associate a datatype with the data element .The association is ignored since the data element contains child elements .6.1.2 The readonly Property .Description : describes whether the value is restricted from changing .", "label": "", "metadata": {}}
{"text": "Legal Values : Any expression that is convertible to XPath boolean with boolean ( ) .Default Value : false ( ) , unless a calculate property is specified , then true ( ) .Inheritance Rules :If any ancestor node evaluates to true , this value is treated as true .Otherwise , the local value is used .Note : .This is the equivalent of taking the logical OR of the evaluated readonly property on the local and every ancestor node .When evaluating to true , this model item property indicates that the XFormsProcessor should not allow any changes to the bound instance data node .", "label": "", "metadata": {}}
{"text": "Form controls bound to instance data with the readonly model item property should indicate that entering or changing the value is not allowed .This specification does not define any effect on visibility , focus , or navigation order .Attaching a readonly property .Roland .Here , we have associated a readonly property with an element .6.1.3 The required Property .Description : describes whether a value is required before the instance data is submitted .Computed Expression : Yes .Legal Values : Any expression that is convertible to XPath boolean with boolean ( ) .", "label": "", "metadata": {}}
{"text": "Inheritance Rules : does not inherit .A form may require certain values , and this requirement may be dynamic .When evaluating to true , this model item property indicates that a non - empty instance data node is required before a submission of instance data can occur .Non - empty is defined as : .If the bound instance data node is an element , the element must not have the xsi : nil attribute set to true .The value of the bound instance data node must be convertible to an XPath string with a length greater than zero .", "label": "", "metadata": {}}
{"text": "XForms authors are strongly encouraged to make sure that form controls that accept required data are visible .An XFormsProcessor may provide an indication that a form control is required , and may provide immediate feedback , including limiting navigation .Chapter 4 Processing Model contains details on how the XFormsProcessor enforces required values .Attaching a required property .Roland .Here , we have associated a required property with element my : last - name to indicate that a value must be supplied .Note : .This is different than the XForms Model item property , in two ways : 1 ) use applies only to attributes , while XForms required applies to any node .", "label": "", "metadata": {}}
{"text": "6.1.4 The relevant Property .Description : indicates whether the model item is currently relevant .Instance data nodes with this property evaluating to false are not serialized for submission .Computed Expression : Yes .Legal Values : Any expression that is convertible to XPath boolean with boolean ( ) .Default Value : true ( ) .Inheritance Rules :If any ancestor node evaluates to XPath false , this value is treated as false .Otherwise , the local value is used .Note : .This is the equivalent of taking the logical AND of the evaluated relevant property on the local and every ancestor node .", "label": "", "metadata": {}}
{"text": "For example , a form might ask whether the respondent owns a car .It is only appropriate to ask for further information about their car if they have indicated that they own one .The relevant model item property provides information to the XForms user interface regarding visibility , focus , and navigation order .In general , when true , associated form controls should be made visible .When false , associated form controls ( and any children ) and group and switch elements ( including content ) must be made unavailable , removed from the navigation order , and not allowed focus .", "label": "", "metadata": {}}
{"text": "Note : .A form control , group or switch must express a single node binding in order to be associated with an instance node .Attaching a relevant property .Here , we have associated a relevant property with element my : discount to indicate a discount is relevant when the order amount is greater than 1000 .6.1.5 The calculate Property .Description : supplies an expression used to calculate a string value for the associated instance data node .Computed Expression : Yes .Legal Values : Any XPath expression .Default Value : none .Inheritance Rules : does not inherit .", "label": "", "metadata": {}}
{"text": "For example , the sum over line items for quantity times unit price , or the amount of tax to be paid on an order .Such computed values can be expressed with calculate properties , whose XPath expressions are evaluated and converted to strings with the XPath string ( ) function .Chapter 4 Processing Model contains details of when and how the calculation is performed .Attaching a calculate property .Here , we have associated a relevant property with element my : discount to indicate a discount of 10 % is relevant when the order amount is greater than 1000 .", "label": "", "metadata": {}}
{"text": "Description : specifies a predicate that needs to be satisfied for the associated instance data node to be considered valid .Computed Expression : Yes .Legal Values : Any expression that is convertible to XPath boolean with boolean ( ) .Default Value : true ( ) .Inheritance Rules : does not inherit .When evaluating to XPath false , the associated model item is not valid ; the converse is not necessarily true .Chapter 4 Processing Model contains details of when and how the constraint is calculated as well as when validation is performed .Attaching a constraint property .", "label": "", "metadata": {}}
{"text": "Note : .Specifying minimum and maximum occurrences for nodes in the instance data can be achieved by using the count ( ) function within a constraint property .6.1.7 The p3ptype Property .Description : Attaches a P3P data element to an instance data node , indicating the specific kind of data collected there .Computed Expression : No .Legal Values : xsd : string .Default Value : none .Inheritance Rules : does not inherit .This model item property holds a description of the kind of data collected by the associated instance data node , based on the P3P datatype system [ P3P 1.0 ] .", "label": "", "metadata": {}}
{"text": "Attaching a type constraint using Binding .Here , we have attached both XML Schema and P3P type information to element first - name via element bind .6.2 Schema Constraints .Chapter 5 Datatypes described how XForms uses the XML Schema datatype system to constrain the value space of data values collected by an XForms Model .Such datatype constraints can be provided via an XML Schema .Alternatively , this section lists various mechanisms for attaching type constraints to instance data .Attributes xsi : schemaLocation and xsi : noNamespaceSchemaLocation are ignored for purposes for locating a Schema .", "label": "", "metadata": {}}
{"text": "The XFormsProcessing Model applies XML Schema facets as part of the validation process .At the simplest level , it is necessary to associate a set of facets ( through an XML Schema datatype ) with a model item .This has the effect of restricting the allowable values of the associated instance data node to valid representations of the lexical space of the datatype .The set of facets associated with a model item must be determined by the following list , as if it were processed in the given order .When multiple datatype restrictions apply to the same model item , the combination of all given restrictions must apply .", "label": "", "metadata": {}}
{"text": "An XML Schema associated with the instance data .An XML Schema xsi : type attribute in the instance data .An XForms type constraint associated with the instance data node using XForms binding .The following declares a datatype based on xsd : string with an additional constraining facet .Type Constraint Using XML Schema .This new datatype would then be associated with one or more model items through one of the methods outlined here .Attaching Type Constraint Using XFormsBinding .Here , we have attached type information to element first - name via element bind .", "label": "", "metadata": {}}
{"text": "A future version of XForms is expected to use XPath 2.0 , which includes support for XML Schema datatypes . 7.2 Feature string for the hasFeature method call .For this version of the XForms specification , the feature string for the [ DOM2 Core ] DOMImplementation interface hasFeature method call is \" org.w3c.xforms.dom \" and the version string is \" 1.0 \" .7.3 Instance Data .For each model element , the XFormsProcessor maintains the state in an internal structure called instance data that conforms to the XPath Data Model [ XPath 1.0 ] .XFormsProcessors that implement DOM must provide DOM access to this instance data via the interface defined below .", "label": "", "metadata": {}}
{"text": "Instance data always has a single root element , and thus corresponds to a DOM Document .The IDL for this interface follows : . 7.3.1The getInstanceDocument ( ) Method .If the instance - id parameter is the empty string , then the document element of the default instance is returned .Otherwise , this method returns a DOM Document that corresponds to the instance data associated with the instance element containing an ID matching the instance - id parameter .If there is no matching instance data , a DOMException is thrown .7.3.2The rebuild ( ) Method .", "label": "", "metadata": {}}
{"text": "Processor to rebuild any internal data structures used to track computational dependencies within this XForms Model .This method takes no parameters and raises no exceptions .7.3.3 The recalculate ( ) Method .This method signals the XFormsProcessor to perform a full recalculation of this XForms Model .This method takes no parameters and raises no exceptions .7.3.4 The revalidate ( ) Method .This method signals the XFormsProcessor to perform a full revalidation of this XForms Model .This method takes no parameters and raises no exceptions .7.3.5The refresh ( ) Method .", "label": "", "metadata": {}}
{"text": "Processor to perform a full refresh of form controls bound to instance nodes within this XForms Model .This method takes no parameters and raises no exceptions . 7.4 Evaluation Context .Within XForms , the default model is the first model in document order .The default instance of any model is the first child instance in document order within that model . XPath expressions appearing in various XForms attributes are used to reference instance data .Every XPath expression requires an evaluation context consisting of a node , position , size , variable bindings , function set , and namespace context .", "label": "", "metadata": {}}
{"text": "Any namespace declarations in scope for the attribute that defines the expression are applied to the expression .The context node , position and size are determined according to rules described below .A binding element is any element that is explicitly allowed to have a binding expression attribute , and a bound element is any element that explicitly declares a binding expression attribute .A binding expression attribute contains an XPath expression that references zero or more nodes of instance data .Every XPath expression requires an evaluation context .The in - scope evaluation context of a binding element provides an evaluation context for the binding expression attribute .", "label": "", "metadata": {}}
{"text": "A binding element is \" outermost \" if the element has no ancestor binding elements .If an outermost binding element is contained by a model , then the context node for the outermost binding element is the top - level document element node of the default instance of the containing model element .Otherwise , the context node for outermost binding elements is the top - level document element node of the default instance in the default model .For outermost binding elements , the context size and position are 1 .The context node , position and size for non - outermost binding elements is determined using the binding expression attribute or in - scope evaluation context of the nearest ancestor binding element .", "label": "", "metadata": {}}
{"text": "For a non - outermost binding element : .If the nearest ancestor binding element is not a bound element , then the in - scope evaluation context of the non - outermost binding element is equivalent to the in - scope evaluation context of the nearest ancestor binding element .If the nearest ancestor binding element expresses a Single - Node binding , then the in - scope evaluation context of the non - outermost binding element has a context size and position of 1 and the context node is the one resulting from the Single - Node binding of the nearest ancestor binding element .", "label": "", "metadata": {}}
{"text": "If the nearest ancestor binding element expresses a Node Set binding , then the non - outermost binding element has its own in - scope evaluation context separately from those of its dynamically generated occurences described above .The in - scope evaluation context has a context position of 1 , and the context node and size are set by the first node and the size of the nodeset identified by the Node Set binding of the nearest ancestor binding element .Note : .The rules above for determining the in - scope evaluation context are applicable to XForms elements that can contain a binding expression attribute even if they can not contain a Single Node Binding or Node Set Binding .", "label": "", "metadata": {}}
{"text": "The in - scope evaluation context of an element that is not a binding element is the same as if the element were a binding element .For example , the in - scope evaluation context for the setindex action element is required to provide the context for evaluating the index attribute , so it is determined as if the element could contain a binding expression attribute . XPath expressions also appear in model item property attributes of the bind element to define computed expressions .If the bind element does not express a Node Set binding , then the in - scope evaluation context for model item property attributes of the bind is equal to the in - scope evaluation context for the bind .", "label": "", "metadata": {}}
{"text": "Generally , if the containing element does not express a Single Node Binding or Node Set Binding , then the special attribute is evaluated using the in - scope evaluation context .Special attributes may be evaluated using the in - scope evaluation context even if the containing element expresses a Single Node Binding or Node Set Binding .However , for some special attributes , the evaluation context node , position and size are based on the result of the Single Node Binding or Node set Binding .Each special attribute that contains an XPath expression describes how its evaluation context node , position and size are determined .", "label": "", "metadata": {}}
{"text": "According to the rules above , this outermost element node would have a context node of /level1 , which is the document element node of the instance data .The select1 form control then inherits a context node from the parent group .Sample XML Instance Data .Binding Expression Context Nodes .This section describes how the in - scope evaluation context of an element is determined , not whether the in - scope evaluation will be used .The Single - Node Binding or Node Set Binding of a non - outermost binding element is not evaluated if the in - scope evaluation context does not contain a context node .", "label": "", "metadata": {}}
{"text": "Also , if the Single - Node Binding or Node Set Binding of an element is expressed with the bind attribute , then the resulting node or nodeset is obtained from the referenced bind element .The nodeset attribute of a bind element is evaluated using the in - scope evaluation of the bind element , not the in - scope evaluation context of an element that references it with a bind attribute . 7.5 Binding Expressions .A binding expression is an XPath expression used in binding a model item property to one or more instance nodes , or to bind a form control to instance data , or to specify the node or node set for operation by an action .", "label": "", "metadata": {}}
{"text": "This behavior can be changed with the instance ( ) function .7.5.1 Dynamic Dependencies .Not every possible XPath expression is acceptable as a binding expression .In particular , there are restrictions on model binding expressions that create dynamic dependencies , which are defined as follows : .An XPath predicate ( in square brackets ) is a possibly implicit boolean test .A dynamic dependency exists on any predicate unless all terms in the test are \" fixed \" , where fixed means either a constant , or a value that will not change between operations explicitly defined as rebuilding computational dependencies .", "label": "", "metadata": {}}
{"text": "For purposes of determining dynamic dependencies , the following subexpressions are considered fixed : position ( ) , last ( ) , count ( ) , and property ( ) .This is because the specification mandates a dependency rebuild after any event that could change the values returned by these functions .Another dynamic dependency is any use of the i d ( ) function , unless both the parameter to the function and the matching attribute of type xsd : ID are fixed .In the same way , the instance ( ) function is dynamic unless the parameter to the function is fixed . XPath variables that change in value from one recalculate to the next would also create dynamic dependencies ( though XForms 1.0 defines an empty variable context for all XPath expressions ) .", "label": "", "metadata": {}}
{"text": "7.5.2 Model Binding Expressions .A model binding expression is a kind of binding expression that can be used to declare model item properties , and is used in attributes of the bind element .Dynamic dependencies in model binding expressions will generally require manual rebuilding of dependencies .Dynamic dependences are allowed in UI binding expressions based on the conformance profile .7.5.4 UI Binding in other XML vocabularies .The XForms binding mechanism allows other XML vocabularies to bind user interface controls to an XForms Model using any of the techniques shown here .As an example , XForms binding attribute bind might be used within XHTML 1.x user interface controls as shown below .", "label": "", "metadata": {}}
{"text": "XFormsBinding In XHTML 1.x User Interface Controls .7.5.5 Binding Examples .Consider the following document with the one - and - only XForms model : .John .The following examples show three ways of binding user interface control xforms : input to instance element firstName declared in the model shown above .7.6The XForms Function Library .The XForms Function Library includes the entire [ XPath 1.0 ] Core Function Library , including operations on node - sets , strings , numbers , and booleans .The function library provided by an XForms processor may also contain other extension functions as described in 7.12 Extension Functions .", "label": "", "metadata": {}}
{"text": "Function boolean - from - string returns true if the required parameter string is \" true \" or \" 1 \" , or false if parameter string is \" false \" , or \" 0 \" .This is useful when referencing a Schema xsd : boolean datatype in an XPath expression .If the parameter string matches none of the above strings , according to a case - insensitive comparison , the return value is false .7.7.2 The if ( ) Function . string if ( boolean , string , string ) .Function if evaluates the first parameter as boolean , returning the second parameter when true , otherwise the third parameter .", "label": "", "metadata": {}}
{"text": "7.8.1The avg ( ) Function .number avg ( node - set ) .Function avg returns the arithmetic average of the result of converting the string - values of each node in the argument node - set to a number .The sum is computed with sum ( ) , and divided with div by the value computed with count ( ) .If the parameter is an empty node - set , or if any of the nodes evaluate to NaN , the return value is NaN .7.8.2 The min ( ) Function .number min ( node - set ) .", "label": "", "metadata": {}}
{"text": "\" If the parameter is an empty node - set , or if any of the nodes evaluate to NaN , the return value is NaN .7.8.3The max ( ) Function .number max ( node - set ) .Function max returns the maximum value of the result of converting the string - values of each node in argument node - set to a number .\" If the parameter is an empty node - set , or if any of the nodes evaluate to NaN , the return value is NaN .7.8.4The count - non - empty ( ) Function .", "label": "", "metadata": {}}
{"text": "Function count - non - empty returns the number of non - empty nodes in argument node - set .A node is considered non - empty if it is convertible into a string with a greater - than zero length .7.8.5The index ( ) Function .number index ( string ) .Function index takes a string argument that is the IDREF of a repeat and returns the current 1-based position of the repeat index for the identified repeat -see 9.3.1 The repeat Element for details on repeat and its associated repeat index .if the specified argument does not identify a repeat , the function returns NaN .", "label": "", "metadata": {}}
{"text": "The IDREF obtained from the function parameter may not uniquely identify the desired repeat if the repeat element bearing the matching ID resides in a repeating construct such as element repeat .The general method described in 4.7 Resolving ID References in XForms is used to determine the desired run - time repeat object . index .Add to Shopping Cart . string property ( string ) .Function property returns the XForms property named by the string parameter .The following properties are available for reading ( but not modification ) .7.10 Date and Time Functions .The following XML Schema datatypes do not have specific functions for manipulation within XForms expressions : xsd : time , xsd : gYearMonth , xsd : gYear , xsd : gMonthDay , xsd : gDay , xsd : gMonth .", "label": "", "metadata": {}}
{"text": "7.10.1 The now ( ) Function . string now ( ) .The now function returns the current system date and time as a string value in the canonical XML Schema xsd : dateTime format .If time zone information is available , it is included ( normalized to UTC ) .If no time zone information is available , an implementation default is used .Note : .Attaching a calculation of \" now ( ) \" to an instance data node would not result in a stream of continuous recalculations of the XForms Model . 7.10.2The days - from - date ( ) Function .", "label": "", "metadata": {}}
{"text": "This function returns a whole number of days , according to the following rules : .If the string parameter represents a legal lexical xsd : date or xsd : dateTime , the return value is equal to the number of days difference between the specified date or dateTime ( normalized to UTC ) and 1970 - 01 - 01 .Hour , minute , and second components are ignored after normalization .Any other input parameter causes a return value of NaN .Examples : . days - from - date(\"2002 - 01 - 01 \" ) returns 11688 days - from - date(\"1969 - 12 - 31 \" ) returns -1 .", "label": "", "metadata": {}}
{"text": "number seconds - from - dateTime ( string ) .This function returns a possibly fractional number of seconds , according to the following rules : .If the string parameter represents a legal lexical xsd : dateTime , the return value is equal to the number of seconds difference between the specified dateTime ( normalized to UTC ) and 1970 - 01 - 01T00:00:00Z .If no time zone is specified , UTC is used .Any other input string parameter causes a return value of NaN .7.10.4 The seconds ( ) Function .number seconds ( string ) .", "label": "", "metadata": {}}
{"text": "The sign of the result will match the sign of the duration .Year and month components , if present , are ignored .Any other input parameter causes a return value of NaN .Examples : .seconds(\"P1Y2 M \" ) returns 0 seconds(\"P3DT10H30M1.5S \" ) returns 297001.5 seconds(\"3 \" ) returns NaN .Note : .Even though this function is defined based on a lexical xsd : duration , it is intended for use only with derived - from- xsd : duration datatypes , specifically xforms : dayTimeDuration . 7.10.5 The months ( ) Function .number months ( string ) .", "label": "", "metadata": {}}
{"text": "The sign of the result will match the sign of the duration .Day , hour , minute , and second components , if present , are ignored .Any other input parameter causes a return value of NaN .Examples : .months(\"P1Y2 M \" ) returns 14 months(\"-P19 M \" ) returns -19 .Note : .Even though this function is defined based on a lexical xsd : duration , it is intended for use only with derived - from- xsd : duration datatypes , specifically xforms : yearMonthDuration .7.11 Node - set Functions .7.11.1 The instance ( ) Function .", "label": "", "metadata": {}}
{"text": "An XForms Model can contain more than one instance .This function allows access to instance data , within the same XForms Model , but outside the instance data containing the context node .If the argument is omitted or is equal to the empty string , then the root element node ( also called the document element node ) is returned for the default instance in the model that contains the current context node .Otherwise , the argument is converted to a string as if by a call to the string function .This string is treated as an IDREF , which is matched against instance elements in the containing document .", "label": "", "metadata": {}}
{"text": "In all other cases , an empty node - set is returned .Example : .For instance data corresponding to this XML : .John .The following expression selects the firstName node .Note that the instance function returns an element node , effectively replacing the leftmost location step from the path : . 7.12 Extension Functions .XForms documents may use additional XPath extension functions beyond those described here .A number of useful community extensions are defined at [ EXSLT ] .The names of any such extension functions must be declared in attribute functions on element model .", "label": "", "metadata": {}}
{"text": "Processor to check against available extension functions .XFormsProcessors perform this check at the time the document is loaded , and stop processing by signaling an exception ( 4.5.4 The xforms - compute - exception Event ) if the XForms document declares an extension function for which the processor does not have an implementation .Note : .Explicitly declaring extension functions enables XFormsProcessors to detect the use of unimplemented extension functions at document load - time , rather than throwing a fatal error during user interaction .Failure by authors to declare extension functions will result in an XForms Processor potentially halting processing during user interaction with a fatal error . 8.1 The XForms", "label": "", "metadata": {}}
{"text": "Form controls are declared using markup elements , and their behavior refined via markup attributes .Optional attribute to define an appearance hint .if absent , the user agent may freely choose any suitable rendering .Note : .A host language is expected to add attributes such as xml : lang as well as an attribute , named class , that holds a list of strings that can be matched by CSS class selectors .Further , a host language must provide a way to indicate overall navigation order among form controls and other elements included in the host language , as well as keyboard or direct access navigation to specific elements .", "label": "", "metadata": {}}
{"text": "Optional attribute is a non - negative integer in the range of 0 - 32767 used to define the navigation sequence .This gives the author control over the sequence in which form control s are traversed .The default navigation order is specified in the chapter 4 Processing Model . accesskey .Optional attribute defines a shortcut for moving the input focus directly to a particular form control .The value of this is a single character which when pressed together with a platform specific modifier key ( e.g. , the alt key ) results in the focus being set to this form control .", "label": "", "metadata": {}}
{"text": "This may be accomplished in different ways by different implementations , for example through direct interaction with the application or via the user 's guide .The accesskey requested by the author might not be made available by the player ( for example it may not exist on the device used , or it may be used by the player itself ) .Therefore the user agent should make the specified key available , but may map the accesskey to a different interaction behavior .UI Inline .As shown above , the XML Events module adds the Actions content set into the UI Common content set .", "label": "", "metadata": {}}
{"text": "When the XFormsExtension module is present , it too should be included in the UI Common content set .Form controls enable accessibility by taking a uniform approach to such features as labels , help text , navigation , and keyboard shortcuts .Internationalization issues are addressed by following the same design principles as in XHTML .All form controls are suitable for styling as aural or visual media .Form controls encapsulate high - level semantics without sacrificing the ability to deliver real implementations .For instance , the form control select enables the user to select items from a set .", "label": "", "metadata": {}}
{"text": "This separation enables the expression of the intent underlying a particular form control - see [ AUI97 ] for a definition of such high - level user interaction primitives .Form controls when rendered display the underlying data values to which they are bound .While the data presented to the user through a form control must directly correspond to the bound instance data , the display representation is not required to match the lexical value .For example , user agents should apply appropriate conventions to the display of dates , times , durations and numeric values including separator characters .", "label": "", "metadata": {}}
{"text": "If a form control violates its data binding restriction , an xforms - binding - exception must occur .All form controls that read simpleContent instance data must do so as follows : .Element nodes : If element child nodes are present , then an xforms - binding - exception occurs .Otherwise , if text child nodes are present , returns the string - value of the first text child node .Otherwise , returns \" \" ( the empty string ) .Attribute nodes : returns the string - value of the node .Text nodes : returns the string - value of the node .", "label": "", "metadata": {}}
{"text": "Form controls must distinguish rendering between valid and invalid states .Control of this behavior should be made available to stylesheets .Form controls must indicate when the bound instance data contains a value the form control is not capable of rendering .Control of this behavior should be made available to stylesheets .Form controls must render upon request an explanation of the current state of a form control , including validity and associated model item properties .Control of this behavior should be made available to stylesheets .Form controls must provide a default explanation for the above when no user - specified explanation is available .", "label": "", "metadata": {}}
{"text": "the form control is contained by a non - relevant switch or group ( which includes a non - relevant repeat item ) , or .the form control is contained by a non - selected case element of a switch .When a form control becomes non - relevant , it must receive event xforms - disabled and then the XForms action handlers that are listening for events on the non - relevant form control must be disabled .The following events must be dispatched to the form control : xforms - enabled , xforms - value - changed , one of xforms - valid or xforms - invalid , one of xforms - readonly or xforms - readwrite , one of xforms - required or xforms - optional , and one of xforms - in - range or xforms - out - of - range .", "label": "", "metadata": {}}
{"text": "Description Common Attributes Special Attributes Examples Data Binding Restrictions Implementation Requirements .Optional .This form control accepts an input mode hint .E Input Modes . incremental .when true , this form control will generate additional xforms - value - changed events .The default value for this attribute is false .Example : .Street Please enter the number and street name .In the above , the class attribute can be used by a style sheet to specify the display size of the form control .Note that the constraints on how much text can be input are obtained from the underlying XForms Model definition and not from these display properties .", "label": "", "metadata": {}}
{"text": "Implementation Requirements : Must allow entry of a lexical value for the bound datatype .Implementations should provide a convenient means for entry of datatypes and take into account localization and internationalization issues such as representation of numbers .For example , an input bound to an instance data node of type xsd : date might provide a calendar control to enter dates ; similarly , an input control bound to of type boolean might be rendered as a checkbox .Ship By Please specify the ship date for this order .Description : This form control is used to provide the user with the ability to supply information to the system in a manner that makes it difficult for someone , other than the user , who may be observing the process to discern the value that is being supplied .", "label": "", "metadata": {}}
{"text": "Implementation Requirements : Implementations , including accessibility aids , must obscure the value being entered into this form control .Note that this provides only a casual level of security ; truly sensitive information will require additional security measures outside the scope of XForms .8.1.4 The textarea Element .Description : This form control enables free - form data entry and is intended for use in entering multiline content , e.g. , the body of an email message .Optional .This form control accepts an input mode hint .E Input Modes . incremental .when true , this form control will generate additional xforms - value - changed events .", "label": "", "metadata": {}}
{"text": "Example : .In the above , the class attribute can be used by a style sheet to specify the display size of the form control .Note that the constraints on how much text can be input are obtained from the underlying XForms Model definition and not from these display properties .Data Binding Restrictions : Binds to xsd : string or any derived simpleContent .Implementation Requirements : Must allow entry of a lexical value for the bound datatype , including multiple lines of text .8.1.5 The output Element .Description : This form control renders a value from the instance data , but provides no means for entering or changing data .", "label": "", "metadata": {}}
{"text": "Note that attributes ref and value on element output are mutually exclusive .This form control does not use the UI Common attribute group , but nevertheless still contains an optional appearance attribute , as defined above .value .Optional .An XPath expression to be evaluated .The string result of the evaluation is rendered by the form control .If binding attributes are present to select a node , this attribute has no effect .The evaluation context is the same as would be applied to the evaluation of the single node binding .This XPath expression is re - evaluated whenever there is a change in any node to which the expression refers .", "label": "", "metadata": {}}
{"text": "Implementations should provide a convenient means for display of datatypes and take into account localization and internationalization issues such as representation of numbers .8.1.6 The upload Element .Description : This form control enables the common feature found on Web sites to upload a file from the local file system , as well as accepting input from various devices including microphones , pens , and digital cameras .On activation , if child element filename is present and a filename is available , upload places the filename of the data to upload in the instance at the node indicated by the binding attributes on child element filename .", "label": "", "metadata": {}}
{"text": "Data Binding Restrictions : This form control can only be bound to datatypes xsd : anyURI , xsd : base64Binary or xsd : hexBinary , or types derived by restriction from these .Implementation Requirements : For base64Binary or hexBinary data binding : .When bound to an instance data node of type xsd : base64binary , xsd : hexBinary , or a type derived by restriction thereof , on activation upload places the binary content in the content of the node with the indicated encoding .Implementation Requirements : For anyURI data binding : .When bound to an instance data node of type xsd : anyURI ( or a type derived by restriction thereof ) , on activation upload places a URI in the content of the node .", "label": "", "metadata": {}}
{"text": "Processor must not dereference the URI bound to this form control without explicit user permission .Implementations with a file system should support file upload -selecting a specific file .Implementation Requirements : For all data bindings : .Implementations with specific pen / digitizer hardware should ( and implementations with other pointing devices may ) support scribble -allowing in - place creation of pen - based data .Implementations with specific audio recording capabilities should support record audio -in - place recording of an audio clip .Implementations with a digital camera , scanner interface or screen capture should support acquire image -in - place upload of images from an attached device .", "label": "", "metadata": {}}
{"text": "Implementations with 3d capabilities should provide a 3d interface option .Implementations may provide proprietary implementations ( for example , a mediatype of text / rtf could invoke an edit window with a proprietary word processing application ) .Implementations are encouraged to support other input devices not mentioned here .Implementations which can not support upload for the given mediatype must make this apparent to the user .Implementation Requirements : Must allow input of a value corresponding to the bound datatype .Implementations should inform the user of the upper and lower bounds , as well as the step size , if any .", "label": "", "metadata": {}}
{"text": "In graphical environments , this form control may be rendered as a \" slider \" or \" rotary control \" .Notice that the attributes of this element encapsulate sufficient metadata that in conjunction with the type information available from the XFormsModel proves sufficient to produce meaningful prompts when using modalities such as speech , e.g. , when using an accessibility aid .Thus , in the example below , an aural user agent might speak a prompt of the form Please pick a date in the range January 1 , 2001 through December 31 , 2001 .In the event of overlapping restrictions between the underlying datatype and the start and end hints , the most restrictive range should be used .", "label": "", "metadata": {}}
{"text": "Ship Date .8.1.8 The trigger Element .Description : This form control is similar to the HTML element button and allows for user - triggered actions .This form control may also be used to construct other custom form controls .Data Binding Restrictions : Binds to any node .This form control does not directly interact with form data , but is affected by model item properties of the bound node , thus binding attributes are not required .Implementation Requirements : The user agent must provide a means to generate an DOMActivate event on the form control .", "label": "", "metadata": {}}
{"text": "Style sheets can be used to style this form control as an image , hyperlink , or other presentation .8.1.9The submit Element .Description : This form control initiates submission of all or part of the instance data to which it is bound .Submit Timecard .Data Binding Restrictions : Binds to any node .This form control does not directly interact with form data , but is affected by model item properties of the bound node , thus binding attributes are not required .Implementation Requirements : The default action for event DOMActivate is to dispatch event xforms - submit to the submission element specified by required attribute submission .", "label": "", "metadata": {}}
{"text": "8.1.10 The select Element .Description : This form control allows the user to make multiple selections from a set of choices .Optional attribute determining whether free entry is allowed in the list .Default is \" closed \" .incremental .When true , this form control will generate additional xforms - value - changed events .The default for this form control is true .Example : .Flavors Vanilla v Strawberry s Chocolate c .In the above example , more than one flavor can be selected .A graphical browser might render form control select as any of the following : .", "label": "", "metadata": {}}
{"text": "The value of the attribute consists of one of the following values : . \" full \" : all choices should be rendered at all times . \" compact \" : a fixed number of choices should be rendered , with scrolling facilities as needed \" minimal \" : a minimum number of choices should be rendered , with a facility to temporarily render additional choices .Data Binding Restrictions : any simpleContent capable of holding a sequence .The restriction to binding simpleContent exists when the choices are authored as part of the user interface control as shown in this section .", "label": "", "metadata": {}}
{"text": "Note : .A limitation of the XML Schema list datatypes is that white space characters in the storage values ( the value element ) are always interpreted as separators between individual data values .Therefore , authors should avoid using white space characters within storage values with list simpleContent .Incorrect Type Declaration .United States of America ... .When selected , this item would introduce not one but four additional selection values : \" America \" , \" of \" , \" States \" , and \" United \" .Implementation Requirements : The label for each choice must be presented , allowing at any number of selections , possibly none .", "label": "", "metadata": {}}
{"text": "The values to be stored are either directly specified as the contents of element value , or specified indirectly through binding attributes on element value .Note that the datatype bound to this form control may include a non - enumerated value space , e.g. , xsd : string , or a union of a enumeration and a non - enumerated datatype ( called an open enumeration ) .The form control should then allow free data entry , as described in 8.1.2 The input Element .The form control may permit multiple values to be entered through free entry .", "label": "", "metadata": {}}
{"text": "If there is no match , no items are initially selected .If any selected values do not have a choice with a matching storage value , the form control must indicate an out - of - range condition .For open selections : If the initial instance values match the storage value specified by one or more of the items , the all such matching items are selected .If the initial instance values do not match the storage value specified by one or more of the items , all such non - matching items are included as selected values , as if entered through free entry .", "label": "", "metadata": {}}
{"text": "When using dynamic selections with complexTypes , open selection has no effect .Implementation Hints : An accessibility aid might allow the user to browse through the available choices and leverage the grouping of choices in the markup to provide enhanced navigation through long lists of choices .8.1.11 The select1 Element .Description : This form control allows the user to make a single selection from multiple choices .Optional attribute determining whether free entry is allowed in the list .Default is \" closed \" .incremental .When true , this form control will generate additional xforms - value - changed events .", "label": "", "metadata": {}}
{"text": "Example : .Flavor Vanilla v Strawberry s Chocolate c .In the above example , selecting one of the choices will result in the associated value given by element value on the selected item being set in the underlying instance data at the location icecream / flavor .A graphical browser might render this form control as any of the following : .Data Binding Restrictions : Binds to any simpleContent .The restriction to binding simpleContent exists when the choices are authored as part of the user interface control as shown in this section .Element itemset for creating dynamic selections described in 9.3.3 The itemset Element allows the available choices to be obtained from an XForms Model , and when using that construct , the data binding restriction to simpleContent is relaxed .", "label": "", "metadata": {}}
{"text": "This form control stores the value corresponding to the selected choice in the location addressed by attribute ref .The value to be stored is either directly specified as the contents of element value , or specified indirectly through binding attributes on element value .Note that the datatype bound to this form control may include a non - enumerated value space , e.g. , xsd : string , or a union of a enumeration and a non - enumerated datatype ( called an open enumeration ) .The form control should then allow free data entry , as described in 8.1.2 The input Element .", "label": "", "metadata": {}}
{"text": "If there is no match , the form control must indicate an out - of - range condition .For open selections : If the initial instance value matches the storage value specified by one of the items , the first such matching item is selected .Otherwise , the selected value is the initial lexical value .Free entry text is handled the same as form control input 8.1.2 The input Element .User interfaces may choose to render this form control as a pulldown list or group of radio buttons , among other options .The appearance attribute offers a hint as to which rendering might be most appropriate , although any styling information ( such as CSS ) should take precedence .", "label": "", "metadata": {}}
{"text": "The choices Element .This element is used within selection form controls to group available choices .This provides the same functionality as element optgroup in HTML .Data Binding Restriction : All lexical values must be valid according to the datatype bound to the selection control .If inline content and a Single Node Binding are both specified , the Single Node Binding is used . 8.3 Additional Elements .The child elements detailed below provide the ability to attach metadata to form controls .Instead of supplying such metadata e.g. , the label for a form control as inline content of the contained element label , the metadata can be pointed to by using a simple linking attribute src on these elements .", "label": "", "metadata": {}}
{"text": "Factoring all human readable messages to a separate resource XML file .Using URIs into this XML resource bundle within individual label elements .Finally , an XForms implementation could use content negotiation to obtain the appropriate XML resource bundle , e.g. , based on the accept - language headers from the client , to serve up the user interface with messages localized to the client 's locale .8.3.1 The filename Element .Binding attributes on optional element filename specify the location in the instance for the parent element upload , when activated , to place the filename for the chosen binary resource .", "label": "", "metadata": {}}
{"text": "In the following example , the user is prompted to select an image .When activated , upload places in mail / attachment either the binary data of the image or a URI for it , depending on the type declared for the mail / attachment .The filename , perhaps \" me.jpg \" , is placed in the attribute node mail / attachment@filename , and the mediatype , perhaps \" image / jpeg \" in the attribute node mail / attachment@mediatype .Example : .Select an image to attach .8.3.2 The mediatype Element .Binding attributes on optional element mediatype specify the location in the instance for the parent element upload , when activated , to place the mediatype of the chosen binary resource , if available .", "label": "", "metadata": {}}
{"text": "Additionally , the label makes it possible for someone who ca n't see the form control to obtain a short description while navigating between form controls .The label specified can exist in instance data , in a remote document , or as inline text .If more than one source of label is specified in this element , the order of precedence is : single node binding attributes , linking attributes , inline text .An accessibility aid might speak the metadata encapsulated here when the containing form control gets focus .8.3.4 The help Element .The optional element help provides a convenient way to attach help information to a form control .", "label": "", "metadata": {}}
{"text": "If more than one source of message is specified in this element , the order of precedence is : single node binding attributes , linking attributes , inline text .The message specified can exist in instance data , in a remote document , or as inline text .If more than one source of message is specified in this element , the order of precedence is : single node binding attributes , linking attributes , inline text .The optional element alert provides a convenient way to attach alert or error information to a form control .Rendering of this element is implementation - defined , and there is no default level such as modal or ephemeral for the displayed message .", "label": "", "metadata": {}}
{"text": "If more than one source of message is specified in this element , the order of precedence is : single node binding attributes , linking attributes , inline text .See F XForms and Styling for examples to see how this might be presented to the user .9 XForms User Interface .This chapter covers XForms features for combining form control s into user interfaces .9.1 The XForms Group Module .All form controls defined in 8 Form Controls are treated as individual units for purposes of visual layout e.g. , in XHTML processing .Aggregation of form controls with markup defined in this chapter provides semantics about the relationship among user interface controls ; such knowledge can be useful in delivering a coherent UI to small devices .", "label": "", "metadata": {}}
{"text": "The elements and attributes included in this module are : .The group element is used as a container for defining a hierarchy of form controls .Groups can be nested to create complex hierarchies .A group is considered to be non - relevant if and only if : . the Single Node Binding is expressed and resolves to empty nodeset , . the Single Node Binding is expressed and resolves to a non - relevant instance node , .the group is contained by a non - relevant switch or group ( which includes a non - relevant repeat item ) , or .", "label": "", "metadata": {}}
{"text": "All content elements ( e.g. form controls , groups , switches , repeats and host language content ) within a non - relevant group are handled as non - relevant .When a group becomes non - relevant , it must receive event xforms - disabled and then the XForms action handlers that are listening for events on the non - relevant group must be disabled .When a non - relevant group changes to being relevant , the XForms action handlers that listen for events on the group must become enabled and then the group must receive the event xforms - enabled .", "label": "", "metadata": {}}
{"text": "The optional label element has special significance when it appears as the first element child of group , representing a label for the entire group .Example : .Shipping Address Address line 1 Address line 2 Postcode .Setting the input focus on a group results in the focus being set to the first form control in the navigation order within that group .9.2 The XForms Switch Module .This section defines a switch construct that allows the creation of user interfaces where the user interface can be varied based on user actions and events .The elements and attributes included in this module are : .", "label": "", "metadata": {}}
{"text": "Note : .This is separate from XForms relevant processing ( see 6.1.4 The relevant Property ) , which is based on the current state of the XForms Model .As an example , portions of a questionnaire pertaining to the user 's automobile may become relevant only if the user has answered in the affirmative to the question ' Do you own a car ? 'The non - relevance of a switch is determined in the same way as it is for group and similarly applies to the entire content .Also , as with group , when a switch becomes non - relevant , it must receive event xforms - disabled and then the XForms action handlers that are listening for events on the non - relevant switch must be disabled .", "label": "", "metadata": {}}
{"text": "Please tell me your name Hello Edit .The above results in the portion of the user interface contained in the first case being displayed initially .This prompts for the user 's name ; filling in a value and activating the control e.g. , by pressing enter results switches to the alternate case , with a read - only output rendering .Activating the trigger labeled \" Edit \" in turn switches back to the original case .9.2.2 The case Element .This element encloses markup to be conditionally rendered .The content elements ( e.g. form controls , groups , switches , repeats and host language elements ) within a non - selected case behave as if they were in a non - relevant group ( see 9.1.1 The group Element ) .", "label": "", "metadata": {}}
{"text": "The attribute selected determines the initial selected state .The IDREF obtained from the case attribute may not uniquely identify the desired case if the case element bearing the matching ID resides in a repeating construct such as element repeat .The general method described in 4.7 Resolving ID References in XForms is used to determine the desired run - time case object .9.3 The XForms Repeat Module .The XForms specification allows the definition of repeating structures such as multiple items within a purchase order .When defining the XForms Model , such higher - level collections are constructed out of basic building blocks ; similarly , this section defines user interface construct repeat that can bind to data structures such as lists and collections .", "label": "", "metadata": {}}
{"text": "[ repeat - nodeset , repeat - bind , repeat - model ] ( Node Set Binding attributes ) , repeat - startindex ( xsd : positiveInteger ) , repeat - number ( xsd : nonNegativeInteger ) .N / A .This element defines a UI mapping over a homogeneous collection selected by Node Set Binding Attributes .This node - set must consist of contiguous child element nodes , with the same local name and namespace name of a common parent node .The behavior of element repeat with respect to non - homogeneous node - sets is undefined .", "label": "", "metadata": {}}
{"text": "Optional 1-based initial value of the repeat index .The default value is 1 . number .Optional hint to the XFormsProcessor as to how many elements from the collection to display .This element operates over a homogeneous collection by binding the encapsulated user interface controls to each element of the collection . if an element of the collection is non - relevant , then the rendering approach used to signify non - relevance is applied to the associated user interface controls .Attributes on this element specify how many members of the collection are presented to the user at any given time .", "label": "", "metadata": {}}
{"text": "Actions insert , delete , and setindex can be used to operate on the collection - see 10 XForms Actions .Another way to view repeat processing ( disregarding special user interface interactions ) is to consider \" unrolling \" the repeat .The above example is similar to the following ( given four item elements in the returned node - set ) : .Repeat Unrolled .Homogeneous Collection .3.00 32.25 132.99 ...Line Item Name Insert a new item after the current one 0.00 remove current item .9.3.2 Creating Repeating Structures Via Attributes .Element repeat enables the creation of user interfaces for populating repeating structures .", "label": "", "metadata": {}}
{"text": "Thus , one might wish to use element repeat within a table to create the rows of a table , where each row of the table binds to a distinct member of a homogeneous collection .Since html : table does n't ( and probably never will ) allow xforms : repeat elements as children , another syntax is needed .Tables And Repeating Structures .More generally , there is a need to integrate repeat behavior into host languages at points where the content model of the host language does not or can not provide the appropriate extension hooks via modularization .", "label": "", "metadata": {}}
{"text": "The above attributes are equivalent to the repeat attributes of the same name , but without the prefix repeat- .A host language can include these attributes in the appropriate places to enable repeating constructs .For example , a version of XHTML might use : .Tables And Repeating Structures .Which could be validated against an appropriately configured XHTML Schema that includes the XForms Repeat module .Note that what gets repeated is the child elements of the element with the repeat- attributes .Additionally , when using XFormsAction setindex , attribute repeat of type idref can point to any element carrying the repeat attributes .", "label": "", "metadata": {}}
{"text": "9.3.3 The itemset Element .This element allows the creation of dynamic selections within controls select and select1 , where the available choices are determined at run - time .The node - set that holds the available choices is specified via the Node Set Binding .As with repeat , this nodeset should refer to a homogeneous collection .Child elements label and value indirectly specify the label and storage values .Notice that the run - time effect of itemset is the same as using element choices with child item elements to statically author the available choices .", "label": "", "metadata": {}}
{"text": "XFormsActions appearing in the content of an itemset are created within each item element , and the in - scope evaluation context for these XFormsActions is based on the node for which the item was generated as described in Section 7.4 Evaluation Context .An XForms processor must not allow XFormsActions contained by an itemset to handle events on the itemset .Whenever a refresh event is dispatched the nodeset is re - evaluated to update the list of available choices .The following example shows element itemset within control select to specify a dynamic list of ice cream flavors : .", "label": "", "metadata": {}}
{"text": "Vanilla Strawberry Chocolate Flavors .9.3.4 The copy Element .Structurally , this element is similar to 8.2.3 The value Element .It differs in that it can only be used within itemset , and that it works with subtrees of instance data rather than simple values .The child element node associated with the item , selected by the binding attributes on copy , is deleted .A full computational dependency rebuild .This action is used to insert new entries into a homogeneous collection , e.g. , a set of items in a shopping cart .Attributes of action insert specify the insertion in terms of the collection in which a new entry is to be inserted , and the location within that collection where the new node will appear .", "label": "", "metadata": {}}
{"text": "In this process , nodes of type xsd : ID are modified to remain as unique values in the instance data .Required selector ( \" before \" or \" after \" ) of insert before / after behavior .The rules for insert processing are as follows : .The homogeneous collection to be updated is determined by evaluating the Node Set Binding . if the collection is empty , the insert action has no effect .The node - set binding identifies a homogeneous collection in the instance data .The final member of this collection is cloned to produce the node that will be inserted .", "label": "", "metadata": {}}
{"text": "Attribute at is evaluated to determine the insertion index - a numerical value that is the index into the node - set .The attribute at is evaluated with the first node in document order from the node set binding as the context node , the size of the node set binding as the context size and 1 as the context position .Attribute position specifies whether the new node is inserted before or after this index .The rules for selecting the index are as follows : .The return value of the XPath expression in attribute at is processed according to the rules of the XPath function round ( ) .", "label": "", "metadata": {}}
{"text": "If the result is NaN , the insert appends to the end of the node - set .If the resulting index is outside the valid range of the node - set , it is replaced with either 1 or the size of the node - set , whichever is closer .The index for any repeating sequence that is bound to the homogeneous collection where the node was added is updated to point to the newly added node .The indexes for inner nested repeat collections are re - initialized to startindex .If the insert is successful , the event xforms - insert is dispatched .", "label": "", "metadata": {}}
{"text": "Such nodes are constructed as defined in the initialization section of the processing model - see 4.2 Initialization Events .As an example , this causes the instantiation of the necessary user interface for populating a new entry in the underlying collection when used in conjunction with repeating structures .An example of using insert with a repeating structure is located at 9.3.1 The repeat Element .Note that XForms Action setvalue can be used in conjunction with insert to provide initial values for the newly inserted nodes .The homogeneous collection to be updated is determined by evaluating the Node Set Binding .", "label": "", "metadata": {}}
{"text": "The n -th element node is deleted from the instance data , where n represents the number returned from node - set index evaluation , defined in 9.3.5 The insert Element .If no n th node exists , the operation has no effect .The index should point to the same node after a delete as it did before the delete except : .When the last remaining item in the collection is removed , the index position becomes 0 .When the index was pointing to the deleted node , which was the last item in the collection , the index will point to the new last node of the collection and the index of inner repeats is reinitialized .", "label": "", "metadata": {}}
{"text": "To re - initialize a repeat index means to change its value to be equal to startindex , or to the size of the homogeneous collection if it contains less than startindex items .Required XPath expression that evaluates to a 1-based offset into the sequence .The evaluation context is determined in the same manner as the evaluation context for a Single - Node Binding ( see 7.4 Evaluation Context ) .If the selected index is 0 or less , an xforms - scroll - first event is dispatched and the index is set to 1 .", "label": "", "metadata": {}}
{"text": "if the index evaluates to NaN the action has no effect .The indexes for inner nested repeat collections are re - initialized to startindex .The implementation data structures for tracking computational dependencies are rebuilt or updated as a result of this action .Note : .The IDREF from the repeat attribute may not uniquely identify the desired repeat if the repeat element bearing the matching ID resides within the content of another repeat .The general method described in 4.7 Resolving ID References in XForms is used to determine the desired run - time repeat object .", "label": "", "metadata": {}}
{"text": "The markup contained within the body of element repeat specifies the user interface to be generated for each member of the underlying collection .During user interface initialization ( see 4.2.2The xforms - model - construct - done Event ) , the following steps are performed for repeat : .The Node Set Binding is evaluated to locate the homogeneous collection to be operated on by this repeat .The index for this repeating structure is initialized to the value of startindex .if the initial startindex is less than 1 it defaults to 1 .If the index is greater than the initial node - set then it defaults to the size of the node - set .", "label": "", "metadata": {}}
{"text": "The processing model for repeating structures uses an index that points to the current item in the instance data .This repeat index is accessed via XForms function index 7.8.5The index ( ) Function and manipulated via XFormsAction setindex 9.3.7 The setindex Element .This index is used as a reference point for insert and delete operations .Notice that the contained XForms form controls inside element repeat do not explicitly specify the index of the collection entry being populated .This is intentional ; it keeps both authoring as well as the processing model simple .The binding expression attached to the repeating sequence returns a node - set of the collection being populated , not an individual node .", "label": "", "metadata": {}}
{"text": "Repeat processing uses XPath expressions to address the collection over which element repeat operates .The form controls appearing inside repeat need to be suitable for populating individual items of the collection .A simple but powerful consequence of the above is that if the XFormsModel specifies nested collections , then a corresponding user interface can nest repeat elements .9.3.9 Nested Repeats .It is possible to nest repeat elements to create more powerful user interface for editing structured data .G.2 Editing Hierarchical Bookmarks Using XForms is an example of a form using nested repeats to edit hierarchical data consisting of bookmarks within multiple sections .", "label": "", "metadata": {}}
{"text": "Repeat Index and Nested Repeats .The above insert statement is used in that example to add new bookmark entries into the currently selected section .The inner ( nested ) repeat operates on bookmarks in this selected section ; The index - as returned by XForms function index -for this inner repeat starts at 1 .Hence , after a new empty section of bookmarks is created and becomes current , the first insert bookmark operation adds the newly created bookmark at the front of the list .9.3.10 User Interface Interaction .Element repeat enables the binding of user interaction to a homogeneous collection .", "label": "", "metadata": {}}
{"text": "In this case , the presentation would render only a portion of the repeating items at a given time .For example , a graphical user interface might present a scrolling table .The current item indicated by the repeat index should be made available to the user at all times , for example , not allowed to scroll out of view .The XForms Actions enumerated at 10 XFormsActions may be used within event listeners to manipulate the homogeneous collection being populated by scrolling , inserting , and deleting entries .Notice that the markup encapsulated by element repeat acts as the template for the user interface that is presented to the user .", "label": "", "metadata": {}}
{"text": "Based on the IDREF resolution rules given in 4.7 Resolving ID References in XForms , it is possible to toggle the case of a switch even when it is within one or more repeat elements .Similarly , it is possible to set the focus to controls and dispatch events to elements that are within one or more repeat elements .If the focus is transferred to a control within a repeat by any means , such as by an XForms action or by user interaction , the index of the repeat is changed to indicate the item of the homogeneous collection that contains the control .", "label": "", "metadata": {}}
{"text": "10 XForms Actions .This chapter defines an XML Events - based [ XML Events ] common set of actions that can be invoked in response to events .Note : .XForms itself defines no method for script - based event handling .The definition of such facilities is a responsibility of the hosting language .10.1 The XForms Action Module .All form controls defined in this specification have a set of common behaviors that encourage consistent authoring and look and feel for XForms - based applications .This consistency comes from attaching a common set of behaviors to the various form controls .", "label": "", "metadata": {}}
{"text": "XFormsActions are declarative XML event handlers that capture high - level semantics .As a consequence , they significantly enhance the accessibility of XForms - based applications in comparison to previous Web technologies that relied exclusively on scripting .This module also defines the content set \" Action \" , which includes the following elements ( of these , toggle comes from the XFormsSwitch module , and insert , delete , and setindex come from the XForms Repeat module ) : .Additionally , this module defines the attribute group \" XML Events \" , which includes all of the \" global \" attributes defined in that specification ( [ XML Events ] ) .", "label": "", "metadata": {}}
{"text": "Action Syntax .Reset .This example recreates the behavior of the HTML reset control , which this specification does not define as an independent form control .For each built - in XFormsAction , this chapter lists the following : .Name Common Attributes Special Attributes Description of behavior .All elements defined in this chapter explicitly allow global attributes from the XML Events namespace , and apply the processing defined in that specification in section 2.3 [ XML Events ] .An outermost action handler is an action that is activated when the XForms processor is not executing any other action handlers .", "label": "", "metadata": {}}
{"text": "An inner action handler may be within the content of the outermost action handler , or it may be executed as the response to an event dispatched while performing all of the actions initiated by the outermost action handler .Deferred Updates : Sequences of one or more XFormsActions have a deferred effect on XForms model and user interface processing .Execution of an outermost action handler begins by setting the XForms processor into the state of executing an outermost action handler .The outermost action handler is then performed , which may include the execution of inner action handlers .", "label": "", "metadata": {}}
{"text": "Note : .The XForms processor is not considered to be executing an outermost action handler at the time that it performs deferred update behavior for XForms models .Therefore , event handlers for events dispatched to the user interface during the deferred refresh behavior are considered to be new outermost action handler .Actions that directly invoke rebuild , recalculate , revalidate , or refresh always have an immediate effect , and clear the corresponding deferred update flag .The XForms Actions in this category are : . rebuild recalculate revalidate refresh .XFormsActions that change the tree structure of instance data result in setting all four deferred update flags to true for the model over which they operate .", "label": "", "metadata": {}}
{"text": "XFormsActions that change only the value of an instance node results in setting the deferred update flags for recalculate , revalidate , and refresh to true and making no change to the deferred update flag for rebuild for the model over which they operate .The XForms Actions in this category are : . setvalue .Finally , the reset action clears all of the deferred update flags for a model .Similarly , if the default processing of xforms - submit replaces instance data in a model , then the deferred update flags for that model are cleared immediately before the behaviors are peformed for xforms - rebuild , xforms - recalculate , xforms - revalidate , and xforms - refresh . 10.1.1", "label": "", "metadata": {}}
{"text": "This action causes its child actions to be invoked in the order that they are specified in the document .Optional boolean indicating if this event bubbles - as defined in [ DOM2 Events ] .The default value is true for a custom event .For predefined events , this attribute has no effect . cancelable .Optional boolean indicating if this event is cancelable - as defined in [ DOM2 Events ] .The default value is true for a custom event .For predefined events , this attribute has no effect .Note : .The IDREF obtained from the target attributemay not uniquely identify the desired target object if the element bearing the matching ID resides in a repeating construct such as element repeat .", "label": "", "metadata": {}}
{"text": "The rebuild Element .This action causes the processing of xforms - rebuild to happen , bypassing the normal event flow ( i.e. the behavior occurs without dispatching the xforms - rebuild event ) .This action results in the XFormsProcessor rebuilding any internal data structures used to track computational dependencies among instance data nodes -see 4.3.7 The xforms - rebuild Event .This action causes the processing of xforms - recalculate to happen , bypassing the normal event flow ( i.e. the behavior occurs without dispatching the xforms - recalculate event ) .As a result , instance data nodes whose values need to be recalculated are updated as specified in the processing model - see 4.3.6 The xforms - recalculate Event .", "label": "", "metadata": {}}
{"text": "This results in the instance data being revalidated as specified by the processing model - see 4.3.5 The xforms - revalidate Event .This action causes the processing of xforms - refresh to happen , bypassing the normal event flow ( i.e. the behavior occurs without dispatching the xforms - refresh event ) .This action results in the XForms user interface being refreshed , and the presentation of user interface controls being updated to reflect the state of the underlying instance data - see 4.3.4 The xforms - refresh Event .This action dispatches an xforms - focus event ( 4.3.2 The xforms - focus Event ) to the element identified by attribute control .", "label": "", "metadata": {}}
{"text": "Setting focus to a repeating structure sets the focus to the repeat item represented by the repeat index .Note : .The IDREF obtained from the control attribute may not uniquely identify the desired form control if the element bearing the matching ID resides in a repeating construct such as element repeat .The general method described in 4.7 Resolving ID References in XForms is used to determine the desired form control .Optional .Link to external resource to load , defined as an [ XLink 1.0 ] link between this element and the remote resource indicated .", "label": "", "metadata": {}}
{"text": "The XLink show value depends on the show attribute .If the link traversal fails , it is treated as an error ( 4.5.3 The xforms - link - error Event ) .show .Optional link behavior specifier .if this attribute is missing , a default value of \" replace \" is assumed .Either the Single - Node Binding attributes , pointing to a URI in the instance data , or the resource attribute is required .If both the Single - Node Binding and the resource attribute are present , the action has no effect .", "label": "", "metadata": {}}
{"text": "Possible values for attribute show have the following processing for the document ( or portion of a document ) reached by traversing the link : . new .The document is loaded into a new presentation context , e.g. , a new window .Form processing in the original window continues . replace .The document is loaded into the current window .Form processing is interrupted , exactly as if the user had manually requested navigating to a new document . 10.1.9The setvalue Element .This action explicitly sets the value of the specified instance data node .", "label": "", "metadata": {}}
{"text": "Optional XPath expression to evaluate , with the result stored in the selected instance data node .The evaluation context for this XPath expression is the result from the Single Node Binding .The element content of setvalue specifies the literal value to set ; this is an alternative to specifying a computed value via attribute value .The following two examples contrast these approaches : . setvalue with Expression . setvalue with Literal .If neither a value attribute nor text content are present , the effect is to set the value of the selected node to the empty string ( \" \") .", "label": "", "metadata": {}}
{"text": "All strings are inserted into the instance data as follows : .Element nodes : If the element has any child text nodes , the first text node is replaced with one corresponding to the new value .If no child text nodes are present , a text node is created , corresponding to the new value , and appended as the first child node .Attribute nodes : The string - value of the attribute is replaced with a string corresponding to the new value .Text nodes : The text node is replaced with a new one corresponding to the new value .", "label": "", "metadata": {}}
{"text": "This action initiates reset processing by dispatching an xforms - reset event to the specified model .Processing of event xforms - reset is defined in the processing model - see 4.3.8 The xforms - reset Event .This specification does not define behavior for QName values .The message specified can exist in instance data , in a remote document , or as inline text .If more than one source of message is specified in this element , the order of precedence is : single node binding attributes , linking attributes , inline text .The user interface for the message action is considered to be created at the time the action occurs .", "label": "", "metadata": {}}
{"text": "For example , the following example displays the message Hello , world ! as the form starts up : .John world Hello , !In this example , the message includes the latest user input even though other form controls not in the message action are not guaranteed to be updated until the end of the xforms - refresh event processing : .Enter birthday : is n't a valid birthday .Note : .A graphical browser might render a modal message as follows : .This is not a drill !XForms is designed to gather instance data , serialize it into an external representation , and submit it with a protocol .", "label": "", "metadata": {}}
{"text": "The following sections define the processing of instance data for submission , and the behavior for the serialization and submission options .11.1 The xforms - submit Event .Submission begins with the default action for a xforms - submit event .Target : submission .Bubbles : Yes .Cancelable : Yes .Context Info : None .Under no circumstances may more than a single concurrent submit process be under way for a particular XForms submission .From the start of the default action of xforms - submit , until the completion of the default action for xforms - submit - done or xforms - submit - error , the default action for subsequent xforms - submit events is to do nothing .", "label": "", "metadata": {}}
{"text": "The data model is updated .Specifically , if the deferred update rebuild flag is set for the model containing this submission , then the rebuild operation is performed without dispatching an event to invoke the operation .Then , if the deferred update recalculate flag is set for the model containing this submission , then the recalculate operation is performed without dispatching an event to invoke the operation .Performing the operations clears the flags .A node from the instance data is selected , based on attributes on the submission element .If the attributes of submission select an empty nodeset , a non - relevant node or a non - element node , then submission processing is stopped after dispatching event xforms - submit - error .", "label": "", "metadata": {}}
{"text": "Any node which is considered not relevant as defined in 6.1.4 The relevant Property is removed .All selected instance data nodes are checked for validity according to the definition in 4.3.5 The xforms - revalidate Event ( no notification events are marked for dispatching due to this operation ) .Any selected instance data node that is required but empty or found to be invalid stops submission processing after dispatching event xforms - submit - error .For a success response including a body , when the value of the replace attribute on element submission is \" all \" , the event xforms - submit - done is dispatched , and submit processing concludes with entire containing document being replaced with the returned body .", "label": "", "metadata": {}}
{"text": "An xforms - link - exception ( 4.5.2 The xforms - link - exception Event ) occurs if the parse fails .If the parse succeeds , then all of the internal instance data of the instance indicated by the instance attribute setting is replaced with the result .Once the XML instance data has been replaced , the rebuild , recalculate , revalidate and refresh operations are performed on the model , without dispatching events to invoke those four operations .This sequence of operations affects the deferred update behavior by clearing the deferred update flags associated with the operations performed .", "label": "", "metadata": {}}
{"text": "For a success response including a body , when the value of the replace attribute on element submission is \" none \" , submit processing concludes after dispatching xforms - submit - done .For a success response not including a body , submit processing concludes after dispatching xforms - submit - done .Behaviors of other possible values for attribute replace are not defined in this specification .For an error response nothing in the document is replaced , and submit processing concludes after dispatching xforms - submit - error .11.2 Submission Options .The XForms Model specifies a submission element containing the following attributes that affect serialization and submission .", "label": "", "metadata": {}}
{"text": "( See 3.3.3 The submission Element for additional submission attributes that affect serialization . ) action ( xsd : anyURI ) .method ( xsd : string , enumerated below ) .For the URI scheme of action , XForms normatively defines a binding to HTTP/1.1 [ RFC 2616 ] .Note : .Other bindings , in particular to the URI scheme \" mailto : \" may , and the schemes \" https : \" and \" file : \" should , be supported .Bindings to these schemes are not normatively defined in XForms .Implementations that choose to provide a binding to these schemes should pay particular attention to privacy and security concerns .", "label": "", "metadata": {}}
{"text": "The method attribute determines the serialization format , and the URI scheme used in the action attribute determines the submit protocol , according to the following table : .HTTP POST or equivalent .( any ) .any other QNAME with no prefix .N / A .N / A .( any ) .any QNAME with a prefix .implementation - defined .implementation - defined .Note : .Foreign - namespaced attributes are allowed on element submission , but no behavior is defined by XForms 1.0 .11.3 Serialization as application / xml .", "label": "", "metadata": {}}
{"text": "In addition , this format is capable of submission of binary content .The steps for serialization are as follows : .An XML document is produced following the rules of the XML output method defined in [ XSLT 1.0 ] section 16 and 16.1 , using the values supplied as attributes of the submission element .Handling of namespace nodes : The default behavior is that every namespace node is serialized according to the rules of the XML output method , so that at least one namespace declaration appears in the serialized XML for each in - scope namespace .", "label": "", "metadata": {}}
{"text": "The special value # default represents the default namespace .Mediatype : By default , the mediatype of the serialized XML instance is application / xml , but can be changed to a compatible type using element submission attribute mediatype .Authors should ensure that the type specified is compatible with application / xml .11.4 Serialization as multipart / related .This format is intended for integration of XForms into environments that involve large amounts of binary data where the inclusion of the data as xsd : base64Binary or xsd : hexBinary is undesirable .One part for each node with a datatype of xsd : anyURI populated by upload with : .", "label": "", "metadata": {}}
{"text": "A Content - Transfer - Encoding header .A Content - ID header whose value matches the URI in the associated instance data node .The binary content associated with the URI , serialized according to the Content - Transfer - Encoding heading .multipart / related .11.5 Serialization as multipart / form - data .This format is for legacy compatibility to permit the use of XForms clients with [ RFC 2388 ] servers .This method is suitable for the persistence of binary content .Contextual path information , attribute values , namespaces and namespace prefixes are not preserved .", "label": "", "metadata": {}}
{"text": "Note : .Existing HTML user agents fail to encode special characters ( such as double quotes ) and non - ASCII characters in the Content - Disposition : form - data name and filename parameters .Since this serialization method is supported for legacy applications only , new applications should use application / xml or multipart / related .This format follows the rules for multipart / form - data MIME data streams in [ RFC 2388 ] , with specific requirements of this serialization listed below : .Each element node is visited in document order .Each element that has exactly one text node child is selected for inclusion .", "label": "", "metadata": {}}
{"text": "Element nodes of any datatype populated by upload are serialized as the specified content and additionally have a Content - Disposition filename parameter , if available .The Content - Type must be text / plain except for xsd : base64Binary , xsd : hexBinary , and derived types , in which case the header represents the media type of the attachment if known , otherwise application / octet - stream .If a character set is applicable , the Content - Type may have a charset parameter .Example : . multipart / form - data .It has two lines .", "label": "", "metadata": {}}
{"text": "This format represents an extension of the [ XHTML 1.0 ] form content type application / x - www - form - urlencoded with specific rules for encoding non - ASCII and reserved characters .This format is not suitable for the persistence of binary content .Therefore , it is recommended that forms capable of containing binary content use another serialization method .The steps for serialization are as follows : .Each element node is visited in document order .Each element that has one text node child is selected for inclusion .Note that attribute information is not preserved .", "label": "", "metadata": {}}
{"text": "As a result , different elements might serialize to the same name .Line breaks are represented as \" CR LF \" pairs ( i.e. , % 0D%0A ) .All such encodings are concatenated , maintaining document order .Example : . application / x - www - form - urlencoded .This format consists of simple name - value pairs .Ren\u00e9 .Here is the instance data for the above example .Note that very little of the data is preserved .Authors desiring greater data integrity should select a different serialization format .11.7 The post , multipart - post , form - data - post , and urlencoded - post Submit Methods .", "label": "", "metadata": {}}
{"text": "The serialized form data is delivered as the message body .11.8 The put Submit Method .This submit method represents HTTP PUT or the equivalent concept ( such as writing to a local file ) .The serialized form data is delivered as the message body .11.9 The get Submit Method .This submit method represents HTTP GET or the equivalent concept .The serialized form data is delivered as part of the URI that is requested during the submit process .This method is not suitable for submission of forms that are intended to change state or cause other actions to take place at the server .", "label": "", "metadata": {}}
{"text": "The URI is constructed as follows : .The submit URI from the action attribute is examined .If it does not already contain a ?( question mark ) character , one is appended .If it does already contain a question mark character , then a separator character from the attribute separator is appended .The serialized form data is appended to the URI .No message body is sent with the request .12 Conformance .12.1 Conformance Levels .The XForms specification is intended for implementation on hardware platforms of all sizes , from tiny hand - held devices to high - powered servers .", "label": "", "metadata": {}}
{"text": "XFormsFull .This conformance level is suitable for more powerful forms processing , such as might be found on a standard desktop browser or a distributed XFormsProcessor involving server - side components .XFormsFull implementations must return \" full \" from the property method ( defined at 7.9.1The property ( ) Function ) called with the \" conformance - level \" parameter string . 12.2.1Conforming XFormsProcessors .All XFormsProcessors must conform to the following specifications , except as qualified below : .All XFormsProcessors must fully support the following XForms modules : Core ; MustUnderstand ; Form Controls ; Group ; Switch ; Repeat ; and Action .", "label": "", "metadata": {}}
{"text": "Processors must also support : the XFormsProcessing Model and all events listed at 4 Processing Model ; the http scheme for processing xsd : anyURI ; all serialization methods defined at 11 Submit .A host language may introduce additional conformance requirements .XFormsFull Processors must implement all required features defined in this specification . 12.2.2Conforming XFormsDocuments .All XFormsContaining Documents must conform to the following specifications , except as qualified below : .XForms elements are typically inserted into a containing document in multiple places .The root element for each individual fragment must be model , a form control , group , repeat , or switch .", "label": "", "metadata": {}}
{"text": "( A Schema for XForms ) .A host language may introduce additional conformance requirements .All XForms Full conforming documents must conform to all required portions of this specification .Binding .[ Definition : A \" binding \" connects an instance data node to a form control or to a model item constraint by using a binding expression as a locater . ][ Definition : An [ XPath 1.0 ] expression used by model item properties such as relevant and calculate to include dynamic functionality in XForms . ]Containing document .Datatype .Facet .[ Definition : From XML Schema [ XML Schema part 2 ] : A single defining aspect of a value space .", "label": "", "metadata": {}}
{"text": "] First node rule .Form control .[ Definition : An XForms user interface control that serves as a point of user interaction . ] Host language .[ Definition : An XML vocabulary , such as XHTML , into which XForms is embedded . ] Instance data .[ Definition : An internal tree representation of the values and state of all the instance data nodes associated with a particular form . ][ Definition : A string consisting of a non - zero digit ( 1 to 9 ) followed by zero or more digits ( 0 to 9 ) , then a period character ( . ) , and then one or more digits ( 0 - 9 ) .", "label": "", "metadata": {}}
{"text": "[ Definition : The non - visible definition of an XML form as specified by XForms .The XForms Model defines the individual model items and constraints and other run - time aspects of XForms .] XForms Processor .[ Definition : A software application or program that implements and conforms to the XForms specification . ] P3P privacy policies may be associated with any forms transmitted over HTTP that have URIs associated with them .In the future , mechanisms may be specified for associating P3P policies with content transmitted over other protocols .P3P allows for policies to be associated with an individual URI or a set of URIs .", "label": "", "metadata": {}}
{"text": "However , site management is substantially easier for many sites if they declare a single policy that covers many URIs , or even their entire Web presence .The P3P specification specifies several methods for referencing a P3P policy reference file , which in turn associates P3P policies with URIs and cookies .XForms can be P3P enabled using any of the methods that are appropriate for the Web site in which they are embedded .Some special considerations regarding forms are addressed in the P3P Specification .[ P3P 1.0 ] .Different P3P policies may be applied to the representation of a form embedded in a containing document to that which is associated with the data submitted via that form .", "label": "", "metadata": {}}
{"text": "Typically the form representation causes only clickstream data ( as defined in [ P3P 1.0 ] section 5.6.4 ) to be transferred , while a form submission causes much more data to be transferred .D Recalculation Sequence Algorithm .XFormsProcessors are free ( and encouraged ) to skip or optimize any steps in this algorithm , as long as the end result is the same .The XForms recalculation algorithm considers model items and model item properties to be vertices in a directed graph .Edges between the vertices represent computational dependencies between vertices .To provide consistent behavior , implementations must reduce the number of vertices to be processed by computing a pertinent dependency subgraph consisting only of vertices and edges that are reachable from nodes that require recomputation .", "label": "", "metadata": {}}
{"text": "Note that on a first recomputation ( such as on form load ) , the pertinent dependency subgraph will be the same as the master dependency directed graph .A topological sort is performed on the vertices of the pertinent dependency subgraph , resulting in an order of evaluation in which each vertex is evaluated only after those vertices on which it depends and before all vertices which depend on it .The topological sort algorithm is discussed at [ Algorithms ] .The recalculate process completes .D.1 Details on Creating the Master Dependency Directed Graph .The master dependency directed graph can be considered an array with one record for each vertex , each having the following fields : .", "label": "", "metadata": {}}
{"text": "Any expression violating any Binding Expression Constraint causes an exception ( 4.5.4 The xforms - compute - exception Event ) , terminating the recalculate process .The depList for a vertex v is assigned to be the vertices other than v whose computational expressions reference v ( described below ) .Vertex v is excluded from its own depList to allow self - references to occur without causing a circular reference exception .A computational expression appearing in a calculate attribute controls the text content ( value ) of one or more instance nodes .A vertex exists for each instance node to represent the expression in the context of the node .", "label": "", "metadata": {}}
{"text": "The computational expression of each vertex must be examined to determine the XML nodes to which it refers .Any expression violating any Binding Expression Constraint causes an exception ( 4.5.4 The xforms - compute - exception Event ) , terminating the recalculate process .A computation expression refers to a vertex v if a subexpression indicates the InstanceNode for v and v represents the instance node text content ( its value ) .In this version of XForms , model item properties such as readOnly and required can not be referenced in an expression .D.2 Details on Creating the Pertinent Dependency Subgraph .", "label": "", "metadata": {}}
{"text": "The method of path exploration can be depth first search , a suitable version of which appears in the pseudo - code below .Sample Algorithm to Create the Pertinent Dependency Subgraph .Variables such as v and w represent vertices in the master dependency directed graph .The same variables ending with S indicate vertices in the pertinent dependency subgraph S .// Use depth - first search to explore master digraph subtrees rooted at // each changed vertex .A ' visited ' flag is used to stop exploration // at the boundaries of previously explored subtrees ( because subtrees // can overlap in directed graphs ) .", "label": "", "metadata": {}}
{"text": "Push the pair ( NIL , r ) onto a stack .while the stack is not empty .if w is not visited .Set the visited flag of w to true .Create a vertex wS in S to represent w .Set the index of w equal to the array location of wS .Set the index of wS equal to the array location of w .Set the InstanceNode of wS equal to the InstanceNode of w .Set the type of wS equal to the type of w .For each dependency node x of w .", "label": "", "metadata": {}}
{"text": "Obtain vS from index of v .Add dependency node for wS to vS .// Now clear the visited flags set in the loop above .for each vertex vS in S .Obtain v from index of vS .D.3 Details on Computing Individual Vertices .The following steps process vertices , resulting in a recalculated form : .A vertex with inDegree of 0 is selected for evaluation and removed from the pertinent dependency subgraph .In the case where more than one vertex has inDegree zero , no particular ordering is specified .If the pertinent dependency subgraph contains vertices , but none have an inDegree of 0 , then the calculation structure of the form has a loop , and an exception ( 4.5.4 The xforms - compute - exception Event ) must be thrown , terminating processing .", "label": "", "metadata": {}}
{"text": "For each vertex in the depList of the removed vertex , decrement the inDegree by 1 .If no vertices remain in the pertinent dependency subgraph , then the calculation has successfully completed .Otherwise , repeat this sequence from step 1 .D.4 Example of Calculation Processing .For example , consider six vertices a , b , v , w , x , and y .Let a and b represent the text content of instance nodes that will be set by a binding from user input controls .Let v and w be vertices representing the calculated value and the validity property of a third instance node c .", "label": "", "metadata": {}}
{"text": "Suppose that the value of c is the product of a and b and that the value is only valid if it does not exceed 100 .Likewise , suppose x and y are vertices representing the calculated value and the validity property of a fourth instance node d .Let the value of d be the sum of a and b , and let d be valid if the value does not exceed 20 .The figure below depicts the dependency digraph for this example .Vertices a and b have edges leading to v and x because these vertices represent the calculate expressions of c and d , which reference a and b to compute their product and sum , respectively .", "label": "", "metadata": {}}
{"text": "If a and b are initially equal to 10 , and the user changes a to 11 , then it is necessary to first recalculate v ( the value of c ) then recalculate w ( the validity property of the value of c ) .Likewise , x ( the value of d ) must be recalculated before recalculating y ( the validity property of the value of d ) .In both cases , the validity of the value does not change to false until after the new product and sum are computed based on the change to a .", "label": "", "metadata": {}}
{"text": "The pertinent subgraph excludes b and only vertex a has in - degree of zero .The vertex a is processed first .It is not a computed vertex , so no recalculation occurs on a , but its removal causes v and x to have in - degree zero .Vertex v is processed second .Its value changes to 121 , and its removal drops the in - degree of vertex w to zero .Vertex x is processed next , changing value to 21 .When x is removed , its neighbor y drops to in - degree zero .", "label": "", "metadata": {}}
{"text": "E Input Modes .The attribute inputmode provides a hint to the user agent to select an appropriate input mode for the text input expected in an associated form control .The input mode may be a keyboard configuration , an input method editor ( also called front end processor ) or any other setting affecting input on the device(s ) used .Using inputmode , the author can give hints to the agent that make form input easier for the user .Authors should provide inputmode attributes wherever possible , making sure that the values used cover a wide range of devices .", "label": "", "metadata": {}}
{"text": "The value of the inputmode attribute is a white space separated list of tokens .Tokens are either sequences of alphabetic letters or absolute URIs .The later can be distinguished from the former by noting that absolute URIs contain a ' : ' .Tokens are case - sensitive .All the tokens consisting of alphabetic letters only are defined in this specification , in E.3 List of Tokens ( or a successor of this specification ) .This specification does not define any URIs for use as tokens , but allows others to define such URIs for extensibility .", "label": "", "metadata": {}}
{"text": "The URI should dereference to a human - readable description of the input mode associated with the use of the URI as a token .This description should describe the input mode indicated by this token , and whether and how this token modifies other tokens or is modified by other tokens .E.2 User Agent Behavior .Upon entering an empty form control with an inputmode attribute , the user agent should select the input mode indicated by the inputmode attribute value .User agents should not use the inputmode attribute to set the input mode when entering a form control with text already present .", "label": "", "metadata": {}}
{"text": "User agents should make available all the input modes which are supported by the ( operating ) system / device(s ) they run on / have access to , and which are installed for regular use by the user .This is typically only a small subset of the input modes that can be described with the tokens defined here .Note : .Additional guidelines for user agent implementation are found at [ UAAG 1.0 ] .The following simple algorithm is used to define how user agents match the values of an inputmode attribute to the input modes they can provide .", "label": "", "metadata": {}}
{"text": "The algorithm is not designed to produce \" obvious \" or \" desirable \" results for every possible combination of tokens , but to produce correct behavior for frequent token combinations and predictable behavior in all cases .First , each of the input modes available is represented by one or more lists of tokens .An input mode may correspond to more than one list of tokens ; as an example , on a system set up for a Greek user , both \" greek upperCase \" and \" user upperCase \" would correspond to the same input mode .", "label": "", "metadata": {}}
{"text": "Second , the inputmode attribute is scanned from front to back .For each token t in the inputmode attribute , if in the remaining list of tokens representing available input modes there is any list of tokens that contains t , then all lists of tokens representing available input modes that do not contain t are removed .If there is no remaining list of tokens that contains t , then t is ignored .Third , if one or more lists of tokens are left , and they all correspond to the same input mode , then this input mode is chosen .", "label": "", "metadata": {}}
{"text": "E.3 List of Tokens .Tokens defined in this specification are separated into two categories : Script tokens and modifiers .In inputmode attributes , script tokens should always be listed before modifiers .E.3.1 Script Tokens .Script tokens provide a general indication the set of characters that is covered by an input mode .In most cases , script tokens correspond directly to [ Unicode Scripts ] .Some tokens correspond to the block names in Java class java.lang.Character.UnicodeBlock ( [ Java Unicode Blocks ] ) or Unicode Block names .However , this neither means that an input mode has to allow input for all the characters in the script or block , nor that an input mode is limited to only characters from that specific script .", "label": "", "metadata": {}}
{"text": "The version of the Unicode Standard that these script names are taken from is 3.2 .Comments .arabic .Unicode script name .armenian .Unicode script name .bengali .Unicode script name .bopomofo .Unicode script name . braille .used to input braille patterns ( not to indicate a braille input device ) .Unicode script name .hangul .Unicode script name . hanja .Subset of ' han ' used in writing Korean . hanunoo .Unicode script name .hebrew .Unicode script name .hiragana .Unicode script name ( may include other Japanese scripts produced by conversion from hiragana ) .", "label": "", "metadata": {}}
{"text": "thaana .Unicode script name .thai .Unicode script name . tibetan .Unicode script name . traditionalHanzi .Subset of ' han ' used in writing Traditional Chinese . user .Special value denoting the ' native ' input of the user ( e.g. to input her name or text in her native language ) .yi .Unicode script name . E.3.2Modifier Tokens .Modifier tokens can be added to the scripts they apply in order to more closely specify the kind of characters expected in the form control .Traditional PC keyboards do not need most modifier tokens ( indeed , users on such devices would be quite confused if the software decided to change case on its own ; CAPS lock for upperCase may be an exception ) .", "label": "", "metadata": {}}
{"text": "Input Mode Token .Comments .lowerCase . lowercase ( for bicameral scripts ) .upperCase . uppercase ( for bicameral scripts ) .titleCase . title case ( for bicameral scripts ) : words start with an upper case letter .startUpper . start input with one uppercase letter , then continue with lowercase letters . symbols .symbols , punctuation ( suitable for a particular script ) .predictOn . text prediction switched on ( e.g. for running text ) .predictOff . text prediction switched off ( e.g. for passwords ) .halfWidth .half - width compatibility forms ( e.g. Katakana ; deprecated ) .", "label": "", "metadata": {}}
{"text": "User agents may use information available in an XML Schema pattern facet to set the input mode .Note that a pattern facet is a hard restriction on the lexical value of an instance data node , and can specify different restrictions for different parts of the data item .Attribute inputmode is a soft hint about the kinds of characters that the user may most probably start to input into the form control .Attribute inputmode is provided in addition to pattern facets for the following reasons : .The set of allowable characters specified in a pattern may be so wide that it is not possible to deduce a reasonable input mode setting .", "label": "", "metadata": {}}
{"text": "In such a case , inputmode allows to set the input mode for the user 's convenience .In some cases , it would be possible to derive the input mode setting from the pattern because the set of characters allowed in the pattern closely corresponds to a set of characters covered by an inputmode attribute value .However , such a derivation would require a lot of data and calculations on the user agent .Small devices may leave the checking of patterns to the server , but will easily be able to switch to those input modes that they support .", "label": "", "metadata": {}}
{"text": "E.5 Examples .This is an example of a form for Japanese address input .It is shown in table form ; it will be replaced by actual syntax in a later version of this specification .hiragana .( in kana ) .katakana .Email . latin lowerCase .Telephone . latin digits .Comments . user predictOn .F XForms and Styling ( Non - Normative ) .This informative section provides a broad outline of new and existing CSS features needed to style XForms content .A future Recommendation from the CSS Working Group will fully develop the specification of these features .", "label": "", "metadata": {}}
{"text": "A CSS pseudo - class is used to select elements for styling based on information that lies outside of the document tree or that can not be expressed using the other selectors .Name .Defined in : .Relationship to XForms .: enabled & : disabled .[ CSS3 ] .Selects any form control bound to a node with the model item property relevant evaluating to true or false ( respectively ) .: required & : optional .TBD .Selects any form control bound to a node with the model item property required evaluating to true or false ( respectively ) .", "label": "", "metadata": {}}
{"text": "TBD .Selects any form control bound to a node that is currently valid or invalid ( respectively ) , as defined by XForms 1.0 .: read - only & : read - write .TBD .Selects any form control bound to a node with the model item property readonly evaluating to true or false ( respectively ) .: out - of - range & : in - range .TBD .Selects any form control bound to a node that contains a value the form control is not or is capable of rendering , ( respectively ) .", "label": "", "metadata": {}}
{"text": "F.2 Pseudo - elements .Pseudo - elements are abstractions about the document tree beyond those specified by the document language .Pseudo - elements do not appear in the DOM ; they are used only for purposes of styling .Name .Defined in : .Relationship to XForms .: : value .TBD .Represents the \" active \" area of a form control excluding the label ; this corresponds in HTML to input and other form control elements .This pseudo - element is a child of the form control element , and appears immediately after the required label element .", "label": "", "metadata": {}}
{"text": "TBD .Represents a single item from a repeating sequence .Its position is as a parent to all the elements in a single repeating item .Each : : repeat - item is associated with a particular instance data node , and is affected by the model item properties ( e.g. ' relevant ' ) found there , as the related style properties will cascade to the child elements .: : repeat - index .TBD .Represents the current item of a repeating sequence .Its position is as a parent of all the elements in the index repeating item ( and as a child to the : : repeat - item pseudo - element ) , thus any style declarations applying to this pseudo - element override those on the parent : : repeat - item .", "label": "", "metadata": {}}
