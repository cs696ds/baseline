{"text": "Abstract .Background .Stochastic Context - Free Grammars ( SCFGs ) were applied successfully to RNA secondary structure prediction in the early 90s , and used in combination with comparative methods in the late 90s .The set of SCFGs potentially useful for RNA secondary structure prediction is very large , but a few intuitively designed grammars have remained dominant .In this paper we investigate two automatic search techniques for effective grammars - exhaustive search for very compact grammars and an evolutionary algorithm to find larger grammars .We also examine whether grammar ambiguity is as problematic to structure prediction as has been previously suggested .", "label": "", "metadata": {}}
{"text": "These search techniques were applied to predict RNA secondary structure on a maximal data set and revealed new and interesting grammars , though none are dramatically better than classic grammars .In general , results showed that many grammars with quite different structure could have very similar predictive ability .Many ambiguous grammars were found which were at least as effective as the best current unambiguous grammars .Conclusions .Overall the method of evolving SCFGs for RNA secondary structure prediction proved effective in finding many grammars that had strong predictive accuracy , as good or slightly better than those designed manually .", "label": "", "metadata": {}}
{"text": "Background .RNA secondary structure prediction is the process of predicting the position of hydrogen bonds in an RNA molecule based only on its nucleotide sequence .These predictions can be used to better understand the functioning of cells , characteristics of gene expression and the mechanisms involved in protein production [ 1 ] .Early attempts at systematic prediction include [ 2 ] ; who simply evaluated all possible structures with respect to free energy functions .Later , thermodynamic principles were used to advance free energy methods in algorithms such as UNAfold [ 3 ] and RNAfold [ 4 ] .", "label": "", "metadata": {}}
{"text": "Whilst energy minimisation models have proved popular , SCFG based methods also have their merits .Stochastic Context Free Grammars .Each production rule replaces one non - terminal variable with a string of non - terminals and terminals .One possible grammar , generating strings which may be interpreted as addition / multiplication expressions using only the number 1 , may be represented thus : .The order in which the production rules are used forms the derivation of a string .Beginning with the start symbol and following production rules sampled from the relevant distribution , a string of terminal variables can be produced ( if the grammar terminates ) .", "label": "", "metadata": {}}
{"text": "Application of SCFGs to RNA Secondary Structure Prediction .The use of SCFGs in RNA secondary structure prediction was based on the success of Hidden Markov Models ( HMMs ) in protein and gene modelling [ 6 ] .Any attempt to apply HMMs to RNA secondary structure was prevented by the long - range interactions in RNA [ 7 ] .SCFGs , being generalisations of HMMs , offer a solution .This was first exploited by [ 8 ] and then developed by others ( e.g. [ 9 ] ) .The Pfold algorithm [ 10 , 11 ] is one of the most successful approaches using SCFGs .", "label": "", "metadata": {}}
{"text": "Pfold uses a SCFG designed specifically for RNA secondary structure prediction ( denoted KH99 in this paper ) .Therefore , when only considering a single sequence , Pfold is simply a SCFG prediction method .There are other approaches which predict secondary structures from aligned RNA sequences , such as RNAalifold [ 12 ] and Turbofold [ 13 ] .However , we are concerned with the single - sequence prediction problem , so these are not used here .While KH99 was effective , it seems to have been chosen relatively arbitrarily , in that there is little discussion about the motivation behind the choice of production rules .", "label": "", "metadata": {}}
{"text": "The set of grammars they tested , however , was by no means exhaustive .All of these grammars were constructed by hand and there was little motivation for their production rules ( except for the extension to stacking grammars : production rules such as for nucleotides ) .This suggested that a computational search of a large space of grammars might find stronger grammars , which is what we have attempted in this paper .Evolutionary approaches have already been implemented for HMMs .Indeed , [ 15 ] used one to find the best HMM for protein secondary structure prediction .", "label": "", "metadata": {}}
{"text": "It is hard to tell quite how conclusive the results were since the limited size of the data set forced training and testing to be done on the same data .Given the size of the data set , overtraining may have caused unreasonably high quality predictions .Clearly though , the method is potentially very powerful .Methods .Strings generated by these grammars uniquely define secondary structures , with a dot ' . 'representing an unpaired nucleotide and an opening parenthesis indicating pairing with its corresponding closing parenthesis .Once a structure is generated , a generative model for sequences is to stochastically allocate nucleotides to each site according to the frequency of occurrence ( paired and unpaired ) in some set of trusted sequences and structures .", "label": "", "metadata": {}}
{"text": "To develop algorithms for analysing sequences under grammatical models , it is convenient to restrict the grammar to a normal form , with only a few possible types of productions .The normal form most commonly used is Chomsky Normal Form ( CNF ) , as every context - free grammar is equivalent to one in CNF .However , a grammar in CNF can not introduce the corresponding parentheses of paired nucleotides in a single production , and therefore does not capture structure in a straightforward manner .Thus it was necessary to create a new double emission normal form ( so called because paired bases are emitted simultaneously ) which was able to capture the fundamental features of RNA secondary structure : branching , unpaired bases , and paired bases .", "label": "", "metadata": {}}
{"text": "This normal form allows the development of the structural motifs commonly found in RNA .Furthermore , with the exception of the ability to generate empty strings , this normal form allows the expression of dependencies of any context - free grammar producing valid structures .It was also designed to avoid cyclical productions ; that is , combinations of production rules which result in the same string that they started from .These are undesirable as they permit a countably infinite number of derivations for some strings .There is , however , nothing intrinsically wrong with these rules ; it is quite possible to create strong grammars with these rules present ( many of those used in [ 14 ] have rules of this type ) .", "label": "", "metadata": {}}
{"text": "As this normal form is an extension of CNF , any context - free grammar can be converted to this normal form , maintaining paired terminal symbol emissions .This produces the same strings , and a given probability distribution for stochastic grammars can even be conserved .However , the transformation will often change the set of parameters in the model , which may result in different predictions when the production rule probabilities are inferred .Secondary structure prediction .Secondary structure can be predicted by two methods , both of which are employed here .Firstly , one can find the maximum likelihood derivation of a sequence , during which a structure is generated .", "label": "", "metadata": {}}
{"text": "It is designed for grammars in CNF , though there are established methods of dealing with grammars in a different normal form [ 17 ] .Secondly , one can employ a posterior decoding method using base - pairing probability matrices .The base - pair probability matrix for a SCFG are obtained via the inside and outside algorithms [ 18 ] .The secondary structure with the maximum expected number of correct positions can then be calculated via dynamic programming .Our decoding algorithm follows [ 19 ] , including a \u03b3 parameter specifying the trade - off between correct base pairs relative to correct unpaired positions .", "label": "", "metadata": {}}
{"text": "Ambiguity and completeness .A grammar is said to be ambiguous if it produces more than one derivation for a given structure [ 20 ] .If structure A has one derivation with probability 0.3 , and structure B two derivations , each with probability 0.25 , the CYK algorithm will choose structure A , while structure B is more probable .This may reduce the quality of predictions using the CYK algorithm .The posterior decoding , though , sums over all derivations in prediction , so might be affected less by grammar ambiguity .Nine grammars are tested in [ 14 ] , of which two are ambiguous .", "label": "", "metadata": {}}
{"text": "Consequently , efforts have been made to avoid ambiguity [ 20 ] .The conclusion that ambiguous grammars are undesirable is not necessarily justified .The ambiguous grammars in [ 14 ] are small , with at most two non - terminal variables , and one might expect them to be ineffective regardless .Their poor predictive quality may be due to deficiency in design rather than ambiguity .We define a grammar to be complete if it has a derivation for all possible structures which have no hairpins shorter than length two .Clearly the ability to generate all structures is desirable for a grammar .", "label": "", "metadata": {}}
{"text": "Similarly , the posterior decoding is not prone to grammar incompletness in the same way that CYK is since , in theory , after obtaining the probabilities of unpaired and paired positions , structures which can not be derived with the grammar can still be predicted .One can perform a heuristic test for completeness by testing on a sample of strings .Ambiguity can also be checked for heuristically [ 20 ] , but determining grammar ambiguity and completeness is undecidable [ 21 ] .Practically , it is very difficult to ensure both unambiguity and completeness .A complete , unambiguous grammar can not be simply modified without compromising one of the properties .", "label": "", "metadata": {}}
{"text": "Equally , removing production rules will create incompleteness ( unless the rule is never used in a derivation ) , as the original grammar is assumed unambiguous .Because of this , an automated grammar design based on simple - step modification is practically impossible without creating ambiguous and incomplete grammars .Moreover , grammars that are unambiguous and complete are vastly outnumbered by grammars that are not .Therefore , grammars not possessing these desirable qualities must be considered and as a result our grammar search serves as a test of the capabilities of ambiguous or incomplete grammars .", "label": "", "metadata": {}}
{"text": "Training data , consisting of strings of nucleotides and trusted secondary structures , is used to obtain the probabilities associated with each production rule , as well as paired and unpaired nucleotide probabilities .If derivations are known for the training sequences , then there are simple multinomial maximum likelihood estimators for the probabilities .Usually , though , the derivation is unknown .Again , one can estimate probabilities by finding derivations for the training set using CYK , or by the inside and outside algorithms .For the CYK algorithm , in the case of ambiguous grammars , one can not know which derivation produced the known structure , so probabilities can not be obtained .", "label": "", "metadata": {}}
{"text": "That is , we randomly select one derivation .For unambiguous grammars , such as KH99 , this has no effect on the training .As with the prediction , inside - outside training works for unambiguous and ambiguous grammars alike .Again , both CYK and inside - outside were used for parameter inference in the search and evaluation .Evolutionary algorithm .An evolutionary algorithm would allow for efficient exploration of the space of grammars in the above normal form .The way that the algorithm searches the space is determined by the design of the initial population , mutation , breeding and selection procedure .", "label": "", "metadata": {}}
{"text": "Initial population .When forming the initial population , the size of the space of grammars quickly becomes problematic .The space is clearly large , even for small m , so the population size can not approach that usually afforded in evolutionary algorithms [ 22 ] .We start with an initial population of small grammars , and use mutation and breeding rules which grow the number of non - terminal variables and production rules .Our initial population comprised sixteen grammars , of the form : .We also tried initial populations containing the SCFGs from [ 14 ] to consider examining SCFGs close to these .", "label": "", "metadata": {}}
{"text": "Mutations constitute the majority of movement through the search space , so are particularly important .They give the grammar new characteristics , allow it more structural freedom , and add production rules which may be used immediately or may lie dormant .This form of mutation is very basic , but allows many structural features to develop over generations .The rate of mutation determines movement speed through the search space and development of these structural features .Adding rules too slowly prevents grammars from developing structure , while too many results in a lot of ambiguity and thus creates ineffective grammars .", "label": "", "metadata": {}}
{"text": "More complex mutation is clearly possible .The derivation could be used to find the rules used more often and make mutations of those rules more or less likely .A model for simultaneous mutations could be developed , which might be able to make use of expert understanding of RNA structure , in combination with an evolutionary search .We have found the above model to give sufficient mobility in the search space , and therefore did not investigate other extensions .Breeding .The breeding model forms a grammar which can produce all derivations of its parent grammars .", "label": "", "metadata": {}}
{"text": "This breeding model was chosen to keep the size of the grammar relatively small , whilst allowing expression of both bred grammars to be present in derivations .Selection .We grow the population in each generation by introducing a number of newly mutated or bred grammars , then we pare it back to a fixed population size by stochastic elimination .We determine the probability of elimination of a grammar by the inverse of some fitness measure .We also tried these accuracy measures in combination with other factors in the fitness function , including largest correctly predicted length , inability to predict structures , and cost for grammar complexity .", "label": "", "metadata": {}}
{"text": "In addition to the evolutionary algorithm , we have run a brute force search to evaluate small grammars which might be effective .One of the main points of emphasis of [ 14 ] was to look for lightweight grammars .In searching exhaustively for a small grammar , computational problems are quickly encountered .( 16,384 grammars ) but not for 3 non - terminals ( over 500 billion grammars ) .Whilst the search in three non - terminals may be worthwhile , especially since KH99 contains only 3 non - terminals , it was far from computationally feasible for the purposes of this paper .", "label": "", "metadata": {}}
{"text": "We took data from RNASTRAND [ 24 ] , a collection of other databases [ 25 - 31 ] .We filtered the data set so that the sequences and structures could ensure reliability of predictions .We removed identical sequences and disregarded synthetic data and sequences with ambiguous base pairs .We further cleaned the data to filter out any sequences with greater than 80 % base pair similarity with another structure ( the standard used in [ 14 ] ) .Furthermore , we removed all sequences with pseudoknots as it is well established that SCFGs can not predict pseudoknots [ 32 ] .", "label": "", "metadata": {}}
{"text": "The CYK and training algorithms are of cubic order in the length of the string , so we decided to use large training and test sets with small strings .Longer strings require longer derivations , thus they have a larger weight in the parameter training , which might lead to overtraining .Equally , if one omits longer strings , poorer predictions may result from overtraining on the shorter strings .We found the trained parameters highly sensitive to the choice of training data set , and struggled to balance this with computational efficiency .We used a final data set from a variety of families , consisting of 369 sequences with corresponding structures .", "label": "", "metadata": {}}
{"text": "We investigated the practice of dividing data into training and test sets .[ 18 ] randomly generate training sets of 200 and 400 strings for parameter training .[14 ] use a training set of 278 structures and test set of 403 total structures .Meanwhile , [ 10 ] used a considerably larger training set , with 2273 structures , and a much smaller test set of just four sequences .Our training and test sets used in the evolutionary algorithm were disjoint sets of size 109 , chosen at random from those sequences in our data of length less than 200 nucleotides .", "label": "", "metadata": {}}
{"text": "As well as measuring performance on our own data , we have used results obtained with the [ 14 ] data .Results and discussion .Figure 1 shows a typical realisation of the search process .The average fitness ( here , smaller fitness is desirable ) of the population is shown , as well as the fitness of the best recorded ( champion ) grammar .The average fitness of the population falls consistently as stronger grammars are found for approximately 100 generations , and then only minor improvements to the champion grammar were found .However , the population fitness continues to fluctuate as areas around the local optimum are searched .", "label": "", "metadata": {}}
{"text": "Fitness evolution .The change over generations in average fitness of population , and the fitness of the best SCFG .Here , a lower fitness is more desirable , the SCFG predicting better secondary structure .Many improvements to both the whole population and best SCFG are made in the first 100 or so generations .After this , the best SCFG does not become much better , but the average population fitness continues to fluctuate .Clearly the algorithm continues to explore alternative SCFGs and tries to escape the local optimum .Across all our experiments , over 300,000 grammars were searched .", "label": "", "metadata": {}}
{"text": "Results on the sensitivity , PPV , and F - score of each grammar can be found in Table 1 , in addition to the benchmark with the [ 14 ] data , and results on different training and testing methods can be found in Table 2 .Table 2 also gives the scores of the combined best prediction , calculated by selecting , for each structure , the prediction with the highest F - score , and then recording the sensitivity , PPV , and F - score for that prediction .Table 1 .Sensitivity and specificity of evolved SCFGs and other prediction methods .", "label": "", "metadata": {}}
{"text": "Sensitivity and specificity of evolved SCFGs using different training and testing methods .This shows grammars with very different structures perform well on the same ( full evaluation ) data set .These rules were used infrequently ( probabilities 0.007 and 0.047 respectively ) .The mild improvement in functionality allows for an additional fraction of base pairs to be correctly predicted .GG2 and GG3 were found using the posterior decoding version of the evolutionary algorithm .They have a high density of rules , that is many rules for each non - terminal variable . is kept constant through the evolutionary algorithm .", "label": "", "metadata": {}}
{"text": "However , with posterior decoding , the base - pair probabilities are still effective for good predictions .GG4 has only two variables ( A and C ) used almost exclusively in producing base pairs .It then uses various exit sequences to generate different sets of unpaired nucleotides and returns to producing base pairs .Finally , GG5 and GG6 are typical of larger grammars we have found with complex structure .It is not obvious to us how their structure relates to their success in secondary structure prediction .GG4 , GG5 , and GG6 were all found using the CYK version of the evolutionary algorithm , and perhaps their complex structure can be accredited to this .", "label": "", "metadata": {}}
{"text": "Most grammars achieved lower predictive power on the Dowell and Eddy dataset .Particularly noteworthy is the performance of GG3 and GG5 .GG3 has had a considerable increase in PPV , likely due to the posterior decoding prediction method .Given many of the structures in the Dowell and Eddy dataset contain pseudoknots , other grammars score poorly trying to predict pairs where there are not , in contrast to GG3 .By predicting fewer base pairs , GG3 gains higher PPV as more of them are correct , but lower sensitivity .GG5 is a grammar which was unremarkable in its results on the original data set , however , it has outperformed the rest of the grammars on the benchmark set and is the only grammar with improved sensitivity when compared to the RNASTRAND dataset .", "label": "", "metadata": {}}
{"text": "GG6 again proves to do slightly better than the other grammars , having the largest area underneath the curve .Figure 2 .Sensitivity / PPV curve .A graph showing how sensitivity and PPV change for grammars when the posterior decoding parameter \u03b3 is changed to alter the frequency of base - pair prediction .The parameter \u03b3 ranged from 0.05 to 5 in increments of 0.05 for each grammar , and the sensitivity and PPV were measured on the full evaluation set .Grammar GG6 shows further strong performance here , having the largest area underneath the graph .", "label": "", "metadata": {}}
{"text": "Determining which is best depends on the measure of strength of prediction , whether the size of the grammar is a concern , ability to approximate structures with pseudoknots effectively , and so on .However , it is clear that a selection of effective grammars has been found .Results shown by UNAfold and RNAfold continue to be superior to those produced by SCFG methods .To do this we define the relative sensitivity of method A with respect to method B as the sensitivity of method A as a predictor of the structures produced by method B. The relative PPV is defined in a similar manner .", "label": "", "metadata": {}}
{"text": "Similarly , it is perhaps not surprising that GG2 and GG3 have very similar predictions given they produce structure through posterior decoding .The rest of the methods have sensitivity and PPV relative to other prediction methods of approximately 0.4 - 0.6 .This is confirmed by our results , suggesting that the new grammars produce different kinds of structures which are good representations of RNA secondary structure .Figure 3 .Relative sensitivities / PPVs .A heat map showing the relative sensitivities and PPVs of the different prediction methods , or between prediction method and known structure .", "label": "", "metadata": {}}
{"text": "Further analysis of .Of course , this might be expected given that this SCFG has been constructed manually , and it is therefore unlikely to have unnecessary production rules .With addition of rules , the number of grammars to check quickly becomes large .With one production rule added , 32 grammars must be evaluated , with two added this increases to 496 .A similar local search for larger grammars would be impractical , since there are many more grammars with one or two altered production rules ( for GG6 , there are 584 grammars with only one new production rule , and 170,236 with two ) .", "label": "", "metadata": {}}
{"text": "Results of this local search can be seen in Figure 4 .Figure 4 .Local search results .The plot shows the cumulative proportion of grammars with given sensitivity .GG1 was the top outlier for two production rule added .In this sense the space is reasonably flat .Brute force search .The brute force search illustrated how , with this normal form , larger grammars are needed to provide effective prediction .Most small grammars will only be able to produce one type of string .Also , it suggested that the existing grammars are close to locally optimal and that the space around them is quite flat , demonstrating the need for intelligent searching methods .", "label": "", "metadata": {}}
{"text": "No grammar has sensitivity higher than 0.25 and approximately one quarter of grammars have sensitivity 0 ( those which can not produce long strings ) .Figure 5 .Brute force search .The distribution of sensitivity and corresponding PPV of grammars with at most 2 nonterminal variables .Approximately one quarter of grammars have sensitivity 0 , as many can not produce long strings .It is only the larger grammars that start to predict long strings which might correspond to structure .However , the prediction quality is still poor by both measures .Ambiguity and Completeness .", "label": "", "metadata": {}}
{"text": "All grammars found in the search were ambiguous , and still predicted structure effectively .Particularly , it is clear that GG2 and GG3 have many different derivations for each structure , and their strong performance relies on this ambiguity , as they perform poorly when tested with CYK .GG5 demonstrates further that ambiguous grammars can even be effective at approximating structures with pseudoknots .The effectiveness of some ambiguous grammars is likely due to the prediction algorithm picking structures that , whilst perhaps suboptimal , are close to what the best prediction would be .Clearly there is room for a further investigation into quite why some grammars cope better with ambiguity than others .", "label": "", "metadata": {}}
{"text": "However , heuristically it seems that the structures that can not be generated have little biological relevance ( e.g. GG4 can not generate \" ( ... ) ( ... ) ( ... ) ( ... ) \" ) .In some sense therefore , the incompleteness is permissible , as the grammar is still able to generate any relevant structure .Conclusions .Our brute force search and search around KH99 demonstrate that intelligent searching methods are necessary , and overall , the method of evolving SCFGs for RNA secondary structure prediction proved effective .We found many grammars with strong predictive accuracy , as good or better than those designed manually .", "label": "", "metadata": {}}
{"text": "One of the strengths of the method is the ease of application and effectiveness for RNA structure problems .In particular , grammatical models are used in phylogenetic models of RNA evolution [ 33 ] which make use of manually constructed grammars , and so the accuracy might be improved with automated grammar design .Overall though , whilst many grammars have been found with good predictive power , the space of grammars grows rapidly with the number of non - terminals , so we can not conclude that no better grammars exist .The effectiveness of the search heuristic is supported by the fact that we consistently find grammars on par with the best manually created grammars .", "label": "", "metadata": {}}
{"text": "It appears that the number of grammars able to achieve this level of performance is large , and may depend little on the overall grammar structure , and at the same time it appears that a performance improvement may be difficult or impossible to achieve with a grammatical approach .Competing interests .Author 's contributions .JWJA conceived the idea in discussion with RL and JH .JWJA then developed the methodology with PT and JS , with help from RL .PT and JS then designed and wrote the code , and results were analysed and written up by JWJA , with help from PT and JS .", "label": "", "metadata": {}}
{"text": "All authors read and approved the final manuscript .Acknowledgements .JWJA would like to thank the EPSRC for funding .JH would like to acknowledge the Miller Institute for funding and hospitality .All authors would like to thank the Department of Plant Science , University of Oxford for their support and use of facilities .We should like to acknowledge the EU grant , COGANGS , for support .Markham N , Zuker M : UNAFold : software for nucleic acid folding and hybridization .In Bioinformatics , Volume II .Structure , Function and Applications .Edited by Keith JM .", "label": "", "metadata": {}}
{"text": "Lefebvre F : A grammar - based unification of several alignment and folding algorithms .In Proceedings of the Fourth International Conference on Intelligent Systems for Molecular Biology .Edited by States DJ , Agarwal P , Gaasterland T , Hunter L , Smith RF .Menlo Park CA : AAAI Press ; 1996:143 - 154 .Brown M , Wilson C : RNA pseudoknot modeling using intersections of stochastic context free grammars with applications to database search .In Pacific Symposium on Biocomputing 1996 .Singapore : World Scientific Publishing Co. ; 1995 .Abstract .Background .Over the past years , statistical and Bayesian approaches have become increasingly appreciated to address the long - standing problem of computational RNA structure prediction .", "label": "", "metadata": {}}
{"text": "This method samples the possible foldings from a distribution implied by a sophisticated ( traditional or length - dependent ) stochastic context - free grammar ( SCFG ) that mirrors the standard thermodynamic model applied in modern physics - based prediction algorithms .Specifically , that grammar represents an exact probabilistic counterpart to the energy model underlying the Sfold software , which employs a sampling extension of the partition function ( PF ) approach to produce statistically representative subsets of the Boltzmann - weighted ensemble .Although both sampling approaches have the same worst - case time and space complexities , it has been indicated that they differ in performance ( both with respect to prediction accuracy and quality of generated samples ) , where neither of these two competing approaches generally outperforms the other .", "label": "", "metadata": {}}
{"text": "In this work , we will consider the SCFG based approach in order to perform an analysis on how the quality of generated sample sets and the corresponding prediction accuracy changes when different degrees of disturbances are incorporated into the needed sampling probabilities .Thus , it might then be possible to decrease the worst - case time requirements of such an SCFG based sampling method without significant accuracy losses .If , on the other hand , the quality of sampled structures can be observed to strongly react to slight disturbances , there is little hope for improving the complexity by heuristic procedures .", "label": "", "metadata": {}}
{"text": "Conclusions .Our experiments indicate that absolute errors generally lead to the generation of useless sample sets , whereas relative errors seem to have only small negative impact on both the predictive accuracy and the overall quality of resulting structure samples .Based on these observations , we present some useful ideas for developing a time - reduced sampling method guaranteeing an acceptable predictive accuracy .We also discuss some inherent drawbacks that arise in the context of approximation .The key results of this paper are crucial for the design of an efficient and competitive heuristic prediction method based on the increasingly accepted and attractive statistical sampling approach .", "label": "", "metadata": {}}
{"text": "Electronic supplementary material .The online version of this article ( doi : 10 .1186/\u200b1471 - 2105 - 13 - 159 ) contains supplementary material , which is available to authorized users .Background .In computational structural biology , a well - established probabilistic methodology towards single sequence RNA secondary structure prediction is based on modeling secondary structures by stochastic context - free grammars ( SCFGs ) .In a sense , SCFGs can be seen as a generalization of hidden Markov models ( HMMs ) , which are widely and successfully used in the large field of bioinformatics .", "label": "", "metadata": {}}
{"text": "Traditionally , SCFG based prediction approaches are realized by dynamic programming algorithms ( DPAs ) that require time and storage for identifying the most probable folding for an input sequence of length n .Examples for successful applications of several lightweight ( i.e. small and simple ) SCFGs for RNA secondary structure prediction can be found in [ 1 ] and a popular SCFG based prediction tool is for instance given by the Pfold software [ 2 , 3 ] .However , for a very long time , the free energy minimization ( MFE ) paradigm has been the most common technique for predicting the secondary structure of a given RNA sequence .", "label": "", "metadata": {}}
{"text": "They basically require time and storage for identifying a set of candidate structures for an input sequence of length n .Some implementations are considered state - of - the - art tools for computational structure prediction from a single sequence , for instance the Mfold software [ 9 , 10 ] or the Vienna package [ 11 , 12 ] .To overcome these problems , several statistical sampling methods and clustering techniques have been invented over the last years that are based on the partition function ( PF ) approach for computing base pair probabilities as introduced in [ 13 ] .", "label": "", "metadata": {}}
{"text": "They are implemented in the widely used Sfold package [ 15 ] .In fact , over the past years , statistical approaches to RNA secondary structure prediction have become an attractive alternative to the standard energy - based approach ( which basically relies on several thousands of experimentally - determined energy parameters ) .In principle , many of these approaches - in contrast to Sfold - rely on ( thermodynamic ) parameters estimated from growing databases of structural RNAs .For instance , the CONTRAfold tool [ 16 ] is based on a discriminative statistical method and uses a simplified nearest neighbor model for the underlying conditional log - linear model ( CLLM ) .", "label": "", "metadata": {}}
{"text": "The prime advantage of using discriminate instead of generative training is that more complex scoring schemes can be considered , whereas generative models are generally easier to train and use .Actually , CONTRAfold in several cases manages to provide the highest single sequence prediction accuracy to date and eventually closes the performance gap between the best thermodynamic methods and the best ( lightweight ) SCFGs .However , there are some benchmarks that show better performance by other methods , suggesting in the least that the performance of structure prediction can vary considerably depending on RNA family [ 17 - 19 ] .", "label": "", "metadata": {}}
{"text": "These are all classified as discriminative statistical methods which implement different variants of standard thermodynamic models .In fact , they condition on a set of RNA sequences being given ( in order to obtain estimates for the free energy parameters ) , whereas a generative SCFG approach models the probabilities of the input RNA sequences ( in order to induce corresponding ensemble distributions ) .Anyway , statistical methods for RNA folding have previously been chosen to be either purely physics - based ( e.g. , Sfold ) or discriminative and implementing a thermodynamic model ( e.g. , CONTRAfold ) , not generative .", "label": "", "metadata": {}}
{"text": "However , a generative statistical method for predicting RNA secondary structure has recently been proposed [ 23 ] .This method builds on a novel probabilistic sampling approach for generating random candidate structures for a given input sequence that is based on a sophisticated SCFG design .Basically , it generates a statistical sample of possible foldings for the given sequence that is guaranteed to be representative with respect to the corresponding ensemble distribution implied by the parameters of the underlying SCFG .Particularly , conditional sampling probabilities for randomly creating unpaired bases and base pairs on actual sequence fragments are considered that are calculated by using only the grammar parameters and the corresponding inside and outside probabilities for the sequence .", "label": "", "metadata": {}}
{"text": "In fact , the sole difference is that it incorporates only comprehensive structural features and additional information obtained from trusted databases of real - world RNA structures instead of the recent thermodynamic parameters .Lately , in an attempt to improve the quality of generated sample sets , this probabilistic sampling approach has been extended to being capable of additionally incorporating length - dependencies [ 24 ] .In particular , the employed ( heavyweight )SCFG has been transformed into a corresponding length - dependent stochastic context - free grammar ( LSCFG ) and parts of the respective procedures have been modified accordingly ( in order to deal with this grammar extension ) .", "label": "", "metadata": {}}
{"text": "Applications to structure prediction ( with respect to sensitivity and PPV , as well as to the shapes of sampled structures and predictions ) showed that none of these sampling variants generally yields the most realistic results .Actually , which one of them should be preferred seems to strongly depend on the RNA type of the input sequence , but most importantly on the quality of a corresponding training set and on the performance of the thermodynamic model on such RNAs .Particularly , we want to explore to what extend the quality of produced secondary structure samples for a given input sequence and the corresponding predictive accuracy decreases when different degrees of disturbances are incorporated into the needed sampling probabilities .", "label": "", "metadata": {}}
{"text": "Then it seems adequate to believe that the sampling procedure does not have to calculate these probabilities in the exact way , but it may efficiently suffice if they are only ( adequately ) approximated .Furthermore , to ensure that the quality of the generated sample sets and the predictive accuracy remains sufficiently high , analysis results on the effects of different disturbance levels and types should be taken into account for the development of an appropriate approximation scheme ( or heuristic ) .From the other perspective , suppose the quality of sampled structures seems to strongly react on rather slight disturbances already .", "label": "", "metadata": {}}
{"text": "Therefore , we will incorporate disturbances into these values ( that need to be derived for any input sequence ) rather than into the underlying grammar parameters ( transition and emission probabilities trained on a suitable RNA database ) .This means that in this work , the source of an error will not come from a flawed learning set , although the study of random errors in the applied grammar parameters would actually be analogous to tests performed in connection with the thermodynamic PF [ 29 ] .For this reason , applying random errors on the inside and outside values seems to be a much better test in the context of investigations on the impact of a performance improving heuristic .", "label": "", "metadata": {}}
{"text": "Throughout this article , we will actually present some useful considerations on how a corresponding approximation scheme ( or heuristic procedure ) should be constructed in order to ensure that the sampling quality remains sufficiently high .The rest of this paper is organized as follows : Section Methods introduces the formal framework , including the ( L)SCFG model , definitions of various types and levels of disturbances and a corresponding recursive sampling strategy that will be considered within this article .A comprehensive disturbance analysis based on exemplary RNA data and the corresponding results will follow in Section Results and Discussion , where both the quality of generated sample sets and their applicability to the problem of RNA structure prediction are investigated .", "label": "", "metadata": {}}
{"text": "Section Results and Discussion also includes considerations on how to develop a corresponding time - reduced sampling strategy without significant losses in sampling quality .Notably , some of the key results are discussed in Section Errors Only on Particular Values .Finally , Section Conclusions concludes the paper .Methods .In this section , we provide all needed information and introduce the formal framework that will be used subsequently .We start by a recap of the relevant details of the probabilistic sampling method from [ 23 , 24 ] and proceed with formally defining how a number of different types and levels of disturbances can be incorporated into the corresponding ( L)SCFG based statistical sampling variants .", "label": "", "metadata": {}}
{"text": "Note that we assume the reader to be familiar with the notions and basic concepts regarding SCFGs .A fundamental introduction on stochastic context - free languages can be found in [ 30 ] .Moreover , since for the understanding of this paper , no additional information on length - dependent stochastic models is needed , we refer to [ 25 ] for details .Sampling based on ( L)SCFG model .In general , probabilistic sampling based on a suitable ( L)SCFG has two basic steps : The first step ( preprocessing ) computes the inside and outside probabilities for all substrings of a given input sequence based on the considered ( L)SCFG model .", "label": "", "metadata": {}}
{"text": "For our investigations , we decided to rely on a rather elaborate ( L)SCFG design , namely the exact formal language counterpart to the thermodynamic model applied in the Sfold program , which is given as follows : .Note that has been parameterized to impose two relevant restrictions on the class of all feasible structures : first , a minimum length of for hairpin loops and second , a minimum number of consecutive base pairs for helices , where common choices are and .However , within this work we will only consider , which corresponds to the least restrictive ( yet also most unrealistic ) choice and usually yields the worst sampling results ( see [ 23 , 24 ] ) .", "label": "", "metadata": {}}
{"text": "However , according to [ 23 , 24 ] , the computation of all inside probabilities .Notably , both sampling variants ( length - dependent or not ) can be implemented to require time and memory for this preprocessing step .Step Two - Random structure generation .Once the preprocessing is finished , different strategies may be employed for realizing the recursive sampling step .In general , for any sampling decision ( for example choice of a new base pair ) , a particular strategy relies on the respective set of all possible choices that might actually be formed on the currently considered fragment of the input sequence .", "label": "", "metadata": {}}
{"text": "The corresponding random choice is then drawn according to the resulting conditional sampling distribution ( for the considered sequence fragment ) .This means the respective sampling distributions are defined by the inside and outside values derived in step one ( providing information on the distribution of all possible choices according to the actual input sequence ) and the grammar parameters ( transition probabilities ) .In this work , we will only consider the well - established strategy from [ 23 , 24 ] , which is also implemented in the corresponding second step of the physics - based sampling algorithm underlying the popular Sfold tool .", "label": "", "metadata": {}}
{"text": "Under the assumption that the alternatives for intermediate symbol X are equal to and , this set is defined as follows : .Consequently , we have to sample from the corresponding conditional probability distribution induced by acX ( i , j ) , that is the random choice is drawn according to the following set of sampling probabilities : . which then ensures that the corresponding sampling probabilities still sum up to unity , such that they indeed define a conditional probability distribution ) .For this reason , we can obviously without loss of information remove the outside values from the definitions of the needed sampling probabilities .", "label": "", "metadata": {}}
{"text": "In fact , the sampling strategy randomly draws one of the elements from acX ( i , j ) according to the corresponding distribution induced by normalizing the probabilities of the elements in acX ( i , j ) such that they sum up to unity .Particularly , we have .Considered disturbance types and levels .Obviously , under the assumption of a particular ( L)SCFG model ( trained beforehand on arbitrary RNA data ) , the most straightforward way for improving the performance of the corresponding overall sampling algorithm seems to be by reducing the worst - case complexity of the inside calculations .", "label": "", "metadata": {}}
{"text": "Note that is actually suffices to consider , since only those intermediate symbols are needed for defining the diverse sampling probabilities that are used by the employed sampling strategy for obtaining the distinct conditional distributions for drawing particular random choices .Notably , Interval ( func ) is not centered on \u03b1 X ( i , j ) , as it actually describes the set of error values that might be drawn ( uniformly ) at random - which are then added to \u03b1 X ( i , j ) .Anyway , in the sequel , we will basically consider either .", "label": "", "metadata": {}}
{"text": "Formally , this means that either .Note that the consideration of symmetric intervals ( as defined by Interval ( mep ) ) is of interest as it models the case that all errors are bounded but do not need to admit the maximum value possible ( according to prob ) .When studying relative errors in connection with this variant , this basically corresponds to assuming a particular approximation ratio of the underlying algorithm .The consideration of discrete sets ( as defined by Interval ( fep ) ) corresponds to the case that any error takes on the maximum value possible ( according to prob ) .", "label": "", "metadata": {}}
{"text": "Resulting modified sampling strategy .This , however , might create the need to ( slightly ) modify the respective particularly employed sampling strategy such that it finally gets capable to deal with these skewed distributions .As for this work , consider the previously sketched recursive sampling strategy from [ 23 , 24 ] .Without any errors in the conditional probability distributions ( i.e. by using the exact probabilistic parameters for the given input sequence , particularly the corresponding inside values ) , it always successfully generates the sampled loop type for a considered sequence fragment .For example , suppose the sampling procedure decides that base pair r i .", "label": "", "metadata": {}}
{"text": "The resulting modified versions of the distinct sampling steps ( in pseudocode ) are given in Section Sm - I ( of Additional file 1 ) , Figure 1 gives a schematic overview of the overall sampling process .Flowchart for recursive sampling of an RNA secondary structure S 1,n for a given input sequence r of length n according to an inherently controlled strategy with predetermined order , similar to that of [ 14 ] , [ 23 ] .Note that alternatively , the algorithm could have been modified to revise any decisions that lead to incompletely generated substructures , resulting in some sort of backtracking procedures that obviously would have to be applied in order to sample more realistic overall structures for a given RNA sequence .", "label": "", "metadata": {}}
{"text": "Results and discussion .In fact , we want to explore to what extend the quality of produced secondary structure samples for a given input sequence and the corresponding predictive accuracy decreases when different degrees of errors are incorporated into the needed sampling probabilities .RNA structure data .For our examinations , we decided to consider different sets of trusted RNA secondary structure data for which the ( L)SCFG based sampling approach yields good quality results when no disturbances are included in the respective sampling distributions for a given sequence .These two rich data sets of trusted RNA secondary structures will be exclusively used as the basis for the following applications , such that the results can easily be opposed to the corresponding ones presented in [ 24 ] .", "label": "", "metadata": {}}
{"text": "A statistical sample of all possible secondary structures for a given RNA sequence can be used for sampling estimates of the probabilities of any structural motifs .Actually , probability profiling for unpaired bases within particular loop types can easily be applied for this purpose .These probabilities are given by the observed frequencies in a random sample set .Since this application is rather intuitive , we decided to use it as a starting point for our disturbance analysis .All relevant results are displayed in Additional file 1 : Figures S1 to S14 of Section Sm - II .", "label": "", "metadata": {}}
{"text": "Hairpin loop profiles for E.coli tRNA Ala , calculated from a random sample of 1000 structures generated with the SCFG ( figures on the left ) and LSCFG ( figures on the right ) approach , respectively ( under the assumption of the less restrictive grammar parameters and ) .The exact ( undisturbed ) results are displayed by the thin black lines , and the correct hairpin loops in E.coli tRNA Ala are illustrated by the black points .Errors on all values .Let us first consider the profiles displayed in Figure 2 ( and in Additional file 1 : Figures S1 and S2 ) .", "label": "", "metadata": {}}
{"text": "Second , for ensuring that none of the actually valid choices is prohibited during the folding process , such that the sampling procedure might inevitably prefer other ( potentially even impossible ) substructures .Relevant sampling probabilities .Nevertheless , in order to draw more detailed conclusions , we counted and compared the relevant ( i.e. , greater than zero ) inside and sampling probabilities that were considered for obtaining the profiles presented in Figure 2 .The results are collected in Additional file 1 : Tables S1 and S2 of Section Sm - II .Tables S1 and S2 exemplarily prove this intuitive assumption .", "label": "", "metadata": {}}
{"text": "Considering the LSCFG variant , however , for any the least inside values are relevant only in the exact case , as indicated by Table S1b .Obviously , this seems to be the natural consequence of the previously formulated observations .Errors only on particular values .The corresponding profiles are basically shown in Figures 3 and 4 ( as well as in Additional file 1 : Figures S3 to S14 ) .However , due to the contrary course of action of traditional inside calculations , this approach can obviously not be realized .Moreover , for two symbols , namely F ( for the LSCFG model ) and B , we recognized no noticeable impact of the caused disturbances to the accuracy of the generated sample sets .", "label": "", "metadata": {}}
{"text": "In connection with sampling approaches , there exist diverse ( more or less ) efficient well - defined principles for extracting a particular structure prediction from a generated set of candidate structures for a given input sequence .Briefly , these two common measures are widely used in order to quantify the accuracy of RNA secondary structure prediction methods and are usually defined as follows ( see e.g. [ 34 ] ): .Sens . is the relative frequency of correctly predicted pairs among all position pairs that are actually paired in a stem of native foldings , whereas .", "label": "", "metadata": {}}
{"text": "This choice will be denoted by most probable ( MP ) structure subsequently .In fact , any representative set of candidate structures for a given input sequence obtained by ( L)SCFG based statistical sampling obviously reflects the probability distribution on all feasible foldings of that sequence which strongly depends on the corresponding inside probabilities .Hence , the results for MP and MF structure predictions might differ in the disturbed cases , especially as the gravity of generated disturbances grows .However , we decided to additionally apply two different commonly used construction schemes for computing a new structure as predicted folding , where the predicted structure itself must not necessarily be contained in the given sample .", "label": "", "metadata": {}}
{"text": "However , the ( unadjusted ) sensitivity and PPV measures obtained by considering the four different ( unparameterized ) prediction principles sketched above are listed in Additional file 1 : Tables S3a and S5a i , where a few selected ones are presented in Table 1 .Note that in accordance with [ 23 , 24 ] , we considered any value of in order to obtain appropriate ROC curves and corresponding AUC values .Plots of some of the resulting curves can be found in Additional file 1 : Figures S15 to S18 of Section Sm - II .", "label": "", "metadata": {}}
{"text": "Let us first consider the results reported in Table 1 .As we can see , the PPV is principally not affected by the different dimensions of disturbances caused according to mep ( prob ) , as only in the case of MF structure prediction one can observe a slight change for the worse .Unsurprisingly , for both RNA data , the change for the worse by means of measured sensitivity is less significant when considering MP structure predictions than when employing any of the other three principles , especially in the case of the LSCFG model .This is due to the fact that MP structures are always extracted by relying on the exact distribution ( see discussion above ) .", "label": "", "metadata": {}}
{"text": "Moreover , Table 1 indicates that generating errors according to the fep ( prob ) variant ( unsurprisingly ) yields greater losses in the accuracies of selected predictions .In fact , as prob gets greater , there generally result considerably smaller PPV values for all four prediction schemes ( mostly for MF structures ) than in the corresponding undisturbed case .Furthermore , the respective sensitivity values degrade enormously , albeit again comparatively less in connection with MP structure predictions .However , these changes for the worse are obviously less significant when using the length - dependent sampling approach instead of the more general conventional variant , which matches the observations made above for disturbances caused by mep ( prob ) .", "label": "", "metadata": {}}
{"text": "Sampling quality - Specific values related to shapes .Obviously , the sensitivity and PPV measures used in the last section for assessing the accuracy of predicted foldings depend only on the numbers of correctly and incorrectly predicted base pairs ( compared to the trusted database structure ) .For biologists , however , it is usually much more important to get the correct shape of the native folding .This is due to the fact that a predicted set of suboptimal foldings calculated by modern computational structure prediction methods generally contains lots of similar foldings but for biologists , only those with significant structural differences are of interest .", "label": "", "metadata": {}}
{"text": "Notably , there are five different shape levels which have been proven to gradually increase abstraction by disregarding certain unpaired regions or combining nested helices ( see e.g. [ 39 ] ) , where secondary structures can accordingly be considered level 0 shapes .For these reasons , we decided to complete our analysis of the influence of disturbances to the quality of probabilistic statistical sampling by considering the following meaningful specific values related to the shapes of predictions and sampled structures as defined in [ 23 , 24 ] : .Frequency of prediction of correct structure ( CSP freq ):", "label": "", "metadata": {}}
{"text": "Frequency of correct shape occurring in a sample ( CSO freq ):In how many cases can the correct shape ( on different levels ) be found in the generated sample set ?Number of occurrences of correct shape in a sample ( CS num ): How many times can the correct shape be found in the generated sample set ?Number of different shapes in a sample ( DS num ): How many different secondary structures ( or shapes ) can be found in the generated sample set ?We can easily compute the respective values from the predicted structures and the corresponding sample sets that were derived for the calculation of the sensitivity and PPV measures in the last section .", "label": "", "metadata": {}}
{"text": "Some of the most interesting ones are recorded in Tables 3 and 4 .Tables record specific values related to shapes of predictions and sampled structures , obtained from our tRNA database .All results were computed by 10-fold cross - validation procedures , using sample size 1000 and .Tables record specific values related to shapes of predictions and sampled structures , obtained from our 5S rRNA database .All results were computed by 10-fold cross - validation procedures , using sample size 1000 and .Moreover , comparing the discussed CSP freq results for the LSCFG variant to the corresponding ones for the conventional SCFG approach , we get additional evidence that the length - independent sampling method reacts stronger to relative disturbances in the underlying ensemble distribution for a given sequence than its length - dependent counterpart .", "label": "", "metadata": {}}
{"text": "Now , let us consider the three remaining specific values CSO freq , CS num and DS num that can eventually be used to assess the overall quality of generated sample sets rather than the accuracy of corresponding selected predictions .Basically , the obtained CSO freq and CS num results for tRNAs and 5S rRNAs ( as reported in Tables S7e to S7f and Tables S8e to S8f ) , respectively , show a similar picture and thus yield similar conclusions as the corresponding CSP freq values discussed above .This actually means that the diversity within the generated sample sets generally gets greater as the overall sampling quality ( with respect to occurrences of the correct structure in the sample ) decreases , which could be fully expected .", "label": "", "metadata": {}}
{"text": "Basically , two different levels of errors were considered for randomly creating disturbances on all inside values for a given input sequence according to the underlying grammar model : relative and absolute ones .However , both SCFG approaches ( length - dependent and traditional one ) behave rather resistant to disturbances of the needed conditional sampling probabilities that are caused by generating ( moderate ) relative errors on all ( and also only on particular ) inside values for a given input sequence .In general , even large relative errors seem to have no enormous negative impact on both the predictive accuracy and the overall quality of generated sample sets .", "label": "", "metadata": {}}
{"text": "Endnotes .b Note that the function ensures that the resulting value is still a probability , i.e. a real value from [ 0,1].This effectively facilitates the study of disturbances of different magnitudes .d In general , longer words tend to be generated with smaller probability since we have to apply more grammar rules , each implying a factor ( typically ) less than 1 to the probability .e If those decisions are not revised by employing backtracking procedures , see the description of the modifications incorporated into the sampling algorithm in order to deal with such situations as given in Section Resulting Modified Sampling Strategy .", "label": "", "metadata": {}}
{"text": "g This is due to the fact that the probability of a particular folding of a given RNA sequence ( i.e. , the probability of the corresponding derivation tree ) depends only on the considered set of grammar parameters ( transition and emission probabilities ) .h Note that we here assume sensitivity as a function of PPV is an ROC curve , although correctly an ROC curve is sensitivity as a function of specificity .i Note that the corresponding standard deviations on sensitivity values and PPV are recorded in Additional file 1 : Tables S4 and S6 ; these allow for a reader to acknowledge which values are different and which ones are identical / close .", "label": "", "metadata": {}}
{"text": "Acknowledgements .AS thanks Carl Zeiss Foundation for supporting her research .All authors wish to thank an anonymous reviewer for careful reading and helpful remarks and suggestions made for a previous version of this article .Electronic supplementary material .Competing interests .Both authors declare that they have no competing interests .Authors ' contributions .AS developed and implemented the algorithms for generating statistical samples based on disturbed ensemble distributions .AS performed all experiments and evaluated the decline of sampling quality implied by considering the diverse kinds of disturbances .MEN supervised the work and development of ideas .", "label": "", "metadata": {}}
{"text": "Both authors have read and approved the final manuscript .Authors ' Affiliations .Department of Computer Science , University of Kaiserslautern .References .Dowell RD , Eddy SR : Evaluation of several lightweight stochastic context - free grammars for RNA secondary structure prediction .BMC Bioinformatics 2004 , 5 : 71 .PubMed View Article .Knudsen B , Hein J : RNA secondary structure prediction using stochastic context - free grammars and evolutionary history .Bioinformatics 1999 , 15 ( 6 ) : 446 - 454 .PubMed View Article .Knudsen B , Hein J : Pfold : RNA secondary structure prediction using stochastic context - free grammars .", "label": "", "metadata": {}}
{"text": "PubMed View Article .Nussinov R , Jacobson AB : Fast algorithms for predicting the secondary structure of single - stranded RNA .Proc Nat Acad Sci USA 1980 , 77 ( 11 ) : 6309 - 6313 .PubMed View Article .Nussinov R , Pieczenik G , Griggs JR , Kleitman DJ : Algorithms for loop matchings .SIAM J Appl Mathematics 1978 , 35 : 68 - 82 .View Article .Zuker M , Stiegler P : Optimal computer folding of large RNA sequences using thermodynamics and auxiliary information .Nucleic Acids Res 1981 , 9 : 133 - 148 .", "label": "", "metadata": {}}
{"text": "Steger G , Hofmann H , F\u00f6rtsch J , Gross HJ , Randles JW , S\u00e4nger HL , Riesner D : Conformational transitions in viroids and virusoids : comparison of results from energy minimization algorithm and from experimental data .J Biomol Struct & Dyn 1984 , 2 ( 3 ) : 543 - 571 .View Article .Wuchty S , Fontana W , Hofacker I , Schuster P : Complete suboptimal folding of RNA and the stability of secondary structures .Biopolymers 1999 , 49 : 145 - 165 .PubMed View Article .Zuker M : On finding all suboptimal foldings of an RNA molecule .", "label": "", "metadata": {}}
{"text": "PubMed View Article .Zuker M : Mfold web server for nucleic acid folding and hybridization prediction .Nucleic Acids Res 2003 , 31 ( 13 ) : 3406 - 3415 .PubMed View Article .Hofacker I , Fontana W , Stadler P , Bonhoeffer S , Tacker M , Schuster P : Fast folding and comparison of RNA secondary structures ( the Vienna RNA package ) .Monatsh Chem 1994 , 125 ( 2 ) : 167 - 188 .View Article .Hofacker IL : The Vienna RNA secondary structure server .Nucleic Acids Res 2003 , 31 ( 13 ) : 3429 - 3431 .", "label": "", "metadata": {}}
{"text": "McCaskill JS : The equilibrium partition function and base pair binding probabilities for RNA secondary structure .Biopolymers 1990 , 29 : 1105 - 1119 .PubMed View Article .Ding Y , Lawrence CE : A statistical sampling algorithm for RNA secondary structure prediction .Nucleic Acids Res 2003 , 31 ( 24 ) : 7280 - 7301 .PubMed View Article .Ding Y , Chan CY , Lawrence CE : Sfold web server for statistical folding and rational design of nucleic acids .Nucleic Acids Res 2004 , 32 : W135-W141 .PubMed View Article .", "label": "", "metadata": {}}
{"text": "Bioinformatics 2006 , 22 ( 14 ) : e90-e98 .PubMed View Article .Andronescu M , Condon A , Hoos HH , Mathews DH , Murphy KP : Computational approaches for RNA energy parameter estimation .RNA 2010 , 16 : 2304 - 2318 .PubMed View Article .Hamada M , Kiryu H , Sato K , Mituyama T , Asai K : Prediction of RNA secondary structure using generalized centroid estimators .Bioinformatics 2009 , 25 ( 4 ) : 465 - 473 .PubMed View Article .Lu ZJ , Gloor JW , Mathews DH : Improved RNA secondary structure prediction by maximizing expected pair accuracy .", "label": "", "metadata": {}}
{"text": "PubMed View Article .Andronescu M , Condon A , Hoos HH , Mathews DH , Murphy KP : Efficient parameter estimation for RNA secondary structure prediction .Bioinformatics 2007 , 23 : i19 .PubMed View Article .Zakov S , Goldberg Y , Elhadad M , Ziv - Ukelson M : Rich parameterization improves RNA structure prediction .J Comput Biol 2011 , 18 ( 11 ) : 1525 - 1542 .PubMed View Article .Nebel ME , Scheid A : Analysis of the free energy in a stochastic RNA secondary structure model .IEEE / ACM Trans Comput Biol Bioinformatics 2011 , 8 ( 6 ) : 1468 - 1482 .", "label": "", "metadata": {}}
{"text": "Nebel ME , Scheid A : Evaluation of a sophisticated SCFG design for RNA secondary structure prediction .Theory Biosci 2011 , 130 ( 4 ) : 313 - 336 .PubMed View Article .Scheid A , Nebel ME : Statistical RNA secondary structure sampling based on a length - dependent SCFG model .Technical report , University of Kaiserslautern , 5 , 2012 .Weinberg F , Nebel ME : Applying length - dependent stochastic context - free grammars to RNA secondary structure prediction .Algorithms 2011 , 4 ( 4 ) : 223 - 238 .View Article .", "label": "", "metadata": {}}
{"text": "Inf Theory Appl Workshop 2007 , 256 - 260 .Nawrocki EP , Eddy SR : Query - dependent banding ( QDB ) for faster RNA similarity searches .PLoS Comput Biol 2007 , 3 ( 3 ) : e56 .PubMed View Article .Nebel ME , Scheid A : A n2 RNA secondary structure prediction algorithm .In Bioinformatics 2012 , International Conference on Bioinformatics Models , Methods and Algorithms .Vilamoura , Portugal ; 2012 .Layton DM , Bundschuh R : A statistical analysis of RNA folding algorithms through thermodynamic parameter perturbation .Nucleic Acids Res 2005 , 33 ( 2 ) : 519 - 524 .", "label": "", "metadata": {}}
{"text": "Huang T , Fu KS : On stochastic context - free languages .Inf Sci 1971 , 3 : 201 - 224 .View Article .Viennot G , Chaumont MVD : Enumeration of RNA secondary structures by complexity .Mathematics Med Biol , Lecture Notes Biomathematics 1985 , 57 : 360 - 365 .View Article .Sprinzl M , Horn C , Brown M , Ioudovitch A , Steinberg S : Compilation of tRNA sequences and sequences of tRNA genes .Nucleic Acids Res 1998 , 26 : 148 - 153 .PubMed View Article .Szymanski M , Barciszewska MZ , Erdmann VA , Barciszewski J : 5s ribosomal RNA database .", "label": "", "metadata": {}}
{"text": "PubMed View Article .Baldi P , Brunak S , Chauvin Y , Andersen CA , Nielsen H : Assessing the accuracy of prediction algorithms for classification : an overview .Bioinformatics 2000 , 16 ( 5 ) : 412 - 424 .PubMed View Article .Ding Y , Chan CY , Lawrence CE : RNA secondary structure prediction by centroids in a Boltzmann weighted ensemble .RNA 2005 , 11 : 1157 - 1166 .PubMed View Article .Giegerich R , Vo\u00df B , Rehmsmeier M : Abstract shapes of RNA .Nucleic Acids Res 2004 , 32 ( 16 ) : 4843 - 4851 .", "label": "", "metadata": {}}
{"text": "Janssen S , Reeder J , Giegerich R : Shape based indexing for faster search of RNA family databases .BMC Bioinformatics 2008 , 9 : 131 .PubMed View Article .Steffen P , Vo\u00df B , Rehmsmeier M , Reeder J , Giegerich R : RNAshapes 2.1.1 manual , .February 2006 .Nebel ME , Scheid A : On quantitative effects of RNA shape abstraction .Theory in Biosci 2009 , 128 ( 4 ) : 211 - 225 .View Article .Copyright .\u00a9 Scheid and Nebel ; licensee BioMed Central Ltd. 2012 .This article is published under license to BioMed Central Ltd.", "label": "", "metadata": {}}
{"text": "Affiliated with .Abstract .Background .Searching for members of characterized ncRNA families containing pseudoknots is an important component of genome - scale ncRNA annotation .However , the state - of - the - art known ncRNA search is based on context - free grammar ( CFG ) , which can not effectively model pseudoknots .Thus , existing CFG - based ncRNA identification tools usually ignore pseudoknots during search .As a result , dozens of sequences that do not contain the native pseudoknots are reported by these tools .When pseudoknot structures are vital to the functions of the ncRNAs , these sequences may not be true members .", "label": "", "metadata": {}}
{"text": "In this work , we design a pseudoknot search tool using multiple simple sub - structures , which are derived from knot - free and bifurcation - free structural motifs in the underlying family .We test our tool on a contiguous 22-Mb region of the Maize Genome .The experimental results show that our work competes favorably with other pseudoknot search methods .Conclusions .Our sub - structure based tool can conduct genome - scale pseudoknot - containing ncRNA search effectively and efficiently .It provides a complementary pseudoknot search tool to Infernal .Background .", "label": "", "metadata": {}}
{"text": "Many types of ncRNAs function through both their sequences and secondary structures , which are defined by interactions between Watson - Crick and wobble base pairs .Pseudoknot is a functionally important structural motif in ncRNA secondary structures .In pseudoknots , bases in loop regions can form base pairs with bases outside the stem loop .In a graphical representation where arcs connect base pairs , pseudoknot - free secondary structures only contain parallel or nested base pairs while pseudoknot structures allow \" crossing \" base pairs , shown by an example in Figure 1 .A .Consensus secondary structure of tmRNA and the secondary structure described by SCFG ( pseudoknots missing ) . A. Consensus secondary structure of RF00023 ( tmRNA ) in Rfam .", "label": "", "metadata": {}}
{"text": "B. Secondary structure described by SCFG ( pseudoknots missing ) .It is already known that pseudoknots play important functions in telomerase RNA , tmRNA , rRNA , some riboswitches , some protein - biding RNAs , Viral ribosomal frameshifting signals , etc [ 2 ] .Different research groups [ 3 , 4 ] have shown that the pseudoknot structure in the telomerase RNA is essential for telomerase activity .Gilley and Blackburn [ 3 ] experimentally demonstrated that disruptions of the pseudoknot base pairing within the telomerase RNA from Tetrahymena thermophila prevent the stable assembly in vivo of an active telomerase .", "label": "", "metadata": {}}
{"text": "Similarly , biologists reported that the pseudoknots in tmRNA are highly important for protein biding , tmRNA maturation , and proper folding of the tRNA - like domain [ 5 ] .Currently , 26,704 sequences in 71 ncRNA seed families of Rfam 10.0 [ 6 ] contain pseudoknots .With the advances of sequencing technologies and structure predictions , more pseudoknot structures are expected to be revealed .Because the functions of ncRNAs are determined by both the sequence and structure , successful ncRNA homology search tools must consider both sequence and structural conservations .Existing ncRNA search tools can be divided into two categories .", "label": "", "metadata": {}}
{"text": "The second category includes tools for identifying novel ncRNA genes .This work belongs to the first category and focuses on ncRNAs containing pseudoknots .For pseudoknot free ncRNAs , the state - of - the - art search method is based on stochastic context - free grammars ( SCFGs ) , which can accurately model the evolutionary changes of both the sequences and structures of a group of homologous ncRNAs .Commonly used general and specialized known ncRNA search tools such as Infernal [ 7 ] , RSEARCH [ 8 ] , and tRNAScan - SE [ 9 ] are all based on SCFG .", "label": "", "metadata": {}}
{"text": "However , SCFGs are not able to model pseudoknot .Thus , the implementations of SCFG by Infernal neglect pseudoknots in the structures .For example , although RF00023 ( tmRNA ) has four pseudoknots , its SCFG only models the knot - free structures , shown in Figure 1 . B .As a result , Infernal could misclassify sequences as members of families containing pseudoknots .In addition , Infernal has high computational cost , limiting its usage in large - scale data sets , such as those generated by the next - generation sequencing technologies .More complicated grammars such as context - sensitive Grammars ( CSGs ) [ 10 ] exist to faithfully model pseudoknots .", "label": "", "metadata": {}}
{"text": "Besides CSGs , other grammars such as parallel communicating grammar systems [ 11 ] , RNA pseudoknot grammars [ 12 ] , tree adjoining grammars ( TAGs ) [ 13 , 14 ] , and multiple context - free grammars [ 15 ] have been proposed to model pseudoknot structures .These work described the grammars and associated parsing algorithms .However , they have not been widely used in pseudoknot search in large - scale databases .First , although the parsing algorithms are polynomial , their cubic or even higher time or memory complexity [ 15 ] limits their large - scale applications .", "label": "", "metadata": {}}
{"text": "In order to conduct large - scale homology search , local parsing algorithms are needed .As there are no source codes or executable implementations of these grammars , it is not clear whether they can be automatically applied to known ncRNA search including pseudoknots .In this work , we design an efficient pseudoknot search algorithm for all types of pseudoknots .Our method is based on a set of carefully chosen simple sub - structures ( or sub - structures for short ) , which do not contain pseudoknots or bifurcations .The time complexity of the parsing and probability computation algorithms for an SCFG including the CYK , the inside , and the outside algorithm will be significantly reduced when the secondary structure does not contain any bifurcation [ 10 , 16 ] .", "label": "", "metadata": {}}
{"text": "For multiple sub - structures extracted from one ncRNA family , we choose a set of sub - structures according to their sizes and false positive ( FP ) rates in order to maximize the search performance .These chosen sub - structures will be used in a progressive search .Our experimental results show that our tool competes favorably with other pseudoknot search methods .Related work .Brown and Wilson [ 17 ] proposed an RNA pseudoknot search method using intersections of SCFGs .Both Brown 's method and our approach try to decompose pseudoknot into knot - free structures for SCFG modeling .", "label": "", "metadata": {}}
{"text": "First , our sub - structures are not only knot - free , but also bifurcation free , which enables faster search .Second , while Brown and Wilson 's method focused on the model construction and parsing algorithm , we focus on choosing an optimal set of sub - structures to optimize the search performance .The model construction and the parsing algorithms can be conveniently implemented using Infernal , which has gone through extensive testing .Structural motifs similar to sub - structures have been used as filters to speed up Infernal .FastR [ 18 ] relies on stem - loops ( ( k , w ) -stack ) that do not contain bulge or interior loops to search for ncRNAs .", "label": "", "metadata": {}}
{"text": "[19 ] use more flexible structural motifs based on sub - CMs and profile HMMs for ncRNA classification .Smith [ 16 ] used a decision tree to organize partial SCFG models for fast ncRNA search .Currently , these filters are only designed and tested for speeding up SCFG search .Available pseudoknot search tools include RNAv [ 20 ] and RNATOPS [ 21 ] .RNATOPS designs a graph model for RNA pseudoknots and solves the structure sequence alignment by graph optimization .RNAv is a profile based RNA secondary structure variation search program that detects distant ncRNA structural homologs , which might be missed by RNATOPS .", "label": "", "metadata": {}}
{"text": "[ 22 ] consists of a collection of short conserved words in an ncRNA family .In our work , we use a collection of simple sub - structures for pseudoknot search .Similar to Zhang et al . 's work , we find that using a collection of simple structures can achieve a good tradeoff between sensitivity and false positive rate during search .Approach .There are two components in the method .The first component is the design of a set of sub - structures to represent an ncRNA family .The second component is a progressive search strategy using the designed sub - structures .", "label": "", "metadata": {}}
{"text": "Well - conserved structural and sequence motifs tend to yield better search performance than poorly conserved motifs .Our approach sorts sub - structures extracted from different regions according to their lengths and predicted FP rates in order to choose a set of sub - structures with the optimal search performance .For a chosen set of sub - structures , we conduct a progressive search according to a pre - determined order .During the progressive search , one sub - structure is only applied to regions containing matches to all previous sub - structures .A sequence is classified into the pseudoknot family if and only if 1 ) it passes the score thresholds of all the chosen sub - structures ; 2 ) the position relationship between matched substrings is consistent with the relationship between the sub - structures .", "label": "", "metadata": {}}
{"text": "The pipeline of the approach is illustrated in Figure 2 .Sub - structure derivation .In order to use SCFG - based models for pseudoknot search , we decompose a pseudoknot structure into simple sub - structures .Each sub - structure contains at least one stem , which includes a set of stacking base pairs allowing short bulge and interior loops .A full secondary structure of an ncRNA family can be decomposed into multiple stems .Combinations of stems define different sub - structures .Figure 3 shows all five simple sub - structures derived from the given pseudoknot .", "label": "", "metadata": {}}
{"text": "Each arc represents a stem containing nested base pairs and possible internal / bulge loops .Single - stranded regions are represented using solid lines .We describe a method to systematically extract all simple sub - structures from a pseudoknot .In the first step , all stems are extracted and sorted in increasing order of their starting positions ( i.e. 5 ' end of the outmost base pair in the stem ) .Second , we build a bit table R of size N by N for N stems extracted from the first step .Table R provides us information about whether given stems can form one sub - structure .", "label": "", "metadata": {}}
{"text": "In the pseudocode , H x is the set of sub - structures containing x stems .The number of sub - structures depends on the number of nested stems .Suppose the average number of nested stems inside a stem is n .The total number of sub - structures is O ( N + N 2 n ) .Algorithm 1 ExtractSubstructures Input : a secondary structure containing pseudoknots Output : all simple sub - structures . end for .end for .Algorithm 1 only outputs the combination of stems .For each stem ( or stem set ) in a sub - structure , we add loop and flanking regions using the following three rules .", "label": "", "metadata": {}}
{"text": "Rule 1 : Add all single - stranded regions including bulge and internal loops between I 5 and I 3 .Rule 2 : Except the base pairs inside the chosen stems in a sub - structure , all other base pairs will be treated as single - stranded regions .Rule 3 : Extend the flanking single - stranded regions to the left of I 5 and to the right of I 3 until the first base pair in other sub - structures .Search performance of different sub - structures .Each sub - structure can be conveniently modeled by an SCFG .", "label": "", "metadata": {}}
{"text": "In this section , we use an example to illustrate this .We built SCFGs for eight sub - structures derived from RF00373 ( Ribonuclease P ) and evaluated the sensitivity , FP rates , and running time of the eight SCFGs when applying them to a to a 22.5 M Maize genome ( data is described in \" Experimental results \" ) .The sensitivity and FP rates of different sub - structures from the same family can be compared using true positive ( TP ) hits and FP hits respectively , because the condition positive and condition negative sets are the same for all sub - structures derived from the same family .", "label": "", "metadata": {}}
{"text": "Let the set of true pseudoknot sequences be S , which are the sequences in seed families containing pseudoknots in Rfam .The number of true positive and FP matches of a sub - SCFG is and , respectively .We summarized the TP hits and FP matches of eight SCFGs under different score thresholds in Figure 4 .In addition , the search times are included for the score thresholds corresponding to the highest sensitivity .It is clear that different SCFGs have highly search performance .During a progressive search using a series of sub - structures , the number of matches of the preceding sub - structure determines the search space of the current sub - structure .", "label": "", "metadata": {}}
{"text": "In order to maximize the search efficiency , it is important to sort all candidate sub - structures according to their FP rates .When the FP rates of two or more sub - structures are similar ( same order ) , we prefer shorter models because they incur less search times .Number of TP hits and FP matches of each sub - structure under different score thresholds .For each sub - structure , the length and the search time corresponding to the highest sensitivity is listed .Time format is hr : min : sec .Due to highly different number of FP hits , two sub - structures are plotted in the embedded figure .", "label": "", "metadata": {}}
{"text": "There are two methods to calculate the FP rates of sub - structures .Theoretically , by assuming a background model for random sequences and applying the CYK algorithm [ 10 ] , we can directly calculate the probability that a random sequence matches an SCFG model .Empirically , we can apply the SCFGs to a large annotated sequence database and record the number of FP matches .However , as it is more important to compare the FP rates of different sub - structures than knowing their exact values , it is not necessary to directly calculate FP rates .", "label": "", "metadata": {}}
{"text": "For an alignment score and a database size , an E - value indicates how many random hits a user can expect to see with the same or better score in a random sequence database of similar size .Thus , E - value indicates FP hits when it can be computed accurately .Currently , we are using the E - value calculation method provided by Infernal .Although the assumed score distribution is not accurate , we found that the estimated E - values allow us to compare FP rates of different sub - structures with high accuracy .", "label": "", "metadata": {}}
{"text": "These N random sequences then are aligned against the model .Scores of the top X hits are assumed to follow an exponential distribution with two parameters , \u03bc and \u03bb .The maximum likelihood approach is then taken to fit scores of hits into an exponential distribution .In the E - value computation , \u03bc and \u03bb are parameters trained in Infernal .sc is the score for which one needs to calculate E - value . db target is the size of target database . db random is the number of random sequences generated for curve fitting .", "label": "", "metadata": {}}
{"text": "We can directly obtain \u03bc and \u03bb from each calibrated covariance model , which is built for a sub - structure .With these two parameters available , we can use the above equation to compute E - values for given scores .Our experiments show that although the change of E - values does not scale with the change of the FP rates , the order of E - values is highly consistent to the order of FP rates for all 71 families we tested .Only for SCFGs with similarly small FP rates , their E - values can not accurately reflect their order .", "label": "", "metadata": {}}
{"text": "It is worth noting that we also considered to use the average entropy to sort the sub - structures .However , our experiments show that there is no systematic relationship between entropy - based measurements and the FP rates of sub - structures .Table 1 .The order of E - values is highly consistent to the order of number of the FP hits .Choose sub - structures for progressive search .During a progressive search based on multiple sub - structures , the final sensitivity is bounded by the lowest sensitivity of all sub - structures .", "label": "", "metadata": {}}
{"text": "Let the size of the original database be L. For a sub - structure , let t i and fp i be its search time per hit and FP rate , respectively .The final FP rate is bounded by .The final search time is roughly , where is roughly the search space for the sub - structure .Minimizing T requires the accurate computation of t i or quantification of the relationship between t i and fp i , which is not known as a priori .Although Infernal provides estimated running time , it can be quite different from the true running time .", "label": "", "metadata": {}}
{"text": "Thus we develop a greedy algorithm to generate a set of sub - structures for progressive search based on our empirical observations .We split sub - structures into short group and long group , which contain short and long sub - structures respectively .For each group of sub - structures , we sort the sub - structures according to their E - values and apply a greedy algorithm to choose a set of sub - structures for search .The main steps of the greedy algorithm are outlined below , starting from the short group : .In each iteration , choose the sub - structure with the smallest E - value .", "label": "", "metadata": {}}
{"text": "Remove any remaining sub - structure in both groups that only contains stems in this sub - structure .Repeat the first step until all stems are covered by one chosen sub - structure or the E - values of all remaining sub - structures are bigger than a pre - determined cutoff ( default is 1 ) .If has not included all stems , we apply the same process to the long group and append the chosen sub - structures to .We require all stems covered by the chosen sub - structures in order to ensure the representation of the annotated pseudoknot structure .", "label": "", "metadata": {}}
{"text": "Currently , we use size 150 as the threshold to divide sub - structures into the short and the long group .Implementation .For each sub - structure , we train an SCFG - based model based on the corresponding alignment in the training data using Infernal .Let the SCFGs trained from n sub - structures of an ncRNA family be , where represents a single SCFG .A sequence can be classified into the corresponding family if the following conditions are satisfied .First , the sequence contains matches to all designed SCFGs in \u03a0. SCFG match will be defined in the following text .", "label": "", "metadata": {}}
{"text": "There are three types of position relationship between two sub - structures : parallel , nested , and cross - over .Cross - over indicates existence of pseudoknots .We determine SCFG match using score thresholds .For all sequences in the training set , its alignment score with a given SCFG is computed .The minimum score of all the seed sequences is used as the score threshold .This score cutoff is similar to the NC ( trusted cutoff ) bit score thresholds used in HMMER [ 23 ] or Infernal .When the training data contains a good representation of the family member sequences , the computed score threshold can ensure a high sensitivity during homology search .", "label": "", "metadata": {}}
{"text": "Experimental results .In order to test the performance of our tool for pseudoknot search in sequence databases , we conducted two experiments .First , we examined the automatically classified pseudoknot sequences in Rfam .Second , we applied it to part of the Maize genome .On the same data set , we compared our tool with RNAv , RNATOPS , and Infernal .Pseudoknot sequences in Rfam .Because CFG can not model pseudoknots , the implementations of Stochastic CFG ( SCFG ) , covariance models ( CMs ) in Rfam neglect pseudoknots in the structures .", "label": "", "metadata": {}}
{"text": "Each Rfam family contains a seed sequence set and a full sequence set .While the seed sequence set contains manually validated homologous sequences , the full sets are automatically produced using SCFG - based search against RFAMSEQ database [ 6 ] .Thus , some of the sequences in the full set may not contain pseudoknot structures that are annotated in the seed sequences .We examined the full member set of the 71 ncRNA families containing pseudoknots in Rfam using our tool .Many families contain dozens of sequences that lack the annotated pseudoknot structures .For all those sequences that can not be matched by our tool , we also utilized the Infernal alignments and a RNA stem finding tool RNAmotif [ 24 ] to double check whether the base pairs in pseudoknot structures are missing .", "label": "", "metadata": {}}
{"text": "By comparing the annotated base pairs and the consensus secondary structure of the seed alignments , we can extract the regions that should form pseudoknots .Then , we applied RNAmotif to output all stems of size at least two in the chosen regions .Failing to output any stems validated our findings that these sequences do not have the annotated pseudoknots .The results are summarized in Table 2 .Although homologous ncRNAs may not share the same set of stems , simply ignoring pseudoknots without knowing their impacts on the function can introduce a large number of false members .", "label": "", "metadata": {}}
{"text": "For these well - studied pseudoknot structures , it is important to include them during homology search .Table 2 .Sequences that do not contain annotated pseudoknots and thus may not be real members .Data set preparation .We created a simulated data set based on a contiguous 22-Mb region of the Maize Genome [ 25 ] .The annotation of the 22-Mb region does not contain any hit to the 71 pseudoknot families in Rfam .In order to evaluate the sensitivity of pseudoknot search tools , we randomly chose 1,586 out of 26,704 seed sequences from 71 pseudoknot families and inserted them in the 22-Mb region .", "label": "", "metadata": {}}
{"text": "In order to examine the FP rate of SCFG - based tools , we also created 1,586 sequences without pseudoknots .Specifically , for each of the 1,586 seed sequences , we altered the bases to disrupt the base pairs that can form pseudoknots .Similarly RNAmotif is applied again to ensure these sequences lose the annotated pseudoknot structure .These modified 1,586 sequences and the original 22-Mb region of the Maize Genome constitute the negative training data .Any hit to them is an FP hit .Note that by changing the bases , the modified sequences might share lower sequence similarity to the trained model and thus pose an easier case for all tools .", "label": "", "metadata": {}}
{"text": "Thus , we feel this data set is a reasonable test set .There are two major advantages of using this simulated data set for testing pseudoknot search tools .Second , using thousands of seed members of the pseudoknot families provides us adequate test data for evaluating the sensitivity .Besides using the seed sequences of Rfam , we also considered another pseudoknot sequence database Pseudobase [ 26 ] .This database contains 304 RNA sequences with pseudoknot structures .A majority of them are sub - strings of Rfam seed sequences .Thus , we choose to use Rfam seed sequences as the true label .", "label": "", "metadata": {}}
{"text": "In order to separate the training set and the test set , we removed the sequences that were inserted in the Maize genome from the seed alignments .For the alignments composed of the remaining sequences , we trained the full covariance model and the models for the sub - structures .We used the designed sub - structure sets for pseudoknot search .We evaluated the performance of pseudoknot search tools using three metrics : the sensitivity , FP hits , and running time .For each ncRNA family represented by an SCFG , let be the set of output sequences by a search tool .", "label": "", "metadata": {}}
{"text": "The sensitivity is thus defined as : .We report the FP hits instead of the FP rates for two reasons .First , the condition negative set is family specific and thus is the same for all search tools for a given family .Second , the size of the condition negative set is mainly determined by the size of the genome minus the size of all true pseudoknot sequences .For a large genomic sequence , the FP rate becomes very small and can not reflect the difference between different tools .On the same dataset , we run RNAv , RNATOPS , and Infernal 1.0.2 .", "label": "", "metadata": {}}
{"text": "For Infernal and sub - structure , no hidden Markov model - based filtration was used in order to maximize the sensitivity .Other parameters were set as default for Infernal .We used the default parameters to run RNAv and RNATOPS .Each experiment was allocated four CPU days at most .There are 65 families and 31 families that failed RNAv and RNATOPS , respectively .The search jobs for those families were killed by the cluster after four CPU days .No results were produced .Thus we could not report the results for those families .", "label": "", "metadata": {}}
{"text": "The performance of these four tools is recorded in Table 3 .The results show that our tool is significantly faster than RNATOPS and RNAv .For a majority of families , the running time is smaller than half an hour .A closer examination reveals that 99 % of the running time is attributed to the first sub - structure , which is expected .Of the six families for which RNAv successfully generated outputs , they all have the sensitivity of 1.0 , equal to the sensitivity of sub - structure based search .Of the 40 families for which RNATOPS reported results , 14 of them have equal sensitivity to ours .", "label": "", "metadata": {}}
{"text": "Thus , overall , our search achieves higher sensitivity than RNAv and RNATOPS .In addition , sub - structure based search tool incurs lower FP rate than RNATOPS and RNAv .Table 3 shows that RNATOPS yields low FP hits .Of the 40 families , RNATOPS has the same number of FP hits as ours for only one family and significantly more FP hits for the rest .In particular , RNATOPS outputs over 1,000 hits for 9 families .Table 3 .Sensitivity , FP hits , and running time comparison between RNAv , RNATOPS , Infernal , and sub - structure .", "label": "", "metadata": {}}
{"text": "The empty cells indicate that the corresponding tools did not generate any output within 4 CPU days .We compared the sensitivity , FP hits , and running time of Infernal and our tool in Figure 5 , Figure 6 , and Figure 7 using X - Y scatter plots .As Infernal and our tool generate the same sensitivity or other metrics for some families , we use the bubble plot to visualize the number of the same data points .As expected , Infernal is highly sensitive .However , it reported dozens of hits on the pseudoknot - free sequences which we inserted as false positive sequences .", "label": "", "metadata": {}}
{"text": "In addition , it is generally slower than sub - structure - based tool .Out of 71 RNA families , sub - structure - based tool has shorter running time on 66 families .For 14 families , it yields 10x speed up over Infernal .Running Time comparison .There are 4 families on which Infernal run much longer than on other families .To keep an appropriate scale , there running times are not displayed on the figure .There is no significant difference in the sensitivity between Infernal and sub - structure - based tool when the average sequence length in a family is not too long .", "label": "", "metadata": {}}
{"text": "The major reason behind our worse sensitivity on the long families is that we use sub - structure that cover every stem .Thus , we only classify sequences that have all characterized stems from the underlying structure .However , some remote homologs may lose base pairs in stems during evolution .Thus while we guarantee to find sequences that have the same structures as the annotated pseudoknots , we can miss some homologs , leading to lower sensitivity for some families .Conclusion .Although Infernal is highly sensitive in known ncRNA search , caution must be taken when applying Infernal to ncRNA families containing pseudoknots .", "label": "", "metadata": {}}
{"text": "These sub - structures do not contain pseudoknots or bifurcations .SCFGs can be conveniently built on them and searched with high efficiency .In order to minimize the overall FP rate and the running time , we sorted sub - structures according to their lengths and their E - values for designed trusted cutoff ( NC ) bit score thresholds .We designed a greedy algorithm to choose a set of sub - structures and applied the progressive search to minimize search time .Our experimental results showed that our tool competes favorably with RNAv and RNATOPs , both of which have been used for pseudoknot search in large databases .", "label": "", "metadata": {}}
{"text": "Currently our tool only reports homologous ncRNAs with the same number of characterized stems as the training data .As a result , some true homologs that have lost one or multiple stems will be ignored .As part of the future work , we plan to incorporate available RNA - seq data for remote homology search .Declarations .The publication costs for this article were funded by NSF DBI-0953738 and IOS-1126998 .Declarations .Acknowledgements .This work was partially supported by the NSF grants DBI-0953738 and IOS-1126998 .Competing interests .The authors declare that they have no competing interests .", "label": "", "metadata": {}}
{"text": "YS proposed the original idea and algorithms .YS and CY both contibuted to experiment design .CY conducted the experiments and implemented the algorithms .Both Authors read and approved the final manuscript .Authors ' Affiliations .Department of Computer Science and Engineering Michigan State University East Lansing .References .Griffiths - Jones S : Annotating Noncoding RNA Genes .Annual Review of Genomics and Human Genetics 2007 , 8 : 279 - 298 .PubMed View Article .Staple DW , Butcher SE : Pseudoknots : RNA Structures with Diverse Functions .PLoS Biology 2005 , 3 ( 6 ) : e213 .", "label": "", "metadata": {}}
{"text": "Gilley D , Blackburn EH : The telomerase RNA pseudoknot is critical for the stable assembly of a catalytically active ribonucleoprotein .PNAS 1999 , 96 ( 12 ) : 6621 - 6625 .PubMed View Article .Chen JL , Greider CW : Functional analysis of the pseudoknot structure in human telomerase RNA .PNAS 2005 , 102 ( 23 ) : 8080 -8085 .PubMed View Article .Wower IK , Zwieb C , Wower J : Contributions of Pseudoknots and Protein SmpB to the Structure and Function of tmRNA in trans - Translation .the Journal of Biological Chemistry 2004 , 279 ( 52 ) : 54202 - 54209 .", "label": "", "metadata": {}}
{"text": "Gardner P , Daub J , Tate J , Nawrocki E , Kolbe D , Lindgreen S , Wilkinson A , Finn R , Griffiths - Jones S , Eddy S , Bateman A : Rfam : updates to the RNA families database .Nucleic Acids Research 2008 , 37 ( Database ) : D136-D140 .PubMed View Article .Nawrocki EP , Kolbe DL , Eddy SR : Infernal 1.0 : Inference of RNA alignments .Bioinformatics 2009 , 25 : 1335 - 1337 .PubMed View Article .Klein RJ , Eddy SR : RSEARCH : finding homologs of single structured RNA sequences .", "label": "", "metadata": {}}
{"text": "PubMed View Article .Lowe T , Eddy SR : TRNAscan - SE : a program for improved detection of transfer RNA genes in genomic sequence .Nucleic Acids Res 1997 , 25 : 955 - 64 .PubMed .Durbin R , Eddy SR , Krogh A , Mitchison G : Biological Sequence Analysis : Probabilistic Models of Proteins and Nucleic Acids .UK : Cambridge University Press ; 1998 .View Article .Cai L , Malmberg RL , Wu Y : Stochastic modeling of RNA pseudoknotted structures : a grammatical approach .Bioinformatics 2003 , 19 ( Suppl . 1 ) : i66-i73 .", "label": "", "metadata": {}}
{"text": "Rivas E , Eddy SR : The language of RNA : a formal grammar that includes pseudoknots .Bioinformatics 2000 , 16 ( 4 ) : 334 - 340 .PubMed View Article .Uemura Y , Hasegawa A , Kobayashi S , Yokomori T : Tree adjoining grammars for RNA structure prediction .Theoretical Computer Science 1999 , 210 ( 2 ) : 277 - 303 .View Article .Matsui H , Sato K , Sakakibara Y : Pair stochastic tree adjoining grammars for aligning and predicting pseudoknot RNA structures .Bioinformatics 2005 , 21 ( 11 ) : 2611 - 2617 .", "label": "", "metadata": {}}
{"text": "Kato Y , Seki H , Kasami T : RNA Pseudoknotted Structure Prediction Using Stochastic Multiple Context - Free Grammar .IPSJ Digital Courier 2006 , 2 : 655 - 664 .View Article .Smith JA : RNA Search with Decision Trees and Partial Covariance Models .IEEE / ACM Trans Comput Biol Bioinform 2009 , 6 ( 3 ) : 517 - 527 .PubMed View Article .Brown M , Wilson C : RNA pseudoknot modeling using intersections of stochastic context free grammars with applications to database search .Pac Symp Biocomput 1996 , 109 - 125 .", "label": "", "metadata": {}}
{"text": "PubMed View Article .Weinberg Z , Ruzzo W : Exploiting conserved structure for faster annotation of non - coding RNAs without loss of accuracy .Bioinformatics 2004 , 20 ( suppl . 1 ) : i334 - 40 .PubMed View Article .Huang Z , Malmberg R , Mohebbi M , Cai L : RNAv : Non - coding RNA secondary structure variation search via graph homomorphism .In CSB Conference Proceedings .CA , USA ; 2010:56 - 69 .Huang Z , Wu Y , Robertson J , Feng L , Malmberg RL , Cai L : Fast and accurate search for non - coding RNA pseudoknot structures in genomes .", "label": "", "metadata": {}}
{"text": "PubMed View Article .Zhang S , Borovok I , Aharonowitz Y , Sharan R , Bafna V : A sequence - based filtering method for ncRNA identification and its application to searching for riboswitch elements .Bioinformatics 2006 , 22 : e557 - 65 .PubMed View Article .Macke T , Ecker D , Gutell R , Gautheret D , Case D , Sampath R : RNAMotif - A new RNA secondary structure definition and discovery algorithm .Nucleic Acids Research 2001 , 29 : 4724 - 4735 .PubMed View Article .Wei F , Stein JC , Liang C , et al .", "label": "", "metadata": {}}
{"text": "PLoS Genet 2009 , 5 ( 11 ) : e1000728 .PubMed View Article .van Batenburg FHD , Gultyaev AP , Pleij CWA , Ng J , Oliehoek J : PseudoBase : a database with RNA pseudoknots .Nucleic Acids Research 2000 , 28 : 201 - 204 .PubMed View Article .Copyright .\u00a9 Yuan and Sun ; licensee BioMed Central Ltd. 2013 .This article is published under license to BioMed Central Ltd. Abstract .Background .Random biological sequences are a topic of great interest in genome analysis since , according to a powerful paradigm , they represent the background noise from which the actual biological information must differentiate .", "label": "", "metadata": {}}
{"text": "Similarly , random object of a more complicated structure like RNA molecules or proteins are of interest .Results .In this article , we present a new general framework for deriving algorithms for the non - uniform random generation of combinatorial objects according to the encoding and probability distribution implied by a stochastic context - free grammar .Briefly , the framework extends on the well - known recursive method for ( uniform ) random generation and uses the popular framework of admissible specifications of combinatorial classes , introducing weighted combinatorial classes to allow for the non - uniform generation by means of unranking .", "label": "", "metadata": {}}
{"text": "We address the random generation of these structures according to a realistic distribution obtained from real - life data by using a very detailed context - free grammar ( that models the class of RNA secondary structures by distinguishing between all known motifs in RNA structure ) .Compared to well - known sampling approaches used in several structure prediction tools ( such as SFold ) ours has two major advantages : Firstly , after a preprocessing step in time .O .n .for the computation of all weighted class sizes needed , with our approach a set of m random secondary structures of a given structure size n can be computed in worst - case time complexity .", "label": "", "metadata": {}}
{"text": "n . log .n . ) while other algorithms typically have a runtime in .O . m .n .Secondly , our approach works with integer arithmetic only which is faster and saves us from all the discomforting details of using floating point arithmetic with logarithmized probabilities .Conclusion .A number of experimental results shows that our random generation method produces realistic output , at least with respect to the appearance of the different structural motifs .A link to download an implementation of our method ( in Wolfram Mathematica ) can be found there , too .", "label": "", "metadata": {}}
{"text": "Random generation stochastic context - free grammars RNA secondary structures .Electronic supplementary material .The online version of this article ( doi : 10 .1186/\u200b1748 - 7188 - 6 - 24 ) contains supplementary material , which is available to authorized users .Background and Introduction .The topic of random generation algorithms ( also called samplers ) has been widely studied by computer scientists .As considers software engineering , the so - called random testing approach is commonly used to test implementations of particular algorithms , as it is usually not feasible to consider all possible inputs and unknown which of these inputs are among the most interesting ones .", "label": "", "metadata": {}}
{"text": "In the Bioinformatics area , algorithms for generating random biological sequences have been investigated for a long time ( see e.g. [ 2 , 3 ] ) .As stated in [ 4 ] , random sequences are a topic of great interest in genome analysis , since according to a powerful paradigm , they represent the background noise from which the actual biological information must differentiate .Thus , random generation of combinatorial objects can be used in this context for simulations studies in order to isolate signal ( unexpected events ) from noise ( statistically unavoidable regularities ) .", "label": "", "metadata": {}}
{"text": "However , it is known that these classical models can be enriched by adding structural parameters ( see [ 4 ] ) .Over the past years , several methods have been proposed for the random generation of more complex structures , where special attention has been paid to RNA secondary structures .RNA is a single - stranded nucleotide polymer and a major component of cellular processes ( like DNA and proteins ) .An RNA strand is formed by linking together certain nucleotide units .The specific sequence of nucleotides along this chain is called the primary structure of the molecule .", "label": "", "metadata": {}}
{"text": "Most of the 3D structure is determined by the intramolecular base - pairing interactions in the plane , which together form the secondary structure of the molecule .For this reason , pseudoknots ( induced by crossing base pairs ) are considered as tertiary interactions and are usually not permitted in the definition of secondary structure .As unknotted structures contain only nested base pairs and are thus essentially two - dimensional , they can be modeled as planar graphs .This rather descriptive and commonly used planar graph model for RNA secondary structures was first formalized in [ 5 ] .", "label": "", "metadata": {}}
{"text": "An RNA secondary structure .Unpaired and paired bases are represented by white and gray points , respectively .Most of the existing random generation algorithms for RNA secondary structures are used for predicting the structure of a given RNA sequence ( see e.g. [ 6 , 7 ] ) , while others can be employed for instance for evaluating structure comparison softwares [ 8 ] .Note that secondary structure prediction methods based on random sampling represent a non - deterministic counterpart to the up - to - date most successful and popular physics - based prediction methods that make use of the energy minimization paradigm and are realized by dynamic programming algorithms ( see e.g. [ 9 - 12 ] ) .", "label": "", "metadata": {}}
{"text": "In order to overcome these pitfalls , one could take the competing point of view and consider only typical structural information observed in a set of sample data as the basis for a new random generation method .If that information draws a realistic picture for all the different motifs of a molecule 's folding , the corresponding sampling method is likely to produce realistic results .Accordingly , several authors made use of stochastic context free grammars and employed machine - learning techniques to train parameter values from a set of known secondary structures .The main contribution of this manuscript is the derivation of a new and efficient algorithm for the random generation of RNA secondary structures according to an elaborate and thus very realistic model .", "label": "", "metadata": {}}
{"text": "Particularly , our random generation method is based on a sophisticated context - free grammar for unknotted structures which , in order to model the class of all considered RNA secondary structures as realistic as possible , distinguishes between all known structural motifs that may occur in unknotted RNA secondary structure .This means that any structural feature is modeled by one or more specific grammar rules with corresponding probabilities observed from real - life data .According to [ 20 ] , our sampling method involves a weighted unranking algorithm for obtaining the final structures .That way , the random sampling based on a stochastic grammar - building heavily on the use of small floating point numbers - is translated into an unranking algorithm using integer values only .", "label": "", "metadata": {}}
{"text": "In our case , the weighted unranking algorithm requires a precomputation step in worst - case time .O .n . for computing all weighted class sizes up to input size n .The worst - case complexity for generating a secondary structure of size n at random is then given by .O .n . log .n . ) since we are ranking structures according to the boustrophedon order ( see e.g. [ 7 ] ) .By the end of this paper , we analyze the quality of randomly generated structures by considering some experimental results .", "label": "", "metadata": {}}
{"text": "Their comparison measures indicate that our method actually generates realistic RNA structures .Prior Results and Basic Definitions .Uniform Random Generation .In the past , the problem of uniform random generation of combinatorial structures , that is the problem of randomly generating objects ( of a preliminary fixed input size ) of a specified class that have the same or similar properties , has been extensively studied .Special attention has been paid on the wide class of decomposable structures which are basically defined as combinatorial structures that can be constructed recursively in an unambiguous way .Second and more recently , the so - called Boltzmann method [ 1 , 26 ] , where random objects ( under the corresponding Boltzmann model ) have a fluctuating size , but objects with the same size invariably occur with the same probability .", "label": "", "metadata": {}}
{"text": "( Admissible ) Constructions and Specifications .According to [ 25 ] , a decomposable structure is a structure that admits an equivalent combinatorial specification : .If .A .A . k . are combinatorial classes and \u03f5 1 , ... , \u03f5 k are neutral objects , the combinatorial sum or disjoint union is defined as .A .A . k .A . k .A . k .Note that the constructions of disjoint union , cartesian product , sequence , set and cycle are all admissible : .The framework of ( admissible ) specifications obviously resembles that of context - free grammars ( CFGs ) known from formal language theory ( note that we assume the reader has basic knowledge of the notions concerning context - free languages and grammars .", "label": "", "metadata": {}}
{"text": "In order to translate a CFG into the framework of admissible constructions , it is sufficient to make each terminal symbol an atom and to assume each non - terminal A to represent a class .A .( the set of all words which can be derived from non - terminal A ) .However , for representing CFGs , only the admissible constructions disjoint union , cartesian product and sequence are needed : Words are constructed as cartesian products of atoms , sentential forms as cartesian products of atoms and the classes assigned to the corresponding non - terminal symbols .", "label": "", "metadata": {}}
{"text": "B .Different production rules with the same left - hand side give rise to the union of the corresponding cartesian products .Nevertheless , it should be noted that [ 25 ] also shows how to reduce specifications to standard form , where the corresponding standard specifications constitute the basis of the recursive method for uniform random generation and extends the usual Chomsky normal form ( CNF ) for CFGs .Briefly , in standard specifications , all sums and products are binary and the constructions of sequences , sets and cycles are actually replaced with other constructions ( for details see [ 25 ] ) .", "label": "", "metadata": {}}
{"text": "C . of combinatorial objects .This means they can be used to count the number of structures of a given size that are generated from a given non - terminal symbol .Moreover , standard specifications immediately translate into procedures for generating one such structure uniformly at random .The corresponding procedures ( for class size calculations and structure generations ) are actually required for ( uniform ) random generation of words of a given CFG by means of unranking .Simply speaking , the unranking of decomposable structures ( like for instance RNA secondary structures which can be uniquely decomposed into distinct structural components ) works as follows : Each structure s in the combinatorial class .", "label": "", "metadata": {}}
{"text": "n . of all feasible structures having size n is given a number ( rank ) .i . card .S .n . , defined by a particular ranking method .Based on this ordering of the considered structure class .S .n . , the corresponding unranking algorithm for a given input number .i . card .S .n . computes the single structure .s .S .n . having number i in the ranking scheme defined for class .S .n . . .Note that in this context of unranking particular elements from a considered structure class , the corresponding algorithms make heavy use of their decomposability , as the distinct structural components are unranked from the corresponding subclasses .", "label": "", "metadata": {}}
{"text": "C .n . )C . is . neutral . and .n .C . is . neutral . and .n .C . is . atomic . and .n .C . is . atomic . and .n .i . k . size .A . i .n .C .A .A . k .j .n .s .i .z .e .A .j .size .B .n .j .C .A .B . . .Note that when computing the sums for cartesian products , we can either consider the values for j in the sequential ( also called lexicographic ) order ( 1 , 2 , 3 , ... , n ) or in the so - called boustrophedon order .", "label": "", "metadata": {}}
{"text": "n .n .In either case , given a fix number of considered combinatorial ( sub)classes ( or corresponding non - terminal symbols ) , the precomputation of all class size tables up to size n requires .O .n . operations on coefficients .One random generation step then needs .O .n . arithmetic operations when using the sequential method and .O .n . log .n . ) operations when using the boustrophedon method ( for details we refer to [ 25 ] ) .Obviously , using uniform unranking procedures to construct the i th structure of size n for a randomly drawn number i , any structure of size n is equiprobably generated .", "label": "", "metadata": {}}
{"text": "Coming back to the random testing problem from software engineering , we observe that generating objects of a given class of input data according to a uniform distribution is sufficient for testing the correctness of particular algorithms .However , if one intends to gather information about the \" real - life behaviour \" of the algorithm ( e.g. with respect to runtime or space requirements ) , we need to perform simulations with input data that are as closely as possible related to corresponding application .This means to obtain suitable test data , we need to specify a distribution on the considered class that is similar to the one observed in real life and draw objects at random according to this ( non - uniform ) distribution .", "label": "", "metadata": {}}
{"text": "Details will follow in the next section .However , modeling these structures by an appropriate SCFG yields a more realistic RNA model , where the probability distribution on all structures is determined from a database of real world RNA data ( see e.g. [ 35 , 36 ] ) .Based on this observation , the problem of non - uniform random generation of combinatorial structures has been recently addressed in [ 20 ] .There , it is described how to get algorithms for the random generation of objects of a previously fixed size according to an arbitrary ( non - uniform ) distribution implied by a given SCFG .", "label": "", "metadata": {}}
{"text": "By weighting , we understand the generation of distinguishable copies of objects .Formally : .Definition 0.4 .If .A . is a combinatorial class and \u03bb is an integer , the weighting of .A . by \u03bb is defined as .We will call two objects from a combinatorial class copies of the same object iff they only differ in the tags added by weighting operations .For example , if we weight the class .A .B .Thus , .A .B . a . a .b .b .and within this class , a has relative frequency .", "label": "", "metadata": {}}
{"text": "Hence , this way it becomes possible to regard non - uniformly distributed classes .As weighting a class can be replaced by a disjoint union , . size .A .n . size .A .n . and the complexity results from [ 37 ] also hold for weighted classes .Hence , the corresponding class size computations up to n need .O .n . time .Stochastic Context - Free Grammars .As already mentioned , stochastic context - free grammars ( SCFGs ) are a powerful tool for modeling combinatorial classes and the essence of the non - uniform random sampling approach that will be worked out in this article .", "label": "", "metadata": {}}
{"text": "Basic Concepts .In fact , an SCFG is derived by equipping the productions of a corresponding CFG with probabilities such that the induced distribution on the generated language models as closely as possible the distribution of the sample data .The needed formalities are given as follows : .Definition 0.5 ( [ 38 ] ) .A weighted context - free grammar ( WCFG ) is a 5-tuple .G .I .T .R .S .W . , where I ( resp .T ) is an alphabet ( finite set ) of intermediate ( resp .", "label": "", "metadata": {}}
{"text": "G . is a WCFG , then .G . is a stochastic context - free grammar ( SCFG ) iff the following additional restrictions hold : . f .R .Q .f . )A . w .f .However , at this point , we decided to not recall the basic concepts regarding SCFGs , as they are not really necessary for the understanding of this article .The interested reader is referred to the corresponding section in [ 21 ] .For a more fundamental introduction on stochastic context - free languages , see for example [ 39 ] .", "label": "", "metadata": {}}
{"text": "To ensure that a SCFG gets consistent , one can for example assign relative frequencies to the productions , which are computed by counting the production rules used in the leftmost derivations of a finite sample of words from the generated language .For unambiguous SCFGs , the relative frequencies can actually be counted efficiently , as for every word , there is only one leftmost derivation to consider .Modeling RNA Secondary Structure via SCFGs .Besides the popular planar graph representation of unknotted secondary structures , many other ways of formalizing RNA folding have been described in literature .", "label": "", "metadata": {}}
{"text": "Moreover , there exists a one - to - one correspondence between both representations , as illustrated by the following example : .Example 0.1 .The secondary structure shown in Figure 1 has the following equivalent bar - bracket representation that can be decomposed into subwords corresponding to the basic structural motifs that are distinguished in state - of - the - art thermodynamic models : .Note that the reading order of secondary structures is from left to right , which is due to the chemical structure of the molecule .Consequently , secondary structures without pseudoknots can be encoded as words of a context - free language and the class of all feasible structures can thus effectively be modeled via a corresponding CFG .", "label": "", "metadata": {}}
{"text": "By extending it to a corresponding SCFG , we can also model the fact that specific motifs of RNA secondary structures are more likely to be folded at certain stages than others ( and not all possible motifs are equiprobable at any folding stage ) .In fact , it is known for a long time that SCFGs can be used to model RNA secondary structures ( see e.g. [ 40 ] ) .Additionally , SCFGs have already been used successfully for the prediction of RNA secondary structure [ 14 , 15 ] .Moreoever , they can be employed for identifying structural motifs as well as for deriving stochastic RNA models that are - with respect to the expected shapes - more realistic than other models [ 36 ] .", "label": "", "metadata": {}}
{"text": "Random Generation With SCFGs .SCFGs can easily be used for the random generation of combinatorial objects according to the probability distribution induced by a sample set , where the only problem is that they do not allow the user to fix the length of generated structures .In particular , given an SCFG .G . and the corresponding language ( combinatorial class ) .L .G . ) , a random word .w .L .G . ) can be generated in the following way : .Start with the sentential form S ( where S denotes the axiom of the grammar .", "label": "", "metadata": {}}
{"text": "While there are non - terminal symbols ( in the currently considered sentential form ) , do the following:1 )Let A denote the leftmost non - terminal symbol .Draw a random number r from the interval ( 0,1].i . m .p .i . must hold .i . k .p .i .r .i . k .p .i .r .i . k .p .i .i . k .p .i .If there are no more non - terminal symbols , then the currently considered sentential form is equal to a word .", "label": "", "metadata": {}}
{"text": "L .G . ) w . has been randomly generated .Note that the choice of the production made in 3 ) according to the previously drawn random number is appropriate , since it is conform to the probability distribution on the grammar rules .Example 0.2 .Afterwards , we must repeat the process , as there is still one non - terminal symbol left .Unfortunately , there is one major problem that comes with this approach for the ( non - uniform ) random generation of combinatorial objects : The underlying ( consistent ) SCFG .", "label": "", "metadata": {}}
{"text": "L .G . ) , such that we generate a word of arbitrary size .In order to fix the size , we can proceed along the following lines : .We translate the grammar .G . into a new framework which allows to consider fixed sizes for the random generation , such that .the distribution implied on .L .G . ) conditioned on any fixed size n is kept within the new framework .A well - known approach which allows for 1 ) is connected to the concept of admissible constructions used to describe a decomposable combinatorial class ( see above ) .", "label": "", "metadata": {}}
{"text": "Prob .A . i .x . size .x . )n .Prob .A .x . size .x . )n . which is the posterior probability that we used production rule f i under the condition that a word of size n is generated .There is another striking difference : length - dependent probabilities ( which by the way yield a so - called length - dependent SCFG ( LSCFG ) , see [ 42 ] , and already have been used in [ 43 ] ) , require a very rich training set .", "label": "", "metadata": {}}
{"text": "This is especially a problem when considering comprehensive CFGs that distinguish between many different structural motifs in order to get a realistic picture of the molecules ' behaviour ; such a grammar should however be preferred over simple lightweight grammars as basis for a non - uniform random generation method .Nevertheless , this problem does not surface when sticking to conventional probabilities and the corresponding traditional SCFG model .Actually , since we consider a huge CFG where all possible structural motifs are created by distinct productions , we generally obtain realistic probability distributions and RNA models ( see [ 21 ] ) .", "label": "", "metadata": {}}
{"text": "However , such algorithms typically use a linear time to sample a single base pair ( see , e.g. , [ 6 ] ) such that the time to sample a complete structure is quadratic in its length .This causes no problems for the original application of such algorithms since the sequence - dependent preprocessing which is part of their overall procedure is at least quadratic in time and thus the dominating part .Here our approach is of advantage ( replacing a factor n by log ( n ) ) and since our preprocessing only depends on the size of the structure to be generated it is performed once and stored to disk for later reuse .", "label": "", "metadata": {}}
{"text": "For this reason , we assume our unranking algorithm a valuable contribution , even though it requires a more cumbersome framework .Unranking of Combinatorial Objects .The problem of unranking can easily be solved along the composition of the objects at hand , i.e. the operations used for its construction , once we know the number of possible choices for each substructure .Assume for example we want to unrank objects from a class .C .A .B .We will assume all elements of .A . to be of smaller order than those of .", "label": "", "metadata": {}}
{"text": "( this way we use the construction of the class to imply an ordering ) .Finding the i th element of .i . card .A . )In this case , we recursively call the unranking procedure for .A .Otherwise ( i.e. if .i . card .A . ) , we consider .B . , searching for its ( .i . card .A . ) th element .Formally , we first need to specify an order on all objects of the considered combinatorial class that have the same size .", "label": "", "metadata": {}}
{"text": "Definition 0.6 ( [ 37 ] ) .Neutral and atomic classes contain only one element , such that there is only one possible ordering .Furthermore , let . denote the ordering within the combinatorial class .C .n . , then .If .C .A .A . k . and .C .n . , then .C .n . iff .A . i . )n . and .A .j . )n . and .i .j .or .A . i . )n . and .", "label": "", "metadata": {}}
{"text": "n .C .A .B . and .C .n . , then .C .n . iff . size . size . or .j .size . size . and .A . ) j .or . and .B . )n .j .when considering the lexicographic order ( 1 , 2 , 3 , ... , n ) , which is induced by the specification .C .n .A .B .n .A .B .n .A .B .n .A .", "label": "", "metadata": {}}
{"text": "B . 0 . . .If .C .A .B . and .C .n . , then .C .n . iff .min . size . size .min . size . size . or .min . size . size .min . size . size .B . and . size . size . or .j .size . size . and .A . ) j .or . and .B . )n .j .when considering the boustrophedon order .n .n .n . , induced by the specification .", "label": "", "metadata": {}}
{"text": "n .A .B .n .A .n .B .A .B .n .A .n .B .Considering .C .n . , the actual unranking algorithms are quite straightforward .Therefore , they will not be presented here and we refer to [ 20 , 44 ] for details .Recall that in [ 20 ] , the basic approach towards non - uniform random generation is weighting of combinatorial classes , as this makes it possible that the classes are non - uniformly distributed .If those combinatorial classes are to correspond to a considered SCFG , we have to face the problem that the maximum likelihood ( ML ) training introduces rational weights for the production rules while weighting as an admissible construction needs integer arguments .", "label": "", "metadata": {}}
{"text": "This can be reached by scaling all productions by the same factor ( common denominator of all probabilities ) , while ensuring that derivations are of equal length for words of the same size ( ensured by using grammars in CNF ) .However , a much more elegant way is to scale each production according to its contribution to the length of the word generated , that is , productions lengthening the word by k will be scaled by c k .However , this rule leads to productions with a conclusion of length 1 not being reweighted , hence we have to assure that all those productions already have integral weights .", "label": "", "metadata": {}}
{"text": "We do n't want to discuss full details here and conclude by noticing that the reweighting normal form ( RNF ) keeps track of all possible issues : .Note that the last condition ( that any intermediate symbol occurs as premise of at least one production ) is not required for reweighting , but necessary for the translation of a grammar into an admissible specification .G . are WCFGs , then .G . and .G . are said to be word - equivalent iff .L .G . )L .G . and for each word .", "label": "", "metadata": {}}
{"text": "L .G . )In [ 20 ] , it is shown how to transform an arbitrary WCFG to a word - equivalent , loop - free and \u03f5 -free grammar , that grammar to one in RNF and the latter to the corresponding admissible specification .Formally : .( such that all production weights are integral ) , yielding reweighted WCFG .G .( with integral weights ) into the corresponding admissible specification .This specification ( with weighted classes ) can be translated directly- into a recursion for the function size of all involved combinatorial ( sub)classes ( where class sizes are weighted ) and . into generating algorithms for the specified ( weighted ) classes , . yielding the desired weighted unranking algorithm for generating random elements of .", "label": "", "metadata": {}}
{"text": "G .A small example that shows how to proceed from SCFG to reweighted normal form and the corresponding weighted combinatorial classes which allow for non - uniform generation by means of unranking is discussed in the Appendix .Generating Random RNA Secondary Structures .We will now consider the previously discussed approach to construct a weighted unranking algorithm that generates random RNA secondary structures of a given size according to a realistic probability distribution .As for this paper , the corresponding probability distribution will be induced by a set of sample ( SSU and LSU r)RNA secondary structures from the databases [ 45 , 46 ] , which will be referred to as biological database in the sequel .", "label": "", "metadata": {}}
{"text": "Considered Combinatorial Class .According to the common definition of RNA secondary structure , we decided to consider the combinatorial class of all RNA secondary structures without pseudoknots that meet the stereochemical constraint of hairpin loops consisting of at least 3 unpaired nucleotides , formally : .Considered SCFG Model .First , we have to find a suitable SCFG that generates .and models the distribution of the sample data as closely as possible .To reach this goal , it is important to appropriately specify the set of production rules in order to guarantee that all substructures that have to be distinguished are generated by different rules .", "label": "", "metadata": {}}
{"text": "f .p .f . k . , where .p .f .p .f . k .p .f .This way , we ensure that more common substructures are generated with higher probabilities than less common ones .Example 0.3 .A ( rather simple ) unambiguous SCFG .G . s .generating the language .L . is given by : . w .S . s .C .A . w .A .B . )C . w .A .B . )C .A . w .", "label": "", "metadata": {}}
{"text": "C .w .B .C .A . w .C .w .C .C . . .This grammar unambiguously generates .L .for the following reasons : .Every sentential form C ( B ) C ( B ) ...( B ) C obviously is generated in a unique way ; this resembles .L .L .u .L .l .u . and .l .u .l . )u . of .L .s . definition .The number of outermost pairs of brackets in the entire string uniquely determines the corresponding sentential form to be used .", "label": "", "metadata": {}}
{"text": "w .B .C .B . )C .w .B .C .B . )C .A . w .B .B . ) w .B .C .B . ) w .B .B . )C .w .B .C .B . )C .In fact , in the case of significant differences of the new probabilities ( w 5.1.1 , ... , w 5.1.4 and w 5.2 ) , we can expect a huge improvement in the model 's accuracy .Note that it is not hard to see that changes to a grammar like the ones just discussed do not change the language generated .", "label": "", "metadata": {}}
{"text": "Definition 0.10 .The unambiguous \u03f5 -free SCFG .G .^ .sto . generating exactly the language .L . is given by .sto .I . sto .sto .R . sto .S . , where .I .G .^ .sto .S .E .S .T .C .A .L .G .D .B .F .H .P .Q .R .V .W .O .J .K .M .X .Y .Z .N .", "label": "", "metadata": {}}
{"text": "^ .sto . and .R . sto .contains exactly the following rules : . p .^ .S .E .p .^ .E .S . p .^ .E .S .C .p .^ .S .A .p .^ .S .T .A .p .^ .T .E .p .^ .T .C . shape . of .exterior . loop .p .^ .C .p .^ .C .C . strands . in .", "label": "", "metadata": {}}
{"text": "p .^ .A .L . ) initiate . helix .p .^ .L .A .p .^ .L .M . initiate . stacked . pair . or .multiple . loop .p .^ .L .P .p .^ .L .Q .p .^ .L .R . initiate . interior .loop .p .^ .L .F .p .^ .L .G . initiate . hairpin . loop . or . bulge .loop .p .", "label": "", "metadata": {}}
{"text": "G .A .p .^ .G .A .D .p .^ .G .A .p .^ .G .D .A . shape . of . bulge .loop .p .^ .D .B .p .^ .B .p .^ .B .B . strands . in . bulge .loop .p .^ .F .p .^ .F .p .^ .F .H .p .^ .H .p .^ .", "label": "", "metadata": {}}
{"text": "H . hairpin . loop .p .^ .P .A .p .^ .P .A .p .^ .P .A .p .^ .P .A . small . interior .loops .p .^ .Q .O .p .^ .Q .V .p .^ .R .O .p .^ .R .W .p .^ .V .J .O .p .^ .W .J .A .p .^ .", "label": "", "metadata": {}}
{"text": "A .K . other . interior .loops .p .^ .J .p .^ .J .J .p .^ .K .p .^ .K .K . strands . in . interior .loop .p .^ .M .X .Y .p .^ .X .A .p .^ .X .U .A .p .^ .Y .Z .p .^ .Z .X .p .^ .Z .X .N .", "label": "", "metadata": {}}
{"text": "^ .N .Z .p .^ .N .U . multiple . loop .p .^ .U .p .^ .U .U . strands . in .multiple . loop .In fact , it is easy to see that the overall structure is always produced by starting with the axiom S ' , while any particular substructure or structural motif that belongs to the combinatorial ( sub)class .I . is created from the corresponding intermediate symbol I .For our application it is crucial that . sto . - as claimed its definition - is unambiguous .", "label": "", "metadata": {}}
{"text": "has been constructed starting from a simple grammar which generates .L . by iteratively replacing one production by several ones ( like we did in the previous example ) in order to distinguish more and more structural motifs but without changing the language generated .Furthermore , a standard construction to make the grammar \u03f5 -free has been applied .That way , we can be sure that . sto . generates .L .( formally this fact easily follows by obvious bi - simulation proofs for each substitution and by the proven correctness of the used construction to ensure \u03f5 -freeness ) .", "label": "", "metadata": {}}
{"text": "sto . offers for w .Eliminating all but the variable associated with the axiom and simplifying ( for this step we made use of Mathematica ) yields the single equation .from Example 0.3 which proves that for all n both grammars have the same number of derivation trees for words of size n .Knowing that both grammars generate .L .For details , see [ 20 ] and the Appendix .Furthermore , it should be mentioned that we decided to assign relative frequencies to the production rules of .sto . , since such probabilities can be computed efficiently for unambiguous SCFGs .", "label": "", "metadata": {}}
{"text": "p .^ .i .i . , by their relative frequencies , the resulting grammar .sto .has the consistency property , which means .sto . provides a probability distribution on the language .L . sto . )L .In particular , it is well - known that relative frequencies in our context yield a maximum likelihood ( ML ) estimator for the rule probabilities and thus a consistent estimator for the parameter set .We have trained the probabilities ( relative frequencies ) of .s .L . sto .given in our biological database .", "label": "", "metadata": {}}
{"text": "Table 1 .The probabilities ( relative frequencies ) for the production rules of the SCFG .50 % ) portion of the original training set and re - estimated the probabilities of all the grammar rules .This process was iterated 40 times , resulting in a sample of 40 parameter sets .Finally , for each parameter we determined its variance along this sample of size 40 .The corresponding values lay between 0 ( resulting for intermediate symbols without alternatives ; for whose productions a probability of 1 is predetermined ) and 2.87652 \u00d7 10 -6 ( resp .", "label": "", "metadata": {}}
{"text": "Derivation of the Algorithm .The elaborate SCFG .sto .Then , we can use the resulting weighted class sizes for the straightforward construction of the desired unranking algorithm .However , to improve the worst - case complexity of the resulting unranking procedure from .O .n . to .O .n . log .n . ) by using the boustrophedonic order instead of the sequential order , a simple change in Algorithm 4 ( Unranking of cartesian products ) is neccessary ( see e.g. [ 7 ] ) .A random RNA secondary structure of size n can easily be computed by drawing a random number .", "label": "", "metadata": {}}
{"text": "L .n . ) and then unranking the i th structure of size n .The worst - case runtime complexity of this procedure is equal to that of unranking and is thus given by .O .n . log .n . ) when using the boustrophedonic order .By repeating this procedure m times , a set of m ( not necessarily distinct ) random RNA secondary structures of size n can be generated in time .O . m .n . log .n . ) , where a preprocessing time of .O .", "label": "", "metadata": {}}
{"text": "Availability of Software .Furthermore , our Mathematica source code used to implement the webservice can be downloaded from our website and used under GNU public licence .Discussion .The purpose of this section is to analyze the quality of randomly generated structures by considering some experimental results .Parameters for Structural Motifs .The determined results are presented in Table 3 .Comparing the specific values of all different parameters , we can guess that our algorithm produces random RNA secondary structures that are , related to the different structural motifs and thus related to the expected shape of such structures , in most cases realistic .", "label": "", "metadata": {}}
{"text": "Table 3 .Expectation and variance of important parameters related to particular structural motifs of RNA secondary structure .Values are derived from a native sample ( our biological database ) and from a random sample , respectively .num x denotes the number of occurrences of motif x in one secondary structure and unp x ( bps x ) denotes the number of accessible unpaired bases ( base pairs ) in one substructure of type x .Related Free Energies .For further investigation on the accuracy of our random generator , we take on a completely different point of view and consider thermodynamics .", "label": "", "metadata": {}}
{"text": "Therefore , we decided to consider both the static and dynamic free energy models ( in the static model , averaged free energy contributions for the distinguished structural motifs are considered which can easily be derived from the training data ( by sequence counting ) .These averaged values actually represent the free energy contributions that have to be added for the respective whole substructures .These models are based on the well - known Turner energy model [ 22 , 23 ] and model parameters have been derived from the same biological database ( of SSU and LSU rRNAs ) that we consider in this article .", "label": "", "metadata": {}}
{"text": "Unquantified Results .Similar to [ 21 ] , we denote the free energy of a given secondary structure .s .L . according to the static and dynamic model by g stat ( s ) and g dyn ( s ) , respectively .e .n .e . r . g .y .n .E .e .n .e . r . g .y .s . ) size .s . )n . and .e .n .e . r . g .y .n .", "label": "", "metadata": {}}
{"text": "e .n .e . r . g .y .s . ) size .s . )n . k . percent of the energies in .e .n .e . r . g .y .s . ) s .L .As these analytical energy results from [ 21 ] and our unranking algorithm have been derived from the same database of real - life RNA data and by modeling the same class .L . of structures via very similar SCFGs , it seems adequate to use them for comparisons with the energies of our randomly generated structures .", "label": "", "metadata": {}}
{"text": "S . of secondary structures , we can calculate the corresponding energy points .E .P .S .e .n .e . r . g .y . ) size .s . )e .n .e . r . g .y .s . ) s .Obviously , we can also compute the corresponding \" average energy points \" .A .v .E .P .S .e .n .e . r . g .y . )n .n . card .S .", "label": "", "metadata": {}}
{"text": "S .n .e .n .e . r . g .y .s . )S .n .and the corresponding \" energy variance points \" .V . a .r .E .P .S .e .n .e . r . g .y . )n .n . card .S .n . ) s .S .n .n .e .n .e . r . g .y .s . )S .n . , respectively .To compare the energies of our randomly generated structures to the corresponding confidence interval(s ) , we decided to consider any . k . , meaning the probability that the free energy of a random RNA secondary structure of size n lies within the corresponding interval is greater than 0.5 , 0.75 , 0.9 , and 0.95 , respectively .", "label": "", "metadata": {}}
{"text": "The corresponding plots for the dynamic energy model are shown in Figure 5 .Looking at both figures , we immediately see that the energies for our set of randomly generated RNA secondary structures seem to fit to the ones for the considered RNA database and also to the corresponding analytically obtained energy results from [ 21 ] .This observation becomes even more clear by considering Figures 6 and 7 .There , we compare the previously introduced \" average energy points \" and \" energy variance points \" to the analytically determined expected free energy and corresponding variance from [ 21 ] , respectively .", "label": "", "metadata": {}}
{"text": "V . a .r .E .P . g .s .t . a .t . )Quantified Results .The previously considered energy comparisons have been presented only by unquantified plots .Therefore , there is a need to consider some sort of quantification and additionally present corresponding quantified comparison results .What really matters is the degree to which the energy ranges of the random structures agree , in distribution , with our biological database .This means we have to find out if the energies related to a random sample ( generated by our unranking method ) and those related to a native sample ( given by the structures in our biological database ) come from a common distribution .", "label": "", "metadata": {}}
{"text": "It is also known as the Wilcoxon rank - sum test [ 49 ] which however can only be applied for equal sample sizes .More specifically , the result of such a test , the so - called p - value , is a probability answering the following question : If the two samples really have the same distribution , what is the probability that the observed difference is due to chance alone ?In other words , were the deviations ( differences between the two samples ) the result of chance , or were they due to other factors and how much deviation can occur before one must conclude that something other than chance causes the differences ?", "label": "", "metadata": {}}
{"text": "s .L .n . is added to the random sample iff .[ . g .s .t . a .t .I . g .s .t . a .t .n . k . )( variant \" static \" ) . ] or .[ . g .d .y .n .I . g .d .y .n .n . k . )( variant \" dynamic \" ) . ] or .[ . g .s .t . a .t .", "label": "", "metadata": {}}
{"text": "s .t . a .t .n . k . ) and .g .d .y .n .I . g .d .y .n .n . k . )( variant \" both \" ) . ] otherwise it is rejected .This means we accept only a specified deviation of the energy energy ( s ) of the random structure s from the corresponding expected free energy \u03bc energy , n and reject structures whose energy differs too much from the expected value .s .L .n . ) , no structures are rejected .", "label": "", "metadata": {}}
{"text": "The Wilcoxon test results for our native sample together with any of a number of random sample sets generated in the previously described restricted manner , respectively , can be found in Table 4 .As we can see , the best results are achieved for the unrestricted sample sets , where all free energies of randomly generated structures were allowed during the sample creation process .These observations indicate that our weighted unranking algorithm produces random RNA secondary structures that are - related to the free energy of such structures ( in expectation and variation ) - in expectation realistic .", "label": "", "metadata": {}}
{"text": "Significance results for statistical hypothesis testing , computed by the Wilcoxon rank - sum method .Besides that , it is obvious that the computed p -values are much better for the dynamic energy model than for the static one .This underlines the suggestion made in [ 21 ] that , although both energy models have been proven to be realistic , due to the more realistic variation of free energies connected to varying loop length , the dynamic model should be used for possible applications .Conclusion .Altogether , we can finally conclude that the non - uniform random generation method proposed in this article produces appropriate output and may thus be used ( for research issues as well as for practical applications ) to generate random RNA secondary structures .", "label": "", "metadata": {}}
{"text": "Actually , our webservice can be used for generating random secondary structures of any specified type of RNA .It just requires a database of known structures for the respective RNA type as input .Note that in this work , we abstract from sequence and consider only the structure size as input for our algorithm .Thus , an interesting problem for future research would be to find a way to extend the presented realistic SCFG model to additionally deal with RNA sequence .In fact , this work and especially the considered elaborate SCFG could mark some sort of stepping stone towards new stochastic RNA secondary structure prediction methods realized by statistical random sampling .", "label": "", "metadata": {}}
{"text": "How to Construct a Weighted Unranking Algorithm from a Given SCFG .Example App-.4 .Let us consider the SCFG .G .d . , which contains the following rules : . w .S .B . w .B .B . ) w .B .C .w .C .w .C .C . . .To apply the approach presented in [ 20 ] to transform a given SCFG to RNF , the grammar needs to be \u03f5 -free and loop - free .Thus , we first have to transform grammar .", "label": "", "metadata": {}}
{"text": "d . into the following one : . w .^ .S .B . w .^ .B .B . ) w .^ .B .C .w .^ .C .w .^ .C .C . . .The transformation of .G .d .Second , we have to replace each of these chains by a specific new rule .Consequently , our new rule set is now given by .w .^ .S .B . w .^ .B .B . ) w .", "label": "", "metadata": {}}
{"text": "C .C .B .C .C .B .C .C .A .A .A .This way , we obtain the following production set : . w .^ .S .B . w .^ .w .^ .S .B .C .w .^ .w .^ .w .^ .S .B .C .w .^ .B .B . ) w .^ .w .^ .B .B .C .w .^ .", "label": "", "metadata": {}}
{"text": "^ .w .^ .B .B .C . ) w .^ .C .C .w .^ .w .^ .C .C .B .C .C .B .C .C .However , since in our case , there is obviously nothing left to do , the transformation of .G .d . into RNF is finished .For .G . d .Then , the reweighting of the production rules of ( the RNF of ) .G . d .After that , we obtain the following reweighted grammar .", "label": "", "metadata": {}}
{"text": "d .w .S .B . w .S .B .C . w .S .B .C .w .B .B . ) w .B .B .C .w .B .B .C . ) w .C .C .w .C .C .B .C .C .B .C .C .where each .W .i .i . , is integral .The ( now weighted ) grammar can easily be translated into a corresponding admissible specification , which includes the weighting of all involved combinatorial ( sub)classes , as described earlier .", "label": "", "metadata": {}}
{"text": "G .d . , this specification is given by the following equations : .S .B .S .B .C .S .B .C .B .Z .B .Z . )B .Z .B .C .Z . )B .Z .B .C .Z . )C .Z .C .C .Z .C .B .C .C .B .C .Z .C .Z .S . w .S . w .S . w .", "label": "", "metadata": {}}
{"text": "B . w .B . w .B . w .B .C .w .C .w .C . which can be simplified in the following way : .Z .Z . )Z .C .Z . )Z .Z .Z . )C .Z .C .C .Z .Z .S . w .w .C .w .Z .w .w .w .C .w .C .w .C . 2 . . .As described earlier , this specification ( with weighted classes ) derived from reweighted grammar .", "label": "", "metadata": {}}
{"text": "d . transforms immediately into a recursion for the function size of all needed combinatorial classes .For .G .d . , the recursion for the function size has the following form : . size .I .n . ) size .B .n .I .B . size .C .n .I .B .I .B . and .n . size .C .n .I .C .I .C . and .n .w . size .B .n . ) w . size .", "label": "", "metadata": {}}
{"text": "n . ) w .I .S . and .n .w . size .B .n . ) w . size .C .n . ) w .I .S . and .n .w . size .B .n . ) w . size .B .n . ) w . size .B .n . )I .B .w . size .C .n . ) w . size .C .n . )I .C . else . . .This recursive size function ( with weighted class sizes ) can now be used for the straightforward construction of a corresponding algorithm for the non - uniform generation of elements of .", "label": "", "metadata": {}}
{"text": "In this section , we give a complete and detailled description of the derivation of our weighted unranking algorithm for RNA secondary structures .The different steps are made according to the approach described in [ 20 ] to get an unranking algorithm that generates random RNA secondary structures of a given size n according to the distribution on all these structures .Considered ( unambiguous , \u03f5 -free and loop - free ) SCFG .First , note that in [ 21 ] , to obtain the stochastic model for RNA secondary structures derived from real - world RNA data , the following unambiguous SCFG which unambiguously generates exactly the language .", "label": "", "metadata": {}}
{"text": "given in Definition 0.9 has been used : .Definition App-.11 .The unambiguous SCFG .G . sto . generating exactly the language .L . is given by .G . sto .I .G . sto .G . sto .R .G . sto .S . ) , where .I .G . s .t .o .S .T .C .A .L .G .B .F .H .P .Q .R .J .K .M .N .G . sto . and .", "label": "", "metadata": {}}
{"text": "G . sto .contains exactly the following rules : . p .S .T .A .C .p .T .T .A .C .p .T .C .p .C .C .p .C .p .A .L . )p .L .L . )p .L .M .p .L .P .p .L .Q .p .L .R .p .L .F .p .L .G .p .G .", "label": "", "metadata": {}}
{"text": "p .G .L . )B .p .G .L . )p .G .B .L . )p .B .B .p .B .p .F .p .F .p .F .H .p .H .H .p .H .p .P .L . )p .P .L . )p .P .L . )p .P .L . )p .Q .L . )K .p .Q .", "label": "", "metadata": {}}
{"text": "L . )K .p .R .L . )K .p .R .J .L . )p .J .J .p .J .p .K .K .p .K .p .M .U .L . )U .L . )N .p .N .U .L . )N .p .N .U .p .U .U .p .U .\u03f5 . . .In this grammar , different intermediate symbols have been used to distinguish between different substructures .", "label": "", "metadata": {}}
{"text": "However , as \u03f5 -freeness and loop - freeness are required preliminarily , we have to consider another unambiguous SCFG generating the same language .L . , where we have to guarantee that the same substructures are distinguished as are distinguished in .G . sto . . .Using the usual way of transforming a non-\u03f5 -free grammar into an \u03f5 -free one , the following definition can immediately be obtained from the previous one : .Definition App-.12 .The unambigous and \u03f5 -free SCFG .G . sto . generating exactly the language .L . is given by .", "label": "", "metadata": {}}
{"text": "t .o .I .G . s .t .o .G . s .t .o .R .G . s .t .o .S . , where .I .G . s .t .o .S .S .T .C .A .L .G .B .F .H .P .Q .R .J .K .M .N .G . sto . and .R .G . s .t .o .contains exactly the following rules : . p .", "label": "", "metadata": {}}
{"text": "S . p .S .A . p .S .A .C .p .S .T .A . p .S .T .A .C .p .T .A .p .T .A .C .p .T .T .A .p .T .T .A .C .p .T .C .p .C .p .C .C .p .A .L . )p .L .L . )p .L .", "label": "", "metadata": {}}
{"text": "p .L .P .p .L .Q .p .L .R .p .Affiliated with .Abstract .Background .Pairwise stochastic context - free grammars ( Pair SCFGs ) are powerful tools for evolutionary analysis of RNA , including simultaneous RNA sequence alignment and secondary structure prediction , but the associated algorithms are intensive in both CPU and memory usage .The same problem is faced by other RNA alignment - and - folding algorithms based on Sankoff 's 1985 algorithm .It is therefore desirable to constrain such algorithms , by pre - processing the sequences and using this first pass to limit the range of structures and/or alignments that can be considered .", "label": "", "metadata": {}}
{"text": "We demonstrate how flexible classes of constraint can be imposed , greatly reducing the computational costs while maintaining a high quality of structural homology prediction .Any score - attributed context - free grammar ( e.g. energy - based scoring schemes , or conditionally normalized Pair SCFGs ) is amenable to this treatment .It is now possible to combine independent structural and alignment constraints of unprecedented general flexibility in Pair SCFG alignment algorithms .We outline several applications to the bioinformatics of RNA sequence and structure , including Waterman - Eggert N - best alignments and progressive multiple alignment .", "label": "", "metadata": {}}
{"text": "Conclusion .A program , Stemloc , that implements these algorithms for efficient RNA sequence alignment and structure prediction is available under the GNU General Public License .Background .As our acquaintance with RNA 's diverse functional repertoire develops [ 1 - 5 ] , so does demand for faster and more accurate tools for RNA sequence analysis .In particular , comparative genomics approaches hold great promise for RNA , due to the well - behaved basepairing correlations in an RNA gene family with conserved secondary structure ( at least , well - behaved compared to protein structures ) .", "label": "", "metadata": {}}
{"text": "Many programs for comparative analysis of RNA require the sequences to be prealigned [ 7 - 9 ] .This can be a source of error , since misaligned bases can add noise that swamps the covariation signal .The most recent of these methods allows for some uncertainty in the alignment [ 7 ] .More generally , one can view the alignment and structure prediction as a combined problem , to be solved simultaneously .In this framework , fixing of the alignment can be viewed as a partial constraint on the simultaneous alignment / folding problem .", "label": "", "metadata": {}}
{"text": "The energy - based folding of Zuker et al [ 15 ] and recent approaches based on Stochastic Context - Free Grammars ( SCFGs ) [ 9 , 13 , 16 - 20 ] are both closely related to Sankoff 's algorithm .The method takes time O ( L 3 N ) and memory O ( L 2 N ) for N sequences of length L .This is prohibitively expensive at the time of writing , except for fairly short sequences , which has motivated the development of various constrained versions of these algorithms [ 9 - 11 , 13 , 21 ] .", "label": "", "metadata": {}}
{"text": "The overall aim is the simultaneous alignment and structure prediction of two RNA sequences , X and Y , subject to an SCFG - based scoring scheme and user - supplied constraints .Additionally , we wish to be able to parameterize the model automatically from training data .Without constraints , the above tasks are addressed by the resource - intensive CYK and Inside - Outside algorithms ; here , we present constrained versions of these algorithms that work in reduced space and time ( the exact complexity depends nontrivially on the constraints ) .Our system of constraints is quite general .", "label": "", "metadata": {}}
{"text": "Alternately , constraints on the accessible structures [ 13 ] or alignments [ 9 ] have been described .The algorithms described here can reproduce nearly all such banding constraints and , further , can take advantage of more flexible sequence - tailored constraints .Specifically , the fold envelopes determine the subsequences of X and Y that can be considered by the algorithm , while the alignment envelope determines the permissible cutpoints in the pairwise alignment of X and Y .The fold envelopes can be used to prune the search over secondary structures ( e.g. by including / excluding specific hydrogen - bonded base - pairings ) , while the alignment envelopes can be used to prune the search over alignments ( e.g. by including / excluding specific residue - level homologies ) .", "label": "", "metadata": {}}
{"text": "The algorithms have been implemented in a freely available program for RNA sequence alignment , stemloc , which also includes algorithms to determine appropriate constraints in an automatic fashion .Results demonstrating the program 's efficient resource usage are presented .The stemloc program also implements various familiar extensions to pairwise alignment , including local alignment [ 23 ] , Waterman - Eggert N -best suboptimal alignments [ 24 ] and progressive multiple alignment [ 25 ] .Although the envelope framework , rather than these extensions , is the main focus of this paper , implementation of the extensions is straightforward within this framework , and is briefly described .", "label": "", "metadata": {}}
{"text": "To investigate the comparative resource usage of the various different kinds of constraint that can be applied using fold and alignment envelopes , stemloc was tested on 22 pairwise alignments taken from version 6.1 of RFAM [ 37 ] , spanning 7 different families of functional noncoding RNA .Each chosen test family had a consensus secondary structure published independently in the literature , and no two sequences in the test set had higher than 60 % identity .The EMBL accession numbers and co - ordinates of all sequences are listed in Table 5 .The table shows the performance of stemloc using the 1000-best fold envelope and the 100-best alignment envelope .", "label": "", "metadata": {}}
{"text": "N -best alignments , all folds .The alignment envelope containing the N best primary sequence alignments , with the unconstrained fold envelopes ( stemloc options : ' --nalign N --nfold -1 ' ) .This is the red curve in Figures 8 , 9 , 10 , 11 , 12 , 13 .Peak memory usage of stemloc ( i.e. the size of the principal CYK matrix ) as a function of envelope size parameter N for three different test regimes .N -best folds , all alignments .The unconstrained alignment envelope , with the fold envelopes containing the N best single - sequence structure predictions ( stemloc options : ' --nalign -1 --nfold N ' ) .", "label": "", "metadata": {}}
{"text": "N -best folds , 100-best alignments .The alignment envelope containing the 100 best primary sequence alignments , with the fold envelopes containing the N best single - sequence structure predictions ( stemloc options : ' --nalign 100 --nfold N ' ) .This is the blue curve in Figures 8 , 9 , 10 , 11 , 12 , 13 .In the first two tests , N was varied from 1 to 100 ; in the latter test , N was varied from 1 to 10000 .The lower ceiling for N in the first two tests was imposed by resource limitations .", "label": "", "metadata": {}}
{"text": "As N was increased over the range , the size of the corresponding fold or alignment envelopes was found to be strongly correlated ( Figures 6 , 7 ) .However , the actual size of the fold / alignment envelopes in each particular test case varies widely ( see large error bars in Figures 6 , 7 ) , perhaps due to variable factors such as the sequence lengths , compositions and/or identities .Since it is easier to control the envelope construction parameter N than to control the envelope sizes directly , the following section will report performance indicators as a direct function of N , rather than as a function of the strongly - correlated but widely - varying envelope sizes .", "label": "", "metadata": {}}
{"text": "Suppose that A is the alignment according to RFAM , and B is the alignment predicted by stemloc .Suppose that S is the published structure , and T is the structure predicted by stemloc .These performance indicators are averaged over all 22 pairwise alignments and plotted for the three test regimes in Figure 8 ( alignment sensitivity ) , Figure 9 ( alignment specificity ) , Figure 10 ( basepair sensitivity ) and Figure 11 ( basepair specificity ) .The tests were performed on a 2.3 GHz Apple PowerPC G5 .The resource usages of the test regimes are plotted in Figure 12 ( user - mode running time ) and Figure 13 ( memory usage ) .", "label": "", "metadata": {}}
{"text": "This is especially notable when contrasting the resource usage of the \" N -best folds , all alignments \" test with the more constrained \" N -best folds , 100-best alignments \" test .Three main conclusions can be drawn from these data .First , allowing the search to consider more than a single alignment greatly improves structure prediction ( the red curve ) .Second , constraining the alignment search while exhaustively scanning fold space ( the red curve ) outperforms constraining the fold search while exhaustively scanning alignment space ( the green curve ) .", "label": "", "metadata": {}}
{"text": "Memory is the limiting factor in pairwise RNA alignment , and the primary motivation for constraints .For example , without constraints , alignment of two 16S ribosomal subunits using the stemloc grammar would take approximately 500 terabytes .( Using fold envelope constraints with structures fully specified , it can be done in under 5 gigabytes . )Based on the results of these tests , the default envelope options for stemloc were chosen to be the 100-best alignment envelope and the 1000-best fold envelope .The performance of stemloc with these envelopes on each of the pairwise test alignments is given in Table 5 .", "label": "", "metadata": {}}
{"text": "The algorithms presented here include constrained versions of Pair - SCFG dynamic programming algorithms that run in significantly reduced space and time .The primary advance over previous work is the simultaenous imposition of fold and alignment constraints , including alignment constraints that are more general than others previously described .Thes constraints lead to significant reductions in requirements for processor and memory usage , which will increase the length of RNA sequences that can be analyzed on mainstream computer hardware .These algorithms have been used to implement stemloc , a fast , efficient software tool for multiple RNA sequence alignment implementing numerous extra features such as local alignment , Waterman - Eggert N -best suboptimal alignment and progressive multiple alignment .", "label": "", "metadata": {}}
{"text": "For example , we have only tested the pairwise alignment functionality ; full evaluation / optimisation of the multiple alignment algorithm remains .Rather than using the CYK algorithm , one could use the Inside - Outside algorithm with a decision - theoretic dynamic programming step to maximize expected performance [ 38 , 39 ] .As noted in the Parameterization section , it might also be possible to improve on the training procedure .We are also considering ways of elaborating the grammar to include basepair stacking terms .These and other improvements we hope to address in future work .", "label": "", "metadata": {}}
{"text": "RNA sequence analysis has generated considerable interest over recent years , as many new roles for RNA in the cell have come to light .RNA genes and regulatory elements are components of many molecular systems and comparative genomics is a powerful way to probe this function , perhaps even more so for RNA than for protein ( due to the \" well - behaved \" statistical correlations found in RNAs with conserved secondary structure ) .Furthermore , statistical modeling of RNA evolution continues to play a fundamental role in the phylogenetic classification of new forms of life .", "label": "", "metadata": {}}
{"text": "It is hoped that the algorithms and approaches described here , together with development and analysis of RNA evolutionary models [ 36 ] , may expand the applications of RNA informatics .Methods .We begin our description of the envelope method with an explanatory note regarding our decision to present these constraints in terms of SCFGs , rather than other scoring schemes such as those based solely on energies [ 15 ] or on energy / information - theoretic hybrids [ 11 ] .The reason for our choice of SCFGs is simple : stochastic grammars are , in our opinion , the most theoretically well - developed of the scoring schemes used for RNA .", "label": "", "metadata": {}}
{"text": "Discussion of these algorithms is facilitated by a well - developed and widely - understood probabilistic vocabulary .Stochastic grammars are actively researched outside bioinformatics , principally in natural language processing [ 26 ] .Crucially , SCFGs are sufficiently general to express virtually all of the features offered by other scoring schemes [ 19 ] .We also acknowledge the appeal of free energy - based scoring schemes , which have the advantage that the parameters can be determined experimentally .Energy - based scores can also be used to find posterior probabilities of base - pairings using a partition function [ 27 ] .", "label": "", "metadata": {}}
{"text": "These are information - theoretic in nature and so are measured in bits , rather than kilocalories - per - mole [ 28 ] .Reconciling these two units of score ( in a principled way ) is an open problem .However , in an SCFG framework , all scores are information - theoretic and so there is no conflict of units .Despite these arguments , many people continue to find calories preferable to bits as a unit of score .For such readers , we note that the system of constraints described here is entirely applicable to the general score - attributed grammar .", "label": "", "metadata": {}}
{"text": "Notation .To implement SCFG dynamic programming algorithms efficiently for RNA , it is convenient to define a simplified ( but universal ) template for grammars , similar in principle to \" Chomsky normal form \" [ 29 , 30 ] .The form defined here is slightly different from the above forms , in that it classifies only production rules , and not nonterminals , into different types .Let be the \" ungapped RNA alphabet \" , i.e. the set of four possible nucleotides in RNA .Let be the \" gapped RNA alphabet \" , i.e. the ungapped RNA alphabet \u03a9 plus the gap symbol .", "label": "", "metadata": {}}
{"text": "Alignment envelope size is highly correlated with N in the N -best alignment test , although the variance is large due to the diversity of alignments in the test .The nonterminal L is referred to as the left - hand side ( LHS ) of the production rule and the symbol sequence R as the right hand side ( RHS ) .The allowable forms for production rules include terminations , transitions , bifurcations and emissions .These are defined as follows .There must be no transition - termination path from V or W to \u03b5 , i.e. neither V or W can have completely empty inside sequence - pairs ( see next section for a formal definition of the \" inside sequence - pair \" ) .", "label": "", "metadata": {}}
{"text": "The particular RNA normal form described in this section is chosen for ease of presentation .The implementation in the dart library uses the slightly more restrictive form for Pair SCFGs defined in an earlier paper [ 13 ] .For presentational purposes , we will generally omit all - gap columns from the pairwise alignment and the grammar .For example , an emission rule having the form would be written as instead .All - gap columns are not very interesting to a sequence analyst , and only arise in our formalism because all emission rules have the same form .", "label": "", "metadata": {}}
{"text": "The grammar generates simple alignments of stems and loops , using two nonterminals ( Stem and Loop ) ; the starting nonterminal is Stem .The rule probabilities are functions of five scalar probability parameters ( stemExtend , stemGap , bifurcate , loopExtend and loopGap ) and four arrays of probability parameters ( baseIndel[4 ] , baseSubstitution[16 ] , basepairIndel[16 ] and basepairSubstitution [ 256 ] ) .Here we introduce the notation X [ N ] for an array of N probability parameters normalized so that .It is also convenient to introduce some notation for ungapped sequences at this stage .", "label": "", "metadata": {}}
{"text": "A stochastic context - free grammar for generating pairwise alignments of RNA structures .The parse tree and the sequence likelihood .The grammar is a probabilistic model for deriving sequences X , Y from a single nonterminal .This derivation proceeds as follows : start with an initial sequence containing one starting nonterminal , S , then repeatedly apply probabilistically - sampled transformations to the nonterminals in the sequence .Eventually the sequence will contain only terminals from \u03a8. This process generates a parse tree , rooted at node S , in which internal nodes are labeled with nonterminals and leaf nodes with terminals , with children of each node ordered left - to - right ( Figure 1 ) .", "label": "", "metadata": {}}
{"text": "Note that the subtree rooted at any internal W -labeled node describes a sub - process that generates some pair of subsequences ( X ij , Y kl ) starting from nonterminal W .We will refer to this subsequence - pair ( X ij , Y kl ) as the inside sequence - pair of W .A parse tree for the grammar of Table 1 .Each internal node is labeled with a nonterminal ( Stem or Loop ) ; additionally , the subsequences ( X ij , Y kl ) generated by each internal node are shown .", "label": "", "metadata": {}}
{"text": "The parse tree likelihood is the product of all the rule probabilities corresponding to the internal nodes .This sum can be performed efficiently by the Inside algorithm , as will be described below .Dynamic programming algorithms for Pair SCFGs .The following section describes the constrained and unconstrained dynamic programming ( DP ) algorithms used for Pair SCFGs .The Inside algorithm .In RNA normal form , the emission rules ( Q 2 ) account for homologous base - pairings between residues ( X i , X j ) and ( Y k , Y l ) , or unpaired residues at X i , X j , Y k or Y l .", "label": "", "metadata": {}}
{"text": "The bifurcation rules ( Q B ( m , n ) ) account for conserved multiloop structures in the RNA , i.e. one homology between substructures X i m and Y kn and another between substructures X mj and Y nl ( Figure 3 ) .Parsing a pair of sequences ( X , Y ) using the Inside algorithm involves iterating over subsequence - pairs ( X ij , Y kl ) specified by four indices ( i , j , k , l ) .The filled cells in the rectangular grid show the aligned nucleotides .Note that the co - ordinates ( i , j , k , l ) lie on the grid - lines between the nucleotides .", "label": "", "metadata": {}}
{"text": "The filled cells in the rectangular grid show the nucleotide homologies highlighted in the alignment .Note that all co - ordinates ( i , j , k , l , m , n ) lie on the grid - lines between nucleotides .Imposing constraints .The high time and memory cost of the Inside and related algorithms motivate the development of slimmer , faster versions .To begin with , we impose constraints that narrow the search space .We can combine these various strategies into a generalized constraint on base - pairs , alignment - columns or both .", "label": "", "metadata": {}}
{"text": "Fold - related features ( basepairs and unpaired residues ) can be included or excluded by this set , and so we refer to it as a fold envelope [ 13 ] .The set is a set of possible cut - points in the alignment of X and Y , and is referred to as an alignment envelope [ 31 ] .Both types of envelope are illustrated in Figure 2 .The fold and alignment envelopes satisfy the following set relations .If equality holds in all three cases , then we recover the unconstrained Inside algorithm .", "label": "", "metadata": {}}
{"text": "As an alternative to the unconstrained Inside algorithm , we can partially initialize the envelopes to limit the maximum subsequence length and/or the maximum deviation of the alignment from the main diagonal ( Figure 4 ) .More flexibly , we can limit the recursion to a single alignment , a single structure , or a broadly - specified set of alignments or structures ( Figure 5 ) .Applications such as alignment of two known structures [ 13 , 32 ] , alignment of an unstructured sequence to a known structure [ 33 ] or structure prediction from a known alignment [ 9 ] all reduce to simple application of the appropriate constraints .", "label": "", "metadata": {}}
{"text": "These fold envelopes ( triangular grids ) and alignment envelope ( rectangular grid ) limit the subsequences ( black dots ) and cutpoints ( short diagonal lines ) to those consistent with a given alignment and consensus secondary structure ( shown ) .The alignment path is also shown on the alignment envelope as a solid black line , broken by cutpoints .Further possible constraints .The constraints given here allow the independent imposition of alignment or fold constraints .One can imagine further , even more general constraints .This constraint is employed by the FOLDALIGN program .", "label": "", "metadata": {}}
{"text": "Accelerating the iteration .Simply setting some intermediate probabilities to zero is not sufficient to accelerate the Inside algorithm .We also need to redesign the iteration to avoid visiting zero - probability subsequence - pairs ( X ij , Y kl ) .This is achieved by pre - indexing the fold envelopes , and the alignment envelope so that we can quickly locate valid co - ordinates ( i , j , k , l ) .The following is pseudocode for the algorithm with the redesigned iterator .Calculate Q B ( m , n ) and add to Q 1 . Calculate ( i , j , k , l ) and store .", "label": "", "metadata": {}}
{"text": "Slimming the container .Memory is the most prohibitively expensive resource demand of the Inside algorithm .In its simplest form , the algorithm stores the intermediate probabilities ( i , j , k , l ) using a five - dimensional array indexed by U , i , j , k and l .To get the most benefit out of imposing constraints , it is necessary to replace this multidimensional array with an efficiently - indexed reduced - space container .This design decision involves a close trade - off between CPU and memory usage .Initially , we tested various combinations of generic containers with O ( N ) -storage and O ( N log N ) access - times , such as balanced search trees [ 22 ] .", "label": "", "metadata": {}}
{"text": "This configuration wastes some space , but has the important advantage of constant access time for given indices ( U , i , j , k , l ) .These are also precomputed and stored .Similar precomputed sets and ranks are stored for .Our DP matrix then uses an inner two - dimensional array nested inside an outer two - dimensional array .Cells of this inner array are further sub - indexed by nonterminal U using a standard fixed - length array , yielding ( i , j , k , l ) .This particular configuration is efficient when the alignment envelope is densely populated and the fold envelopes are sparsely populated .", "label": "", "metadata": {}}
{"text": "The CYK algorithm .The entries of the DP matrix , ( i , j , k , l ) , represent the maximum likelihood of any parse tree for ( X ij , Y kl ) .The Outside and KYC algorithms .The Outside and KYC algorithms widen the applications of probabilistic inference with SCFGs .The Outside algorithm , together with the Inside , can be used to recover posterior probabilities of given basepairs / columns , which can be used as alignment reliability indicators or as update counts in Expectation Maximization parameter training [ 20 , 26 ] .", "label": "", "metadata": {}}
{"text": "( We introduce the name \" KYC \" as a simple reversal of \" CYK \" , reflecting the fact that KYC is to CYK as Outside is to Inside , i.e. the \" reverse \" version of the algorithm . )These algorithms use dynamic programming recursions that are related to Inside and CYK .The Outside algorithm calculates intermediate probabilities of the form . representing the sum - over - probabilities of all partial parse trees rooted at S and ending in V without having yet generated sequences X ij and Y kl .Then , for example , the posterior probability that some node V in the parse tree has inside sequence - pair ( X ij , Y kl ) is .", "label": "", "metadata": {}}
{"text": "As with the Inside algorithm , we sum contributions to ( i , j , k , l ) from various matching production rules .In contrast to the Inside algorithm , the nonterminal V that indexes ( ... ) must now be matched on the right - hand - side , not the left - hand - side , of these production rules .Note that the Inside probabilities ( i , j , k , l ) are needed to compute the Outside probabilities .We supply the Inside matrix , I , as an input to the Outside algorithm ( they are usually calculated at the same time anyway ) .", "label": "", "metadata": {}}
{"text": "Then the Inside iterator visits INNER before OUTER , whereas the Outside iterator visits OUTER before INNER .The order in which the Outside iterator visits nonterminals is topologically forward - sorted with respect to the grammar 's transition - rule graph ( i.e. the reverse of the order used by the Inside iterator ) .Calculate ( m , n ) and add to .Calculate ( m , n ) and add to .Calculate ( i , j , k , l ) and store .The reduced - space dynamic programming matrix that was developed above for the constrained Inside algorithm can be re - used for the constrained Outside algorithm .", "label": "", "metadata": {}}
{"text": "The above - described algorithms were implemented in the C++ dart library .One dart program in particular , stemloc , is an efficient general - purpose RNA multiple - sequence alignment program that can be flexibly controlled by the user from the Unix command line , including re - estimation of parameters from training data as well as a broad range of alignment functions .The dart libraries provide Inside , Outside , CYK , KYC , traceback and training algorithms for any pairwise SCFG in RNA normal form , whose rule probabilities can be expressed as algebraic expressions of some set of probability parameters ( with associated normalization constraints ) .", "label": "", "metadata": {}}
{"text": "dart source code releases can be downloaded under the terms of the GNU Public License , from the following URL ( which also gives access to the latest development code in the CVS repository ) .The grammars and algorithms described in this paper specifically refer to release 0.2 of the dart package , dated October 2004 ( although the algorithms are also implemented in release 0.1 , dated 10/2003 ) .Selecting appropriate fold and alignment envelopes .This section offers a non - exhaustive list of possible strategies for choosing appropriate fold/ alignment envelopes .( Italicized terms apply to fold envelopes , and bold terms to alignment envelopes . )", "label": "", "metadata": {}}
{"text": "Compute posterior probabilities of subsequences / cutpoints using the Inside - Outside / Forward - Backward algorithm for some single - sequence SCFG/ pair HMM that models RNA folding / primary sequence alignment .Select all subsequences / cutpoints with posterior probability above some threshold ( or select e.g. the top 10 percentile of the posterior probabability distribution ) .Ensure that each of these subsequences / cutpoints is on a valid traceback path , e.g. by running the CYK - KYC / Viterbi - forward - backward algorithm to find the maximum - likelihood traceback path from any given subsequence/ cutpoint .", "label": "", "metadata": {}}
{"text": "As above , choose some appropriate single - sequence SCFG / pair HMM that models RNA folding / primary sequence alignment .Compute the maximum traceback path - likelihood from all subsequences / cutpoints using the CYK - KYC / Viterbi - forward - backward algorithm for this grammar .Select all subsequences / cutpoints with maximum traceback likelihood above some threshold ( or select e.g. the top 10 percentile of the max - traceback likelihood distribution ) and do a traceback from each such cell .Take the union of all subsequences / cutpoints on these traceback paths to obtain the required envelope .", "label": "", "metadata": {}}
{"text": "Sample some number of RNA structures /pairwise alignments using the Inside / Forward algorithm with stochastic traceback .Take the union of all subsequences / cutpoints on these traceback paths to obtain the required envelope .The latter two strategies have been implemented in the stemloc package described below .Empirically , the stochastic strategy appears to be less reliable than the deterministic strategies ( although in theory the stochastic strategy will eventually find the globally optimal alignment given sufficiently many random repetitions , which may be a useful property ) .Multiple sequence alignment .A heuristic algorithm for performing multiple alignment - and - folding of RNA sequences with a pairwise SCFG by progressive single - linkage clustering runs as follows .", "label": "", "metadata": {}}
{"text": "Mark the highest - scoring pair , and extract the two marked sequences with their predicted secondary structures .This highest - scoring pair is called the seed alignment .While some sequences remain unmarked : .For each newly - marked sequence : .Align the marked sequence , with a fold envelope constrained by its predicted structure , to each unmarked sequence in turn .( The fold envelope can be tailored to allow e.g. extension of local alignments . )Select the highest - scoring of the pairwise ( marked - to - unmarked ) alignments .", "label": "", "metadata": {}}
{"text": "Return the seed alignment .The above algorithms have been implemented in stemloc .The multiple alignments produced by this algorithm lack well - defined probabilistic scores unless the pair SCFG is conditionally normalized .It is also straightforward to retrieve the N best non - overlapping alignments by repeatedly applying an incremental Waterman - Eggert - style mask to the alignment envelope [ 24 ] .This is implemented in stemloc for the pairwise case .A grammar for pairwise RNA alignment and structure prediction .After some empirical experimentation , we developed the grammar of Tables 2 , 3 , 4 for the stemloc program .", "label": "", "metadata": {}}
{"text": "Table 2 contains rules describing the connectivity of stems , loops and multiloops , and contains the only bifurcation rule .Table 3 describes the connectivity of bulges and Table 4 handles emissions ( basepaired , unpaired , aligned or gapped ) .The starting nonterminal is Start .The nonterminals representing higher - level units of RNA structure are Loop , Stem , LBulge , RBulge and LRBulge .Each of these has associated Match , Ins and Del states ( e.g. StemMatch , StemIns and StemDel ) and each of these states has an associated emission state , prefixed with x , y or xy superscripts ( e.g. xy StemMatch , y StemIns and x StemDel ) .", "label": "", "metadata": {}}
{"text": "Tables 2 , 3 , 4 also refer to probabilistic parameters used by the models .All of the above parameters were automatically estimated from training data by the dart software .To summarize , the grammar models homologous stems , loops , multiloops and bulges in pairwise RNA alignments , with covariant substitution scores and affine gap penalties ( geometric indel length distributions ) .It has the property that any combined alignment and structure prediction for two RNA sequences has a single , unambiguous parse tree .In our investigations , this unambiguity appeared to improve the accuracy of alignment and structure prediction substantially ; see also writings on this topic by Giegerich [ 34 ] and Dowell , Eddy et al [ 35 ] .", "label": "", "metadata": {}}
{"text": "Since the algorithms are implemented for any SCFG , it is straightforward to modify the program to experiment with grammars that model such phenomena .An example of a grammar that models the latter type of mutation ( whole - substructure indels ) , and is also fully derived from an evolutionary rate - based model , is presented in a companion paper [ 36 ] .Parameterization .Furthermore , the pairwise alignments were binned according to sequence identity , providing four alternative parameterisations ; the bin ranges were 30 - 40 % , 50 - 60 % , 70 - 80 % and 90 - 100 % . stemloc allows the user to re - estimate all parameters from their own personal training set of trusted alignments .", "label": "", "metadata": {}}
{"text": "These include the homology modeling program INFERNAL [ 37 ] and the de novo structure prediction program PFOLD [ 8 ] .Declarations .Acknowledgements .The author thanks Sean Eddy for inspiring discussions and three anonymous reviewers for their helpful suggestions .The work was conceived during an NIH - funded workshop on RNA informatics organised by Elena Rivas and Eric Westhof in Benasque , Spain , 2003 .Authors ' contributions .IH designed , programmed , tested and documented the algorithms .Authors ' Affiliations .Department of Bioengineering , University of California .References .Eddy SR : Noncoding RNA genes .", "label": "", "metadata": {}}
{"text": "View Article PubMed .Mandal M , Boese B , Barrick JE , Winkler WC , Breaker RR : Riboswitches Control Fundamental Biochemical Pathways in Bacillus subtilis and Other Bacteria .Cell 2003 , 113 : 577 - 586 .View Article PubMed .Sijen T , Plasterk RH : Transposon silencing in the Caenorhabditis elegans germ line by natural RNAi .Nature 2003 , 426 ( 6964 ) : 310 - 314 .View Article PubMed .Ambros V : The functions of animal microRNAs .Nature 2004 , 431 ( 7006 ) : 350 - 355 .View Article PubMed .", "label": "", "metadata": {}}
{"text": "Nature 2004 , 431 ( 7006 ) : 356 - 363 .View Article PubMed .Rivas E , Eddy SR : Secondary structure alone is generally not statistically significant for the detection of noncoding RNAs .Bioinformatics 2000 , 16 ( 7 ) : 583 - 605 .View Article PubMed .Coventry A , Kleitman DJ , Berger B : MSARI : Multiple sequence alignments for statistical detection of RNA secondary structure .Proceedings of the National Academy of Sciences of the USA 2004 , 101 : 12102 - 12107 .View Article PubMed .Knudsen B , Hein J : RNA secondary structure prediction using stochastic context - free grammars and evolutionary history .", "label": "", "metadata": {}}
{"text": "View Article PubMed .Rivas E , Eddy SR : Noncoding RNA gene detection using comparative sequence analysis .BMC Bioinformatics 2001 , 2 : 8 .View Article PubMed .Gorodkin J , Heyer LJ , Stormo GD : Finding the most significant common sequence and structure motifs in a set of RNA sequences .Nucleic Acids Research 1997 , 25 ( 18 ) : 3724 - 3732 .View Article PubMed .Mathews DH , Turner DH : Dynalign : an algorithm for finding the secondary structure common to two RNA sequences .Journal of Molecular Biology 2002 , 317 ( 2 ) : 191 - 203 .", "label": "", "metadata": {}}
{"text": "Perriquet O , Touzet H , Dauchet M : Finding the common structure shared by two homologous RNAs .Bioinformatics 2003 , 19 : 108 - 116 .View Article PubMed .Holmes I , Rubin GM : Pairwise RNA structure comparison using stochastic context - free grammars .Pac Symp Biocomput 2002 , 163 - 174 .Sankoff D : Simultaneous solution of the RNA folding , alignment , and protosequence problems .SIAM Journal of Applied Mathematics 1985 , 45 : 810 - 825 .View Article .Zuker M , Stiegler P : Optimal Computer Folding of Large RNA Sequences Using Thermodynamics and Auxiliary Information .", "label": "", "metadata": {}}
{"text": "View Article PubMed .Eddy SR , Durbin R : RNA Sequence Analysis Using Covariance Models .Nucleic Acids Research 1994 , 22 : 2079 - 2088 .View Article PubMed .Sakakibara Y , Brown M , Hughey R , Mian IS , Sj\u00f6lander K , Underwood RC , Haussler D : Stochastic Context - Free Grammars for tRNA Modeling .Nucleic Acids Research 1994 , 22 : 5112 - 5120 .View Article PubMed .Lefebvre F : A Grammar - Based Unification of Several Alignment and Folding Algorithms .Proceedings of the Fourth International Conference on Intelligent Systems for Molecular Biology ( Edited by : States DJ , Agarwal P , Gaasterland T , Hunter L , Smith RF , Menlo Park ) .", "label": "", "metadata": {}}
{"text": "Durbin R , Eddy S , Krogh A , Mitchison G : Biological Sequence Analysis : Probabilistic Models of Proteins and Nucleic Acids Cambridge , UK : Cambridge University Press 1998 .View Article .Hofacker IL , Bernhart SH , Stadler PF : Alignment of RNA base pairing probability matrices .Bioinformatics 2004 , 20 ( 14 ) : 2222 - 2227 .View Article PubMed .Austern MH : Generic Programming and the STL : Using and Extending the C++ Standard Template Library Addison - Wesley 1999 .Smith TF , Waterman MS : Identification of Common Molecular Subsequences .", "label": "", "metadata": {}}
{"text": "View Article PubMed .Waterman MS , Eggert M : A new algorithm for best subsequence alignments with application to tRNA - rRNA comparisons .Journal of Molecular Biology 1987 , 197 : 723 - 725 .View Article PubMed .Higgins DG , Sharp PM : Fast and Sensitive Multiple Sequence Alignments on a Microcomputer .Computer Applications in the Biosciences 1989 , 5 : 151 - 153 .PubMed .Lari K , Young SJ : The Estimation of Stochastic Context - Free Grammars Using the Inside - Outside Algorithm .Computer Speech and Language 1990 , 4 : 35 - 56 .", "label": "", "metadata": {}}
{"text": "McCaskill JS : The Equilibrium Partition Function and Base Pair Binding Probabilities for RNA Secondary Structure .Biopolymers 1990 , 29 : 1105 - 1119 .View Article PubMed .Altschul SF : Amino Acid Substitution Matrices from an Information Theoretic Perspective .Journal of Molecular Biology 1991 , 219 : 555 - 565 .View Article PubMed .Chomsky N : Three Models for the Description of Language .IRE Transactions Information Theory 1956 , 2 : 113 - 124 .View Article .Chomsky N : On Certain Formal Properties of Grammars .Information and Control 1959 , 2 : 137 - 167 .", "label": "", "metadata": {}}
{"text": "Holmes I : Studies in probabilistic sequence alignment and evolution .PhD thesis The Sanger Centre 1998 .Shapiro BA , Zhang KZ : Comparing multiple RNA secondary structures using tree comparisons .Computer Applications in the Biosciences 1990 , 6 ( 4 ) : 309 - 318 .PubMed .Klein R , Eddy SR : Noncoding RNA gene detection using comparative sequence analysis .BMC Bioinformatics 2003 ., 4 ( 44 ) : .Giegerich R : Explaining and Controlling Ambiguity in Dynamic Programming .Combinatorial Pattern Matching : 11th Annual Symposium ( Edited by : Giancarlo R , Sankoff D ) .", "label": "", "metadata": {}}
{"text": "View Article .Dowell RD , Eddy SR : Evaluation of several lightweight stochastic context - free grammars for RNA secondary structure prediction .BMC Bioinformatics 2004 , 5 : 71 .View Article PubMed .Holmes I : A probabilistic model for the evolution of RNA structure .BMC Bioinformatics 2004 . , 5 ( 166 ) : .Griffiths - Jones S , Bateman A , Marshall M , Khanna A , Eddy SR : Rfam : an RNA family database .Nucleic Acids Research 2003 , 31 : 439 - 441 .View Article PubMed .Holmes I , Durbin R : Dynamic programming alignment accuracy .", "label": "", "metadata": {}}
{"text": "View Article PubMed .Do CB , Brudno M , Batzoglou S : PROBCONS : Probabilistic Consistency - based Multiple Alignment of Amino Acid Sequences . , in press .Copyright .\u00a9 Holmes .This article is published under license to BioMed Central Ltd.Affiliated with .Abstract .Background .Results .The model , its strengths and its weaknesses are discussed with reference to four examples of functional ncRNA sequences : a riboswitch ( guanine ) , a zipcode ( nanos ) , a splicing factor ( U4 ) and a ribozyme ( RNase P ) .", "label": "", "metadata": {}}
{"text": "Conclusions .Although all three types of mutation \" event \" are built into our model , events of type ( i ) and ( ii ) are found to be better modeled than events of type ( iii ) .Nevertheless , we hypothesise from the model 's performance on pairwise alignments that it would form an adequate basis for a prototype multiple alignment and genefinding tool .Background .One of the promises of comparative genomics is to annotate previously undetectable functional signals in genomic sequence , by identifying and characterising evolutionarily conserved elements .A principled way to extract such signals is by fitting the data to probabilistic models of the molecular evolutionary process .", "label": "", "metadata": {}}
{"text": "( e.g. exons , bits of RNA , promoters , etc ) that might explain an observed sequence homology .For each of these scenarios , we can construct a probabilistic model M x , M y , M z ... and compare the likelihood of the observed data under each of these models .The model with the best fit indicates the type of functional element present in the sequence .A groundbreaking example of how this probabilistic approach can be used is the QRNA program , designed as a comparative RNA gene predictor [ 1 ] .The three types of element considered by QRNA are noncoding RNA ( called RNA ) , protein - coding exons ( called COD for codon ) , and unidentified DNA homology ( called OTH for other ) .", "label": "", "metadata": {}}
{"text": "The noncoding RNA predictions generated a high yield of experimental hits , and offered an information - theoretic glimpse into a modern - day RNA world [ 2 ] .It is natural to consider how such an approach might be applied to a pairwise comparison where the evolutionary \" distance \" between the two sequences can vary .One approach , analogous to the BLOSUM series of BLAST matrices for proteins [ 3 ] , is to partition a set of training alignments into an ad hoc number of bins based on the percentage sequence identity .Alignments in the same bin ( i.e. having comparable sequence identity ) then represent pairs of sequences at approximately equivalent distances .", "label": "", "metadata": {}}
{"text": "This sort of approach is used by the RIBOSUM basepair substitution matrices developed for RSEARCH [ 4 ] , recent versions of QRNA , and the stemloc program in the author 's DART software package .This evolutionary rate approach uses fewer parameters - and makes fuller use of the data - than the dividing - into - bins approach , since it postulates an infinitesimal generator for all time - scales of the process .Furthermore , the evolutionary rate model is supremely compatible with likelihood - based phylogenetic methods [ 7 ] .It 's therefore worth considering such evolutionary rate - based models , although ( since they 're trickier to analyse mathematically ) they 're less suited to quick software prototyping than the \" bin - by - percent - ID \" approach .", "label": "", "metadata": {}}
{"text": "The OTH model , for noncoding DNA sequence , is a Pair HMM with affine gaps ; the closest evolutionary equivalent is the \" long indel \" model [ 8 , 9 ] .The long indel model incorporates multi - residue indels and single - residue ( point ) substitutions ; it is based on the TKF91 model , which only allows single - residue indels [ 10 ] .In contrast , the current best evolutionary versions of the COD [ 11 ] and RNA [ 12 ] models do not attempt to model indels , changes in exon / intron structure or changes in RNA secondary structure .", "label": "", "metadata": {}}
{"text": "For example , the lack of a treatment of indels means that these models can only be used on a pre - generated alignment ; they can not , by themselves , be used to align sequences .In this report we present a simple but improved model of RNA structure evolution , called the TKF91 Structure Tree ( Figure 1 ) .This model allows not just covariant point substitutions of nucleotides , but also covariant insertions and deletions of bases , base - pairs , whole stems and multi - stem structures ( Figure 2 ) .Although we have not , in this paper , applied the Structure Tree to multiple alignment , or adapted it to include \" long indels \" , the similarity to existing models [ 8 , 13 ] suggests very natural forms for such adaptations of our model .", "label": "", "metadata": {}}
{"text": "To our knowledge , this is the first such model for the evolution of RNA structure to be described within an evolutionary rate framework .An example mutation path for a TKF91 Structure Tree , illustrating the instantaneous transitions of the process .The types of mutation are as follows .A computer program for simultaneous pairwise alignment and secondary structure prediction using the TKF91 Structure Tree has been developed in C++ .The TKF91 Structure Tree is a very simple evolutionary model lacking some \" obvious \" features , such as natural selection to favour the thermodynamically stable overlap of \u03c0 -orbitals between adjacent stacked bases in RNA double helices .", "label": "", "metadata": {}}
{"text": "Methods .We begin by reviewing the TKF91 model [ 10 ] .This model describes the evolution of a single sequence under the action of two kinds of mutation event : ( i ) point substitution events , which act on a single residue only ; and ( ii ) single - residue indel events , which insert or delete a single residue .The rates of both types of event are independent of the neighboring sequence .The TKF91 model , as defined by Thorne et al , is time - reversible .This has the implication , called the pulley principle by Felsenstein , that the position of an ancestral node in a phylogenetic tree can be slid around like a pulley without changing the likelihood of the observed data [ 7 ] .", "label": "", "metadata": {}}
{"text": "The TKF91 model can be analysed algebraically [ 10 ] , and the probability distribution function ( PDF ) over ancestor - descendant alignments can be expressed as a Pair HMM [ 13 ] and extended to multiple sequences ( using a \" Multiple HMM \" ) [ 13 ] .In this paper , we will not be considering such long - indel models .Definition of the TKF91 model .The state of the TKF91 process is described by a TKF91 link sequence : a permanent immortal link at the left end of the sequence , followed by zero or more mortal links .", "label": "", "metadata": {}}
{"text": "This can be treated as a birth - death process ( \u03bb 0 , \u03bc 0 ) with constant immigration ( \u03bb 0 ) , where \" births \" are identified with single - link insertions occuring to the immediate right of the parent mortal link . and \" immigration \" with insertions immediately right of the immortal link .Each site 's alphabet label evolves as an independent four - state reversible continuous - time Markov chain ( RCTMC ) with substitution rate R 0 ( i , j ) from state i to state j .Labels for newly inserted mortal links are drawn from the equilibrium distribution p 0 ( i ) of this substitution process .", "label": "", "metadata": {}}
{"text": "The following functions of ( \u03bb n , \u03bc n ) arise in analyses of equilibrium and transition probabilities in the TKF91 model [ 10 ] .Here t is a time parameter .The meaning of the above functions is as follows .The equilibrium probability distribution over sequences in the TKF91 model is a geometric distribution with parameter \u03ba 0 .The residues at individual positions of the sequence are independently , identically distributed at equilibrium and are sampled from the equilibrum distribution of the point substitution process .The TKF91 singlet grammar is shown in Figure 3 .", "label": "", "metadata": {}}
{"text": "Extending the TKF91 model .Various extensions to TKF91 have been proposed [ 8 , 9 , 15 ] .The most tractable kind of extension changes the meaning of a \" link \" but leaves the indel process on links intact [ 15 ] .Our RNA model is one such extension , allowing two different kinds of TKF91 model that can be mutually nested to form loop and stem regions .Consider the following extension to the TKF91 model , which we call the TKF91 Structure Tree , and which is shown in Figures 1 and 2 .", "label": "", "metadata": {}}
{"text": "The state of our stochastic process can thus be described by a rooted tree : every node in this tree is either a singlet , paired , loop or stem node .The tree can be broken into overlapping loop sequences and stem sequences , which correspond to strands of unpaired RNA ( loops ) or double helices of basepaired RNA ( stems ) .Loops are allowed to contain unpaired nucleotides , and can also serve as a branching - off point for nested stems .Stems , on the other hand , are allowed to contain paired nucleotides , and are terminated by a loop ( this reflects the smallest unit of RNA structure , which is a stem terminated by a loop ) .", "label": "", "metadata": {}}
{"text": "The above description will now be made more precise .Definition of the TKF91 Structure Tree .There are four basic kinds of node in the tree : singlet , paired , loop and stem .Singlet and paired nodes correspond to observable nucleotides .Singlet nodes ( labeled from \u03a9 ) represent independently evolving nucleotides , as in TKF91 .Paired nodes ( labeled from \u03a9 2 ) represent covariant basepairs .Loop and stem nodes determine the tree structure ( Figure 1 ) .Loop nodes ( labeled L ) , of which the root node is one , are present at the beginning of loop sequences , which contain singlet and stem nodes and are written horizontally .", "label": "", "metadata": {}}
{"text": "The set of loop and stem node labels is written \u03a6. Loop sequences .A loop sequence is very similar to a TKF91 link sequence : as with TKF91 , we have a leftmost immortal loop link followed by zero or more mortal loop links .The mortal links are inserted and deleted with rates \u03bb 1 and \u03bc 1 , in the style of TKF91 .Each link is also a node in the Structure Tree .The S -labeled links possess an independently evolving embedded stem sequence that can be considered to \" nest \" inside the loop sequence .", "label": "", "metadata": {}}
{"text": "Conversely , when a new S -link is inserted , it is inserted with a complete subtree that is sampled from the equilibrium distribution over Structure Trees .Since a loop sequence is effectively a TKF91 sequence with a special \" fifth nucleotide \" character representing an embedded stem ( the S link ) , it obeys the same statistics as a TKF91 sequence .In particular , the probability distribution over loop lengths at equilibrium is a geometric distribution with parameter \u03ba 1 .Stem sequences .A stem sequence is also derived from a TKF91 link sequence .", "label": "", "metadata": {}}
{"text": "It consists of a topmost immortal stem link , zero or more mortal stem links , and a bottommost , terminating loop link .Again , each link is also a node in the Structure Tree .The mortal stem links experience TKF91-style insertion and deletion with rates \u03bb 2 and \u03bc 2 ( although , in the diagrammatic form of Figure 1 , newly inserted links are placed immediately under their parent link , rather than immediately to the right ) .The terminating loop link L does not contribute to insertion or deletion ( so is effectively immortal but inert ) but possesses an independently evolving loop sequence .", "label": "", "metadata": {}}
{"text": "The S is itself a mortal link in a parent loop sequence , and may be deleted as that sequence evolves .Thus , the only truly immortal link is the loop node at the root of the Structure Tree , which has no parents to deal death from above .As with the loop sequence , a stem sequence is effectively a TKF91 sequence with minor modifications , and it obeys the same statistics as a TKF91 sequence .The probability distribution over stem lengths at equilibrium is a geometric distribution with parameter \u03ba 2 .Analysis of the TKF91 Structure Tree .", "label": "", "metadata": {}}
{"text": "There are two nonterminals , \u03a6 , and four terminals , \u03a9. An SCFG with nonterminals \u03a6 and terminals \u03a9 for generating the equilibrium distribution over Structure Trees .Figure 6 shows the pair stochastic context - free grammar for an ancestor and descendant sequence separated by evolutionary time t .Again , conditional and joint probabilities can both be read from the figure .Nonterminals are \u03a6 1234 ; terminals are \u03a9 a for the ancestor and \u03a9 d for the descendant .Dynamic programming alignment of sequences to these grammars has the typical complexity for single - sequence [ 17 ] and pairwise [ 18 ] SCFGs .", "label": "", "metadata": {}}
{"text": "Grammar transformations .We now describe some transformations of Figures 5 , 6 performed before implementing the grammar parsers .Null cycles .The presence in a grammar of \" null cycles \" - sequences of production rules which cause no net change - complicates the parsing algorithms for that grammar .Generally , null cycles are avoided by programmers designing SCFGs or HMMs for sequence analysis [ 17 ] .However , in the grammars derived automatically for the TKF91 Structure Tree , null cycles arise naturally due to the possibility of zero - length loop or stem sequences in the model .", "label": "", "metadata": {}}
{"text": "Table 1 .Classes of degeneracy in the Structure Tree grammars .Permutations and combinations of these cycles are also possible .Degeneracies .As well as null cycles , there are other undesirable degeneracies in the Structure Tree grammars .Grammatical degeneracy occurs when more than one parse has the same meaning , so parses are degenerate rather than unique .Most stochastic grammars useful for bioinformatics are degenerate in the sense that there are always many folds or alignments consistent with the observed sequence data ; this sort of degeneracy is technically called ambiguity .We are more concerned with other forms of degeneracy , such as structural degeneracy ( multiple parses denote a single pattern of basepairing ) and alignment degeneracy ( multiple parses denote a single alignment ) .", "label": "", "metadata": {}}
{"text": "A full list of degeneracies for the singlet and pair grammars is shown in Table 1 .Prevention of zero - length stems .A more careful analysis , marginalising null cycles and silent bulges rather than simply ignoring them , is almost certainly possible .Transformation to canonical form .Figures 7 and 8 show the singlet and pairwise grammars with null cycles and silent bulges removed , in the canonical form used by the DART software package [ 18 ] .As well as the new sets of nonterminals described above ( \u03a6 ' for singlet , for pair ) the grammar includes nonterminals dedicated to bifurcations ( for singlet , for pair ) and emissions ( for singlet , for pair ) .", "label": "", "metadata": {}}
{"text": "The full nonterminal alphabets are \u03a8 for singlet states and \u03a8 1234 for pair states .The asymptotic complexity of the dynamic programming recursions implied by these grammars is unchanged by the transformation to DART form .Again , the complexity may be reduced by the use of \" banding \" [ 20 , 21 ] or other [ 18 ] constraints .Parameterisation of the TKF91 Structure Tree .The Expectation Maximisation ( EM ) algorithm is often used for training BLOSUM - like models , e.g. estimating emission and transition probabilities for Pair HMMs [ 17 ] or Pair SCFGs [ 1 ] .", "label": "", "metadata": {}}
{"text": "The EM algorithm for the TKF91 Structure Tree can be separated into two parts , one for the substitution process and one for the indel process .Earlier work [ 22 ] showed how to estimate the maximum - likelihood substitution rate matrix R n using the EM algorithm , given the following sufficient statistics : . , the expected number of insertions of state d ; . , the expected number of aligned sites with ancestral state a and descendant state d .A forthcoming paper describes how to estimate the maximum - likelihood indel rates \u03bb n , \u03bc n for a TKF91 model using the EM algorithm , given the following sufficient statistics : . , the expected number of deleted links not followed by an insertion ; . , the expected number of surviving links not followed by an insertion ; . , the expected number of deleted links followed by an insertion ; . , the expected number of surviving links followed by an insertion .", "label": "", "metadata": {}}
{"text": "Assume the joint normalisation , P ( d , a ) , and suppose that is the posterior expectation of the number of times rule m of Figure 8 was applied , as returned by the Inside - Outside algorithm .Then .Results .The aligner is based on the Stochastic Context - Free Grammars ( SCFGs ) shown in Figures 7 and 8 , as explained in the Methods section .The specific implementation uses a general Pair SCFG dynamic programming ( DP ) engine with accelerating heuristics , to be described in a later paper ( manuscript in preparation ) .", "label": "", "metadata": {}}
{"text": "The four families were the purine riboswitch ( Figure 9 ) , the nanos translational control element ( TCE ) from Drosophila ( Figure 10 ) , the U2 spliceosomal factor ( Figure 11 ) and bacterial nuclear RNase P ( Figure 12 ) .Alignment of nuclear RNase P genes from Pichia canadensis ( AF186219.1 ) and Clavispora opuntiae ( AF186216.1 ) .For a given family , denote the two sequences in the family by A , B .The following computations were performed : .( 1A ) , ( 1B )For each of the two sequences ( A , B ) taken individually , the secondary structure was predicted without the aid of comparative information from the other sequence , using the single - sequence SCFG of Figure 7 .", "label": "", "metadata": {}}
{"text": "The two sequences ( A , B ) were then aligned using the TKF91 model , without making use of any model of RNA structure , using the Pair HMM of Figure 4 .( 3 ) Finally , the two sequences ( A , B ) were aligned using the TKF91 Structure Tree model introduced in this paper , using the Pair SCFG of Figure 8 .These computations allow a comparison between the TKF91 model , the single - sequence SCFG of Figure 7 and the TKF Structure Tree .The results , including structure and alignment predictions , are illustrated in a compact visual representation that we call a \" fold / alignment dotplot \" .", "label": "", "metadata": {}}
{"text": "The subregions labeled a - f have the following meaning : .Fold - alignment dotplot key .These plots compare separate and integrated methods for RNA alignment and folding .( a ) .This triangular dotplot illustrates the single - sequence structure prediction for sequence A of computation ( 1A ) .The pixel color at co - ordinates ( x , y ) represents the posterior probability that residues x and y of A are base - paired , in the absence of any information from sequence B .( b ) .This triangular dotplot illustrates the single - sequence structure prediction for sequence B of computation ( 1B ) .", "label": "", "metadata": {}}
{"text": "( c ) .This rectangular dotplot illustrates the structure - free pairwise alignment of computation ( 2 ) .The pixel color at co - ordinates ( x , y ) represents the posterior probability that residue x of A is homologous to residue y of B , in the absence of any structural information from the two sequences .( d ) .This triangular dotplot illustrates the comparative structure prediction for sequence A of computation ( 3 ) .The pixel color at co - ordinates ( x , y ) represents the marginal posterior probability that residues x and y of A are base - paired , summed over all alignments to sequence B .", "label": "", "metadata": {}}
{"text": "This triangular dotplot illustrates the comparative structure prediction for sequence B of computation ( 3 ) .The pixel color at co - ordinates ( x , y ) represents the marginal posterior probability that residues x and y of B are base - paired , summed over all alignments to sequence A .( f ) .This rectangular dotplot illustrates the structural pairwise alignment of computation ( 3 ) .The pixel color at co - ordinates ( x , y ) represents the marginal posterior probability that residue x of B is homologous to residue y of A , summed over all secondary structures of sequences A and B .", "label": "", "metadata": {}}
{"text": "In addition , the \" true \" ( published ) structures and alignments are overlaid on the computational results as blue squares ( or blue dots , on the larger images ) .The rate parameters used for the TKF91 Structure Tree were obtained by maximum likelihood training from a random selection of structurally - annotated RFAM alignments , as follows : .The substitution rate parameters were taken from the PFOLD program [ 12 ] .The evolutionary \" time \" between the two sequences was set to 1 in each case .In the case of the RNase P and U2 genes , the DP algorithms were constrained to a band along the main diagonal of the DP matrix ; this constraint was imposed due to limited memory .", "label": "", "metadata": {}}
{"text": "In all cases , the Pair SCFG sharply resolves the most probable stems in the sequences ; for the nanos , U2 and RNase P sequences , it also resolves the pairwise alignment .Fold - alignment dotplot of purine riboswitches ( see Figure 13 for key ) .From a wide range of potential stems ( faint red diagonal lines , plots a - b ) , the Pair SCFG clearly resolves the three strongest ( sharp white diagonal lines , plots d - e ) .In this case , the primary sequence alignment is relatively clear ( plot c ) and so little alignment clarity is gained by including structural information ( plot f ) .", "label": "", "metadata": {}}
{"text": "From a range of potential stems ( faint red diagonal lines , plots a - b ) , the Pair SCFG resolves the three true stems sharply using the comparative signal ( white diagonal lines , plots d - e ) .Some uncertainty in the primary sequence alignment ( parallel blurred red lines , plot c ) is resolved by including structural information , including a deletion in the outermost stem ( broken diagonal line , plot f ) .Fold - alignment dotplot of U2 splicing factors ( see Figure 13 for key ) .From a range of potential stems ( faint red diagonal lines , plots a - b ) , the Pair SCFG resolves the true stems sharply using the comparative signal ( white diagonal lines , plots d - e ) .", "label": "", "metadata": {}}
{"text": "Fold - alignment dotplot of nuclear RNase P genes ( see Figure 13 for key ) .From a wide range of potential stems ( faint red diagonal lines , plots a - b ) , the Pair SCFG resolves several sharply using the comparative signal ( sharp white diagonal lines , plots d - e ) .Uncertainty in the primary sequence alignment ( wide red lines , plot c ) ? ? is also resolved by including structural information ( arrow white line , plot f ) .Purine riboswitch .The purine riboswitches are a class of cis -acting regulatory elements that specifically bind adenine or guanine and are involved in the post - translational regulation of purine transport and biosynthesis [ 23 ] .", "label": "", "metadata": {}}
{"text": "The two secondary structures of this pair are exactly identical , although the primary sequences are considerably diverged .Figure 14 shows the posterior dotplots for the purine riboswitches .This is an easy case for the model , with a strong signal and few gaps .The TKF91 Structure Tree grammar ( Figure 8 ) is able to identify all stems correctly , with some slight uncertainty over the alignment .The primary - sequence TKF91 grammar ( Figure 4 ) is similarly able to find the correct alignment , although the singlet folding grammar ( Figure 7 ) has difficulty resolving the stems ( note that this grammar does not model basepair stacking effects ) .", "label": "", "metadata": {}}
{"text": "The translational control element ( TCE ) is a regulatory sequence from the 3 ' untranslated region of the Drosophila nanos gene , involved in post - translational degradation and transport of nanos mRNA , which localises to the posterior of oocytes and other cell lines [ 24 ] .Figure 10 shows the alignment of the two TCE sequences , from Drosophila virilis and Drosophila melanogaster , which was curated by hand from the description by Gavis et al [ 24 ] .The two secondary structures of this pair share the same overall bifurcating - stem structure , but with some changes in stem length .", "label": "", "metadata": {}}
{"text": "Again , the Structure Tree does much better than the singlet folding grammar ( Figure 7 ) at distinguishing real stems from background noise , since it is able to use covariation of basepaired residues as a clue .U2 snRNA .The U2 small nuclear RNA recognizes and binds the branch point region of introns in pre - mRNA [ 25 ] .Figure 11 shows the alignment of the two splicing factors , from Tetrahymena thermophila and Leptomonas collosoma , was taken from the RFAM database [ 14 ] .The secondary structures of the two sequences are quite similar , but the Leptomonas U2 has a deletion of roughly 35 bp that eliminates an entire stem ( stems 4 - 6 on Figure 11 ) .", "label": "", "metadata": {}}
{"text": "The primary - sequence TKF91 grammar ( Figure 4 ) is , again , hampered by its global alignment and linear gap penalty , and the alignment in region ( c ) is stretched and also uncertain .Bacterial nuclear RNase P .Nuclear RNase P is a class of endoribonuclease ribozyme involved in the production of mature 5 ' ends of transfer RNAs during tRNA biosynthesis [ 26 ] .Figure 12 shows the alignment of the two ribozyme sequences , from Pichia canadensis and Clavispora opuntiae , which was taken from the RFAM database [ 14 ] .", "label": "", "metadata": {}}
{"text": "Figure 17 shows the posterior dotplots for the RNase P genes .This family is one of the most mutable in RFAM , and the TKF91 Structure Tree performs poorly on this case .As a consequence , the Pair SCFG also fails to predict any stems correctly ; the singlet SCFG ( Figure 7 ) does no better .Region ( f ) of Figure 17 displays the continuous - line alignment from corner - to - corner , that is characteristic of global aligners with linear gaps : unlike the case of the U2 alignment , the structural signal here is insufficient to compensate for the indel - modeling deficiencies of the TKF91 Structure Tree .", "label": "", "metadata": {}}
{"text": "Compare this with the scores for the previous examples : Figure 9 scored 2 bits , Figure 10 scored -82 bits and Figure 11 scored 35 bits .The low score for the nanos TCEs ( Figure 10 ) was due primarily to the deletions in the outermost stem ; the score rose to -5 bits with judicious trimming and careful choice of the \" time \" parameter .Discussion .A pairwise alignment algorithm based on the model has been implemented in C++ and tested on four homologous pairs of RNA functional element from RFAM [ 14 ] .", "label": "", "metadata": {}}
{"text": "28 ] .Such pairwise alignment programs are optimized for criteria like alignment accuracy and sensitivity .The TKF91 Structure Tree , on the other hand , was designed as an expository evolutionary model , ultimately aimed at phylogenetic analysis of multiple RNA sequences in an evolutionary likelihood context .The pairwise alignment program reported in this paper was implemented to demonstrate the potential of this evolutionary model , rather than for use as a practical alignment tool .The results of our tests on pairwise alignments from RFAM reveal the strengths and weaknesses of our model .When RNA structure is very strongly conserved and indels are few , as with the purine riboswitches selected for this comparison ( Figure 14 ) , the TKF91 Structure Tree performs well at both structure prediction and alignment .", "label": "", "metadata": {}}
{"text": "When the alignment has numerous indels in loops and stems , as in the selected nanos TCEs ( 15 ) , or even minor rearrangements of structure , as in the selected U2 splice factors ( 16 ) , the Structure Tree still seems to work well .However , beyond a certain level of structural change , as in the selected RNase P alignment ( 17 ) , the model performs poorly and leaves considerable room for improvement .In view of the room for improvement , we can identify a number of weaknesses of the TKF91 Structure Tree that could be improved in future models : .", "label": "", "metadata": {}}
{"text": "These degeneracies could have beeen specifically excluded from the evolutionary model , but with the apparent cost of making an exact solution much harder to find .One might expect the nondegenerate grammars of Figures 7 and 8 to approximate the transition probabilities of such a nondegenerate model .Indel rates for whole stems / multistems are same as for unpaired residues .In nature , stem gain and loss is much slower than unpaired residue insertion / deletion , since the former is a structural change while the latter is not .Multiple - residue indel events , and hence affine gap penalties , are not allowed .", "label": "", "metadata": {}}
{"text": "This is a characteristic artefact of using a point indel model ( linear gap penalty ) where a multi - residue indel model ( affine penalty ) would be more appropriate .Stems can not be deleted without deleting all their \" children \" as well ( i.e. all stems nested inside ) .Empirical inspection of alignments in RFAM , however , reveals many structures where an outer stem has been deleted or truncated , while inner stems are preserved .Again , perhaps an affine gap penalty for covariant indels ( i.e. indels in stems ) would address this .", "label": "", "metadata": {}}
{"text": "[ 8 ] ) , though this may not be the ideal way to model such effects .The equilibrium distribution over structures is highly simplified .For example , there is currently no modeling of fine - scale energetics such as basepair stacking propensities due to \u03c0 -orbital conjugation .Mathematically , the complexities of modeling such effects are somewhat similar to those involved in modeling nearest - neighbor substitution biases in DNA ( such as methylation - induced CpG deamination ) .Since recent progress has been made with such models [ 29 , 30 ] we might eventually expect inclusion of stacking effects in models of covariant RNA substitution , as well .", "label": "", "metadata": {}}
{"text": "However , this would increase the potential for degeneracies .We have assumed that all stems and loops evolve at the same rate , whereas empirical inspection of RFAM of suggests otherwise .It is known that the analogous assumption in proteins ( that all sites evolve at the same rate ) can skew phylogenetic distance estimation [ 31 ] , and perhaps a similar correction to the discretized gamma priors used in proteins could be applied here [ 32 ] .There is no special treatment of structural features such as triloops , tetraloops , triple - A platforms , U - turns and the like .", "label": "", "metadata": {}}
{"text": "It would be relatively easy to incorporate such features into the TKF91 Structure Tree , as special classes of L - or S -branch .While the lengths of stem sequences are geometrically distributed in the TKF91 Structure Tree , due to their roots in the TKF91 model , empirical observations of real RNA structures suggest that real stem lengths follow a fairly tight length distribution .Such approximations in modeling stem lengths could conceivably contribute to poorer performance of the model .( In practise , we have not observed unnaturally long stems in the output of the TKF91 Structure Tree aligner , but the existence of a long , perfect inverted repeat in the sequence could conceivably bring out this problem . )", "label": "", "metadata": {}}
{"text": "Given the recent growth of RNA sequence and structure databases such as RFAM [ 14 ] and SCOR [ 34 ] , it would be interesting to carry out a broad - scale , empirical study of the mutations of RNA structures .This could then be used as a starting point for systematically designing and benchmarking an improved evolutionary model for RNA .In the meantime , the results presented here suggest new ways of designing evolutionary grammars that recognise higher - level structural change as well as point substitutions and indels , offering new ways of using high - throughput comparative sequencing to interpret the contents of genomes .", "label": "", "metadata": {}}
{"text": "Acknowledgements .This manuscript has evolved over the course of discussions with Sam Griffiths - Jones , Alex Bateman , Sean Eddy , Elena Rivas , Eric Westhof , Bjarne Knudsen , Kushal Chakrabarti , Jotun Hein , Gerton Lunter and David Haussler .The author thanks two anonymous reviewers for helpful criticism .The work was partly developed during a workshop in Benasque , Spain organised by Elena Rivas and Eric Westhof in 2003 .The work was partially supported by grants from the UK 's EPSRC ( code HAMJW ) and MRC ( code HAMKA ) .Authors ' Affiliations .", "label": "", "metadata": {}}
{"text": "Department of Statistics , .References .Rivas E , Eddy SR : Noncoding RNA gene detection using comparative sequence analysis .BMC Bioinformatics 2001 , 2 : 8 .View Article PubMed .Rivas E , Klein RJ , Jones TA , Eddy SR : Computational identification of noncoding RNAs in E. coli by comparative genomics .Current Biology 2001 , 11 : 1369 - 1373 .View Article PubMed .Henikoff S , Henikoff JG : Amino acid substitution matrices from protein blocks .Proceedings of the National Academy of Sciences of the USA 1992 , 89 : 10915 - 10919 .", "label": "", "metadata": {}}
{"text": "Klein RJ , Eddy SR : RESEARCH : Finding homologs of single structured RNA sequences .BMC Bioinformatics 2003 , 4 : 44 .View Article PubMed .Dayhoff MO , Schwartz RM , Orcutt BC : A Model of Evolutionary Change in Proteins .In Atlas of Protein Sequence and Structure ( Edited by : Dayhoff MO ) .Washington , DC : National Biomedical Research Foundation 1978 , 5 ( supplement 3 ) : 345 - 352 .Holmes I : Using guide trees to construct multiple - sequence evolutionary HMMs .In Proceedings of the Eleventh International Conference on Intelligent Systems for Molecular Biology Menlo Park , CA : AAAI Press 2003 , 147 - 157 .", "label": "", "metadata": {}}
{"text": "[ ISBN 0878931775 ] .Mikl\u00f3s I , Lunter G , Holmes I : A long indel model for evolutionary sequence alignment .Molecular Biology and Evolution 2004 , 21 ( 3 ) : 529 - 540 .View Article PubMed .Knudsen B , Miyamoto M : Sequence Alignments and Pair Hidden Markov Models Using Evolutionary History .Journal of Molecular Biology 2003 , 333 ( 2 ) : 453 - 460 .View Article PubMed .Thorne JL , Kishino H , Felsenstein J : An Evolutionary Model for Maximum Likelihood Alignment of DNA Sequences .Journal of Molecular Evolution 1991 , 33 : 114 - 124 .", "label": "", "metadata": {}}
{"text": "Pedersen JS , Hein J : Gene finding with a hidden Markov model of genome structure and evolution .Bioinformatics 2003 , 19 ( 2 ) : 219 - 227 .View Article PubMed .Knudsen B , Hein J : RNA secondary structure prediction using stochastic context - free grammars and evolutionary history .Bioinformatics 1999 , 15 ( 6 ) : 446 - 454 .View Article PubMed .Holmes I , Bruno WJ : Evolutionary HMMs : a Bayesian approach to multiple alignment .Bioinformatics 2001 , 17 ( 9 ) : 803 - 820 .View Article PubMed .", "label": "", "metadata": {}}
{"text": "Nucleic Acids Research 2003 , 31 : 439 - 441 .View Article PubMed .Thorne JL , Kishino H , Felsenstein J : Inching Toward Reality : an Improved Likelihood Model of Sequence Evolution .Journal of Molecular Evolution 1992 , 34 : 3 - 16 .View Article PubMed .Mikl\u00f3s I , Toroczkai Z : An Improved Model for Statistical Alignment .In First Workshop on Algorithms in Bioinformatics Berlin , Heidelberg : Springer - Verlag 2001 .Durbin R , Eddy S , Krogh A , Mitchison G : Biological Sequence Analysis : Probabilistic Models of Proteins and Nucleic Acids Cambridge , UK : Cambridge University Press 1998 .", "label": "", "metadata": {}}
{"text": "Holmes I , Rubin GM : Pairwise RNA structure comparison using stochastic context - free grammars .Pacific Symposium on Biocomputing 2002 .Sankoff D : Simultaneous solution of the RNA folding , alignment , and protosequence problems .SIAM Journal of Applied Mathematics 1985 , 45 : 810 - 825 .View Article .Gorodkin J , Heyer LJ , Stormo GD : Finding the most significant common sequence and structure motifs in a set of RNA sequences .Nucleic Acids Research 1997 , 25 ( 18 ) : 3724 - 3732 .View Article PubMed .Mathews DH , Turner DH : Dynalign : an algorithm for finding the secondary structure common to two RNA sequences .", "label": "", "metadata": {}}
{"text": "View Article PubMed .Holmes I , Rubin GM : Expectation Maximization algorithm for training hidden substitution models .J Mol Biol 2002 , 317 ( 5 ) : 757 - 768 .View Article .Mandal M , Boese B , Barrick JE , Winkler WC , Breaker RR : Riboswitches Control Fundamental Biochemical Pathways in Bacillus subtilis and Other Bacteria .Cell 2003 , 113 : 577 - 586 .View Article PubMed .Crucs S , Chatterjee S , Gavis ER : Overlapping but distinct RNA elements control repression and activation of nanos translation .Molecular cell 2000 , 5 ( 3 ) : 457 - 467 .", "label": "", "metadata": {}}
{"text": "Berglund JA , Rosbash M , Schultz SC : Crystal structure of a model branchpoint - U2 snRNA duplex containing bulged adenosines .RNA 2001 , 7 : 682 - 691 .View Article PubMed .Frank DN , Adamidi C , Ehringer MA , Pitulle C , Pace NR : Phylogenetic - comparative analysis of the eukaryal ribonuclease P RNA .RNA 2000 , 6 : 1895 - 1904 .View Article PubMed .Hein J : An Algorithm for Statistical Alignment of Sequences Related by a Binary Tree .In Pacific Symposium on Biocomputing ( Edited by : Altman RB , Dunker AK , Hunter L , Lauderdale K , Klein TE ) .", "label": "", "metadata": {}}
{"text": "Perriquet O , Touzet H , Dauchet M : Finding the common structure shared by two homologous RNAs .Bioinformatics 2003 , 19 : 108 - 116 .View Article PubMed .Lunter G , Hein J : A nucleotide substitution model with nearest - neighbour interactions .Bioinformatics 2004 .[To appear ] .Siepel A , Haussler D : Phylogenetic estimation of context - dependent substitution rates by maximum likelihood .Molecular Biology and Evolution 2004 , 21 ( 3 ) : 468 - 488 .View Article PubMed .Bruno WJ , Halpern AL : Topological bias and inconsistency of maximum likelihood using wrong models .", "label": "", "metadata": {}}
{"text": "PubMed .Yang Z : Maximum - likelihood estimation of phylogeny from DNA sequences when substitution rates differ over sites .Molecular Biology and Evolution 1993 , 10 : 1396 - 1401 .PubMed .Klosterman PS , Tamura M , Holbrook SR , Brenner SE : SCOR : a structural classification of RNA database .Nucleic Acids Research 2002 , 30 : 392 - 394 .View Article PubMed .Klosterman PS , Hendrix DK , Tamura M , Holbrook SR , Brenner SE : Three - dimensional motifs from the SCOR , structural classification of RNA database : extruded strands , base triples , tetraloops and U - turns .", "label": "", "metadata": {}}
{"text": "View Article PubMed .Varani G : RNA - protein intermolecular recognition .Accounts of chemical research 1997 , 30 ( 5 ) : 190 - 195 .View Article .Wu H , Henras A , Chanfreau G , Feigon J : Structural basis for recognition of the AGNN tetraloop RNA fold by the double - stranded RNA - binding domain of Rnt1p RNase III .Proceedings of the National Academy of Sciences of the USA 2004 , 101 ( 22 ) : 8307 - 8312 .View Article PubMed .Copyright .\u00a9 Holmes .This article is published under license to BioMed Central Ltd.", "label": "", "metadata": {}}
{"text": "This class is a graduate seminar for students who are interested in expanding their knowledge about the use of Bayesian statistics in natural language processing .The class consists of two parts : the first part consists of lectures given by the instructor about various topics in the area of Bayesian NLP .The second part consists of discussions , led by participants in the class ( each week by different participants ) about papers in the area of Bayesian NLP .Grades will be based on the discussions led in class , participation and possibly a white paper ( a short paper that students have to submit , in which participants summarize one or two related papers , and suggest some future directions for exploration ) .", "label": "", "metadata": {}}
{"text": "To get a feeling about some of the core material in this area , check out Sharon Goldwater 's Bayesian language modeling reading list .A lot of progress has been made in this area since this list was last updated , but it presents some of the basic papers and reading material that participants in the class could choose to discuss ( of course , students could choose newer papers to present ) .In the first week of the class , we will compile a more thorough list of papers to choose from .A current seed version of the list exists here , as a PDF file .", "label": "", "metadata": {}}
{"text": "5/6 - last class this semester .Thank you everybody for the hard work ! 3/10 - we have a tentative schedule for paper discussions until 5/6 .If you did not receive an email from me about presenting a paper , and would like to do so , email me as soon as possible .2/12 - We have a tentative schedule for paper discussions until 4/1 .2/3 - We compiled a list of Bayesian NLP papers .The list can be found here .Next week we will start building a schedule for group discussions .2/1 - The class now has a mailing list , coms-e6998-11@lists.cs.columbia.edu - you should subscribe to it if you attend the class .", "label": "", "metadata": {}}
{"text": "Shay .Basic refresher on Probability and Statistics ( statistical independence , conditional independence , Bayes ' theorem ) , the Bayesian approach , hypothesis testing , priors in general , Bayesian updating .Jenny Rose Finkel and Christopher D. Manning ( 2009 ) .Hierarchical Bayesian Domain Adaptation .Proceedings of NAACL .[ pdf ] .Optional reading ( for data motivation ) : John Blitzer , Mark Dredze and Fernando Pereira ( 2007 ) .Biographies , Bollywood , Boom - boxes and Blenders : Domain Adaptation for Sentiment Classification .Proceedings of ACL .[ pdf ] .", "label": "", "metadata": {}}
{"text": "A Bayesian LDA - based model for semi - supervised part - of - speech tagging .Proceedings of NIPS .[ pdf ] .Mark Johnson and Thomas Griffiths and Sharon Goldwater ( 2007 ) .Bayesian inference for PCFGs via Markov chain Monte Carlo .Proceedings of NAACL .[ pdf ] .Variational inference ( cont'd ) , Bayesian logic programs , semantic parsing .the material was presented on the blackboard .Sindhu Raghavan , Raymond J. Mooney and Hyeonseo Ku ( 2012 ) .Learning to \" read between the lines \" using Bayesian logic programs .", "label": "", "metadata": {}}
{"text": "[ pdf ] ( note that this paper is not strictly a \" Bayesian \" paper in the traditional sense , but it is an interesting paper to know about , nevertheless , and there was a demand for it .Food for thought : how would we turn Bayesian logic programs into Bayesian in the full sense of the word ? )Bevan Jones , Mark Johnson and Sharon Goldwater ( 2012 ) .Semantic parsing with Bayesian tree transducers .Proceedings of ACL .[ pdf ] .all material was presented on the blackboard .Stephen J. Roberts , Dirk Husmeier , William Penny and lead Rezek ( 1998 ) .", "label": "", "metadata": {}}
{"text": "IEEE Transactions on Pattern Analysis and Machine Intelligence [ pdf ] .Kurihara and Sato ( 2006 ) .Variational Bayesian grammar induction for natural language .International Colloquium on Grammatical Inference .[ pdf ] .Paul et al .( 2011 ) .Dialect Translation : Integrating Bayesian Co - segmentation Models with Pivot - based SMT .Proceedings of the First Workshop on Algorithms and Resources for Modelling of Dialects and Language Varieties [ pdf ] .Blunsom et al .( 2009 ) .A Gibbs Sampler for Phrasal Synchronous Grammar Induction .Proceedings of ACL .", "label": "", "metadata": {}}
{"text": "Wallach , Mimno and McCallum ( 2009 ) .Rethinking LDA : Why Priors Matter .Proceedings of NIPS .[ pdf ] Tools . by Chris Callison - burch , Christof Monz , Josh Schroeder - In Proceedings of the Fourth Workshop on Statistical Machine Translation ( WMT 2009 . \" ... j schroeder ed ac uk This paper presents the results of the WMT09 shared tasks , which included a translation task , a system combination task , and an evaluation task .We conducted a large - scale manual evaluation of 87 machine translation systems and 22 system combination entries .", "label": "", "metadata": {}}
{"text": "j schroeder ed ac uk This paper presents the results of the WMT09 shared tasks , which included a translation task , a system combination task , and an evaluation task .We conducted a large - scale manual evaluation of 87 machine translation systems and 22 system combination entries .We used the ranking of these systems to measure how strongly automatic metrics correlate with human judgments of translation quality , for more than 20 metrics .We present a new evaluation technique whereby system output is edited and judged for correctness . \" ... Languages with rich inflectional morphology pose a difficult challenge for statistical machine translation .", "label": "", "metadata": {}}
{"text": "By integrating constraint evaluation into the ... \" .Languages with rich inflectional morphology pose a difficult challenge for statistical machine translation .To address the problem of morphologically inconsistent output , we add unification - based constraints to the target - side of a string - to - tree model .By integrating constraint evaluation into the decoding process , implausible hypotheses can be penalised or filtered out during search .We use a simple heuristic process to extract agreement constraints for German and test our approach on an English - German system trained on WMT data , achieving a small improvement in translation accuracy as measured by BLEU . \" ...", "label": "", "metadata": {}}
{"text": "Updates to our syntax - based SMT system mainly fell in the areas of new feature formulations in the translation model and improved filtering of SCFG rules .Compared to our WMT 2009 submission ... \" .We present the Carnegie Mellon University Stat - XFER group submission to the WMT 2010 shared translation task .Updates to our syntax - based SMT system mainly fell in the areas of new feature formulations in the translation model and improved filtering of SCFG rules .Compared to our WMT 2009 submission , we report a gain of 1.73 BLEU by using the new features and decoding environment , and a gain of up to 0.52 BLEU from improved grammar selection . \" ...", "label": "", "metadata": {}}
{"text": "At the same time , making the correct choice is often critical to the coherence of the output text .In the context of statistical machine translation , this difficult ... \" .Prepositions are hard to translate , because their meaning is often vague , and the choice of the correct preposition is often arbitrary .At the same time , making the correct choice is often critical to the coherence of the output text .In the context of statistical machine translation , this difficulty is enhanced due to the possible long distance between the preposition and the head it modifies , as opposed to the local nature of standard language models .", "label": "", "metadata": {}}
{"text": "We use this information in a transfer - based Arabic - to - Hebrew statistical machine translation system .We show that incorporating linguistic knowledge on the distribution of prepositions significantly improves the translation quality . \" ... j schroeder ed ac uk This paper presents the results of the WMT09 shared tasks , which included a translation task , a system combination task , and an evaluation task .We conducted a large - scale manual evaluation of 87 machine translation systems and 22 system combination entries .We used the ranking ... \" .j schroeder ed ac uk This paper presents the results of the WMT09 shared tasks , which included a translation task , a system combination task , and an evaluation task .", "label": "", "metadata": {}}
{"text": "We used the ranking of these systems to measure how strongly automatic metrics correlate with human judgments of translation quality , for more than 20 metrics .We present a new evaluation technique whereby system output is edited and judged for correctness .One of the fundamental problems in computational structural biology is the prediction of RNA secondary structures from a single sequence .To solve this problem , mainly two different approaches have been used over the past decades : the free energy minimization ( MFE ) approach which is still considered the most popular and successful method and the competing stochastic context - free grammar ( SCFG ) approach .", "label": "", "metadata": {}}
{"text": "For instance , over the last years , several statistical sampling methods and clustering techniques have been invented that are based on the computation of partition functions ( PFs ) and base pair probabilities according to thermodynamic models .A corresponding SCFG based statistical sampling algorithm for RNA secondary structures has been studied just recently .Notably , this probabilistic method is capable of producing accurate ( prediction ) results , where its worst - case time and space requirements are equal to those of common RNA folding algorithms for single sequences .As we will see , significant differences with respect to the overall quality of generated sample sets and the resulting predictive accuracy are typically implied .", "label": "", "metadata": {}}
{"text": "Most computational prediction methods based on free energy minimization compute a number of suboptimal foldings and we have to identify the native structures among all these possible secondary structures .For this reason , much effort has been made to develop approaches for identifying good predictions of RNA secondary structure .Using the abstract shapes approach as introduced by Giegerich et al ., each class of similar secondary structures is represented by one shape and the native structures can be found among the top shape representatives .In this article , we derive some interesting results answering enumeration problems for abstract shapes and secondary structures of RNA .", "label": "", "metadata": {}}
{"text": "To reach this goal , we analyze the number of secondary structures and shapes compatible with an RNA sequence of length n under the assumption that base pairing is allowed between arbitrary pairs of bases analytically and compare their exponential growths .Additionally , we analyze the number of secondary structures compatible with an RNA sequence of length n under the assumptions that base pairing is allowed only between certain pairs of bases and that the structures meet some appropriate conditions .The exponential growth factors of the resulting asymptotics are compared to the corresponding experimentally obtained value as given by Giegerich et al . .", "label": "", "metadata": {}}
{"text": "In fact , the free energy in a stochastic model derived from a database of small and large subunit ribosomal RNA ( SSU and LSU rRNA ) data is studied .A common thermody - namic model for computing the free energy of a given RNA secondary structure , as well as stochastic context - free grammars and generating functions are used to derive the desired results .These results include asymptotics for the expected free energy and for the corresponding variance of a random RNA secondary structure .The quality of our model is judged by comparing the derived results to the used database of SSU and LSU rRNA data .", "label": "", "metadata": {}}
{"text": "In this article we present a method to generate random objects from a large variety of combinatorial classes according to a given distribution .Affiliated with .Abstract .Background .Ambiguity is a problem in biosequence analysis that arises in various analysis tasks solved via dynamic programming , and in particular , in the modeling of families of RNA secondary structures with stochastic context free grammars .Several types of analysis are invalidated by the presence of ambiguity .As this problem inherits undecidability ( as we show here ) from the namely problem for context free languages , there is no complete algorithmic solution to the problem of ambiguity checking .", "label": "", "metadata": {}}
{"text": "We explain frequently observed sources of ambiguity , and show how to avoid them .We suggest four testing procedures that may help to detect ambiguity when present , including a just - in - time test that permits to work safely with a potentially ambiguous grammar .We introduce , for the special case of stochastic context free grammars and RNA structure modeling , an automated partial procedure for proving non - ambiguity .It is used to demonstrate non - ambiguity for several relevant grammars .Conclusion .Our mechanical proof procedure and our testing methods provide a powerful arsenal of methods to ensure non - ambiguity .", "label": "", "metadata": {}}
{"text": "The ambiguity problem in biosequence analysis .Biosequence analysis problems are typically optimization problems - we seek the best alignment of two protein sequences under a similarity score , or the most stable secondary structure of an RNA molecule under a thermodynamic model .In such a problem , there is a \" good \" and a \" bad \" type of ambiguity .The good one is that there are many solutions to choose from .The bad one is that our algorithm may find the same solution several times , or even worse , it may study seemingly different solutions , which in fact represent the same object of interest .", "label": "", "metadata": {}}
{"text": "It is not quite the same problem , however .In striving for avoidance of ambiguity , we want to get rid of the bad type and retain the good .Ambiguity is not a problem with a dynamic programming ( DP ) algorithm that returns a single , optimal score , together with a solution that achieves this score , and does not make assertions about other solutions in the search space .Then , it does not matter whether this solution is analyzed several times , or that there are other solutions achieving the optimal score .In other cases , ambiguity can cause a DP algorithm to return an \" optimal \" answer which is plainly wrong .", "label": "", "metadata": {}}
{"text": "The phenomenon of ambiguity has been formalized and studied in [ 3 ] in a quite general framework of dynamic programming over sequence data .There , it is shown that for a proof of non - ambiguity , a canonical model of the studied domain is required .The canonical model plays an essential role .It is the mathematical formalization of the real - world domain we want to study , and \" canonical \" means one - to - one correspondence .Any formal proof can only deal with the formalization of the real - world domain , and when the one - to - one correspondence does not hold , all proofs of ( non- ) ambiguity would be meaningless for the real world .", "label": "", "metadata": {}}
{"text": "Our case , however , is easy .When RNA secondary structure is our domain of study , base pair sets or the familiar dot - bracket strings can serve as a canonical model , as they uniquely represent secondary structures .To ensure non - ambiguity , there must exist an injective ( i.e. one - to - one ) mapping from derivation trees ( according to the grammar underlying the DP algorithm ) to the canonical model .While such a mapping may be easy to specify , the proof of its injectivity remains a problem .Recently , Dowell and Eddy have re - addressed this problem [ 1 ] in the framework of stochastic context free grammars ( SCFGs ) .", "label": "", "metadata": {}}
{"text": "This solution is wrong if several \" different \" solutions represent the same real - world object .Dowell and Eddy experimented with two ambiguous SCFGs , and showed that the quality of results may range from just slightly wrong to totally useless .After having shown that one can not get by with ignoring ambiguity , they provide four non - ambiguous SCFGs for RNA structure analysis ; however , a proof of their non - ambiguity is not given .Instead , they suggest a testing approach to check for the presence of ambiguity , which , of course , can not prove its absence .", "label": "", "metadata": {}}
{"text": "We formalize the problem at hand in two steps , going from context free grammars ( CFGs ) to stochastic context free grammars , and then differentiating between syntactic and semantic ambiguity .Formal grammars .A formal language is a subset of the set of all strings over a finite alphabet .Formal languages are typically described by formal grammars .In general , a formal grammar consists of an alphabet , a set of nonterminal symbols , and a set of production rules .There exist various grammar types , differing in the laws for construction of these production rules .", "label": "", "metadata": {}}
{"text": "In 1956 , Noam Chomsky introduced a hierarchy of formal grammars that ranks grammar types by their expressive power , the Chomsky hierarchy [ 4 ] .It consists of four levels : regular grammars , context - free grammars , context - sensitive grammars , and unrestricted grammars .Here , we only address context - free grammars .These are suitable to describe the pseudoknot - free secondary structure of RNA .When considering pseudoknots , context - sensitive grammars are needed .Context free grammars .Starting with the axiom symbol , by successive replacement of nonterminal symbols by right - hand sides of corresponding productions , we can derive a set of terminal strings .", "label": "", "metadata": {}}
{"text": "Each such derivation can uniquely be represented as a derivation tree , and if the same terminal string has two different derivation trees , the grammar is called ambiguous .Our first example is Dowell and Eddy 's grammar G 1 [ 1 ] to describe RNA secondary structures : .Four different derivation trees of the grammar G 1 are shown in Figure 1 .As they all emerge from the same terminal string acaggaaacuguacggugcaaccg , this grammar is ambiguous .Four derivation trees .Four derivation trees for RNA sequence \" acaggaaacuguacggugcaaccg \" , two ( left ) representing the annotation sequence ( ( ( ( .... ) ) ) ) .", "label": "", "metadata": {}}
{"text": "Stochastic context free grammars .Stochastic context free grammars associate a ( nonzero ) probability with each production , such that the probabilities for all alternative productions emerging from the same nonterminal symbol add up to 1 .As a string is derived , probabilities of the involved rules multiply .We extend the CFG G 1 to a SCFG by the following example probabilities : .For simplicity , we chose probabilities independent of certain bases .In SCFG design , often also non - canonical base pairings are allowed with a low probability .For grammar G 1 , the derivations shown in Figure 1 have probabilities of 5.24\u00b710 -14 , 2.1\u00b710 -15 , 4.19\u00b710 -16 and 4.19\u00b710 -16 ( from left to right ) .", "label": "", "metadata": {}}
{"text": "The parser may compute the overall probability of a given string , summing up probabilities over all its derivations , in which case it is called the Inside algorithm .Or , the parser can return the most likely derivation of the input string , in which case it is known as the Viterbi algorithm .For grammar G 1 , the corresponding CYK - based Viterbi algorithm is shown here : .Syntactic versus semantic ambiguity .Above , we introduced the formal language - theoretic notion of ambiguity : if the same symbol sequence has two or more different derivation trees , the grammar is called ambiguous .", "label": "", "metadata": {}}
{"text": "In this sense , grammar G 1 ( and every other grammar in this manuscript ) is in any case fl - ambiguous .This is demonstrated by the fact that the four derivation trees of Figure 1 all belong to the same symbol sequence .We now need to refine this notion of ambiguity .In modeling with SCFGs , derivations do not merely produce strings , but they represent objects of interest themselves .With RNA , a derivation of an RNA sequence represents a possible secondary structure of this sequence .A more compact representation of a secondary structure is the widely used dot - bracket notation , as shown at the bottom of Figure 1 .", "label": "", "metadata": {}}
{"text": "The one - to - one correspondence between ( molecular ) structures and ( in silico ) annotation sequences qualifies the latter as a canonical model of the grammar .By the term syntactic ambiguity we denote the fact that typically an RNA sequence has many secondary structures , i.e. annotation sequences , hence many derivations .Figure 1 shows two example annotation sequences of the same RNA sequence .Semantic ambiguity exists when there are , for some sequence , several derivations that represent the same annotation sequence , and hence , the same secondary structure .This is our point of study .", "label": "", "metadata": {}}
{"text": "In Figure 1 , this is exemplified by the two derivations on the left that both represent the annotation sequence ( ( ( ( .... ) ) ) ) .( ( ( ( ... ) ) ) ) , and the two derivations on the right , that both represent the annotation sequence .Thus , grammar G 1 is syntactically as well as semantically ambiguous .Semantic ambiguity is the \" bad \" , syntactic ambiguity the \" good \" type of ambiguity in SCFG modeling and dynamic programming that was mentioned above .On the pure formal language level , they can not be distinguished - both are manifest as fl - ambiguity .", "label": "", "metadata": {}}
{"text": "Semantic ambiguity is not a problem with the Inside algorithm , as a probability sum over all derivations is computed anyway .With the Viterbi algorithm , we can certainly obtain the most likely derivation , but we do not know whether it represents the most likely annotation sequence .Some other annotation sequence may be more likely , but as its probability is the sum of many different derivations , none of these derivations may come out optimal .And even if the most likely annotation sequence is returned by the Viterbi algorithm , its computed probability is too small when there are further derivations of this annotation sequence .", "label": "", "metadata": {}}
{"text": "For correct modeling with SCFGs , we need grammars that are syntactically , but not semantically ambiguous .Semantic ambiguity in dynamic programming .Our treatment here extends to all dynamic programming algorithms that fall into the class known as algebraic dynamic programming ( ADP ) [ 6 ] .However , some definitions must be refined , as the ADP approach uses so - called yield grammars rather than ( S)CFGs .We will not introduce the ADP formalism here , but remain within the SCFG terminology .Still , we shall refer to some DP algorithms that are not based on SCFGs , where our treatment also applies .", "label": "", "metadata": {}}
{"text": "We will further exemplify the above using the grammars G 1 to G 6 studied by Dowell and Eddy : . Dowell and Eddy showed that grammars G 1 and G 2 are semantically ambiguous , while G 3 to G 6 passed a partial test for non - ambiguity .Results and discussion .In this section , we first review some sources of ambiguity and suggest three ways to deal with it : ambiguity avoidance , testing for ambiguity , and , best of all when successful , a mechanical proof of absence .Sources of ambiguity , and how to avoid them .", "label": "", "metadata": {}}
{"text": "Thereafter , we make some observations with respect to the potential of testing procedures .Three simple cases .Ambiguity does not sneak into our grammars by chance and non - awareness .There are two competing goals in grammar design , and both may foster ambiguity .Small grammars have the advantage that they require fewer parameters and can be trained more quickly .Larger grammars allow a more sophisticated distinction of cases , hence providing a more fine - tuned model .However , if the underlying \" distinct \" cases lead to the same annotation sequence , then the grammar is ambiguous .", "label": "", "metadata": {}}
{"text": "Often , non - ambiguous grammars require more space in their implementation via a CYK parser .For example , the non - ambiguous Wuchty algorithm ( RNAsubopt , [ 2 ] ) requires four tables for storing intermediate results , while the ambiguous Zuker - Stiegler recurrences ( Mfold , [ 7 ] ) require only two .Two other cases in point are ( a ) and ( b ) below , while ( c ) shows that the non - ambiguous grammar can also be smaller .Ambiguity can have many sources .Here , we present three common situations that lead us to write ambiguous rules , but can be easily avoided .", "label": "", "metadata": {}}
{"text": "For a given string a m Ta n , the first two alternatives of the left - hand rule produce the initial string a m and the terminal a n in arbitrary order , while the right - hand rules produce a m completely before a n , allowing for only one derivation .As above , an extra nonterminal symbol is required to achieve non - ambiguity .Sometimes it is tempting to add a special case by using \u03b5 .The general case of \u03b5 -rules may be more tricky to handle .In general , all context free languages can be described without \u03b5 -rules , except possibly one for the axiom symbol .", "label": "", "metadata": {}}
{"text": "Degree of ambiguity and consequences for testing .Dowell and Eddy showed that semantic ambiguity produces sometimes mildly , sometimes drastically false results .In one experiment , they showed that the CYK algorithm for the semantically ambiguous grammar G 1 does not give the optimal secondary structure for about 20 % of a sample set of 2455 sequences .The same experiment for grammar G 2 even gave a rate of 98 % false results .The explanation of the difference in effect lies with the degree of ambiguity .The degree of ambiguity of a given annotation sequence is the number of its derivations , i.e. a degree of 1 means that this annotation sequence is not ambiguous .", "label": "", "metadata": {}}
{"text": "The latter is the rule rather than the exception .Moreover , if derivations emerging from T are also ambiguous , the degrees of ambiguity multiply .Studying sources of ambiguity helps to better understand the nature of the error .Depending on the grammar , certain types of RNA structures may have their probability split up over a large number of derivations , while others are unaffected .This makes it difficult to judge the amount of testing required , and the confidence achieved with the approaches presented in the next section .Testing for ambiguity .Performing a test for semantic ambiguity allows us to obtain more confidence in the grammar , although testing can not prove non - ambiguity , but only ambiguity .", "label": "", "metadata": {}}
{"text": "First , we create several variants of the Inside and Viterbi algorithms , which are our algorithmic arsenal for testing .G l serves as the expository example here ; for any other grammar , recurrences can be given in an analogous way : .By different interpretations of the operations H , o and P , different scoring schemes can be plugged in .The recurrences may also be \" conditioned \" by annotating the symbol sequence x with a given annotation sequence s [ 1 ] .This version of the recurrences will be denoted by G s .", "label": "", "metadata": {}}
{"text": "Using the other two , we obtain an algorithm for counting the number of derivations for the input string , and an algorithm for base pair maximization .Base pair maximization will not be used in the sequel , it is included only to indicate the swiftness of transition from SCFG modeling to other DP - based analyses .These algorithms are available at the accompanying website [ 8 ] , where readers are welcome to practice their insight on ambiguity matters .In the following , we write G ( \u03c3 , x ) for running the CYK parser based on grammar G with scoring scheme \u03c3 on input x .", "label": "", "metadata": {}}
{"text": "For RNA secondary structures , there is an obvious choice , our annotation sequences in the widely used dot - bracket notation ( cf .Figure 1 ) .Each secondary structure ( excluding pseudoknots ) is uniquely represented by such a string .The scoring scheme Dotbracket makes the CYK algorithm report all the structures it has analyzed for a given input sequence by producing their annotation sequences . is string concatenation .Here , o expects a dot - bracket string as its left argument , a function as its right argument , and applies the latter to the former .", "label": "", "metadata": {}}
{"text": "( ) \" , \" ... \" , \" ... \" , etc . ] , where the duplicate entries result from the ambiguity of G 1 .For example , the annotation sequence \" ... \" is found 48 times .Testing procedures .Brute force testing .Checking for duplicates in G ( Dotbracket , x ) .We can simply enumerate the dot - bracket representation of all structures exhaustively for a given input string and check for any repeats .There are some duplicates in G ( Dotbracket , x ) if and only if x can fold into an ambiguous annotation sequence ( which may be precluded by its nucleotide content ) .", "label": "", "metadata": {}}
{"text": "Of course , enumerating the annotation sequences for all possible derivation trees creates voluminous output , and the automated check for duplicates requires some careful programming .Hence , this test is practical only for short sequences .Sampling structures from sample sequences .Dowell and Eddy suggested a testing procedure that relies on a comparison of the results from the Viterbi and the Inside algorithms , where the latter is conditioned on the most likely annotation sequence s returned by the Viterbi run .G s ( Inside , x ) sums up probabilities over all derivations representing annotation sequence s .", "label": "", "metadata": {}}
{"text": "If there are more than one , the Inside algorithm will return a higher probability than the Viterbi run , which indicates ambiguity of s ( and hence G ) .Similarly , G s ( Counting , x ) directly computes the number of derivations for s , where a result larger than 1 signals ambiguity .Dowell and Eddy suggest to run the test also for a sample of suboptimal annotation sequences for x .Since the minimizing Viterbi run gives us the least probable derivation tree , we may have a higher chance to find an ambiguous one ( if present ) than in the maximizing run .", "label": "", "metadata": {}}
{"text": "The four grammars G 3 - G 6 passed the Dowell - Eddy test in [ 1 ] , and in the next section we shall prove their non - ambiguity .In this sense , we can state that this test has already worked quite well in practice .However , the eternal dilemma of testing persists - only if we confirmed the above equation for all x , semantic non - ambiguity would be assured .Structure counting for sample sequences .An even stronger test is possible when we have a reference grammar R available that generates the same language and is known to be semantically non - ambiguous .", "label": "", "metadata": {}}
{"text": "Still , if this test succeeds , this does not imply non - ambiguity of G .But this test is much more thorough than our previous one , as the entire structure space of each tested x is analyzed .For example , a sequence of length 30 has an expected number of 175550 feasible structures [ 3 ] .Thus , one run of this test has the testing power of 175550 runs of the previous one .Several non - ambiguous reference grammars for RNA are known - the critical part here is to assure that our grammar G to be tested describes the same language as R .", "label": "", "metadata": {}}
{"text": "This may be obvious in many cases , but in general , language equivalence is an undecidable problem in formal language theory .Just - in - time testing .While testing can not guarantee the non - ambiguity of the grammar , we can convert the previous idea to a test that ensures for each application run that the results are not affected by ambiguity .This costs a constant factor in runtime , but solves the problem in the sense that when we get a positive test , we know the Viterbi result is correct for this input .", "label": "", "metadata": {}}
{"text": "Proving non - ambiguity .Proving the absence of ambiguity in a grammar is of course better than any test procedure .Semantic ambiguity in dynamic programming is unde - cidable .Ambiguity of context free grammars is well - known to be algorithmically undecidable [ 9 ] .There exists no program that can determine for an arbitrary grammar G whether or not G is fl - ambiguous .Here , the problem is to decide whether a given SCFG is se - mantically ambiguous .It is not surprising that this problem is not easier : .Theorem 1 Semantic ambiguity in dynamic programming is formally undecidable .", "label": "", "metadata": {}}
{"text": "We show that for a given CFG G there exists a DP problem and an associated canonical model such that the DP algorithm is semantically am biguous if and only if the grammar is fl - ambiguous .Given an algorithm to decide ambiguity for DP problems , we could hence decide ambiguity for context free grammars , which is impossible .Details are given in the appendix .While this result rules out an automated proof procedure for arbitrary grammars used in SCFG modeling , there might still be the possibility to design such a procedure for a restricted class of grammars , say all grammars which describe RNA secondary structures .", "label": "", "metadata": {}}
{"text": "Hand - made proof of non - ambiguity .A hand - made de - novo proof of the non - ambiguity of a new grammar G requires an inductive argument on the number of parses corresponding to the same annotation sequence .We constructed one such proof for the grammar published in [ 3 ] .It is not mathematically deep , but rather a tedious exercise , and the likelihood to produce errors or oversights is high .By showing that a one - to - one mapping between parse trees of G and R exists , it is possible to prove the non - ambiguity of G .", "label": "", "metadata": {}}
{"text": "For grammars that are rather distinct , the proof is as messy as the de - novo proof .Mechanical proof of non - ambiguity .We now present a mechanical technique that is a partial proof procedure for the case of modeling RNA structure with SCFGs : If it succeeds , it proofs non - ambiguity , if it fails , we do not know .We shall show that the method succeeds on several relevant grammars .The technique described in the following comprises two steps .First , we remove the syntactic ambiguity of the grammar and reduce a possibly existent semantic ambiguity to fl - ambiguity .", "label": "", "metadata": {}}
{"text": "This test can prove non - ambiguity of a large number of grammars .Ambiguity reduction .Paired bases can always also be unpaired - this creates the syntactic ( good ) ambiguity .Used in concert , they create the \" good \" ambiguity that allows us to parse \" CAAAG \" either as \" ( ... ) \" or as \" ..... \" .Remember that the dot - bracket notation is a canonical representation for RNA secondary structure .Take for example .Proof .Every dot - bracket string describes exactly one possible secondary structure .", "label": "", "metadata": {}}
{"text": "This is equivalent to semantic ambiguity of G .A single derivation exists in G for a compatible RNA sequence x , and hence , G is semantically non - ambiguous .Non - ambiguity proof .As stated above , this question is undecidable in general .However , compiler technology provides a partial proof procedure : If a deterministic parser can be generated for a grammar , then it is non - ambiguous [ 5 ] .Simply speaking , a parser generator takes a file with a context free grammar as input , and generates a program which implements the parser for this grammar .", "label": "", "metadata": {}}
{"text": "There are many such generators available ; we will focus on the class of LR ( k ) grammars [ 10 ] and their parser generators .A context free grammar is called LR ( k ) if a deterministic shift reduce parser exists that uses k symbols of lookahead .By definition , an LR ( k ) grammar is non - ambiguous , and for a given k it is decidable whether a grammar is LR ( k ) .This decision can be assigned to a parser generator .Given the grammar and the lookahead k , a parser generator tries to construct a parser that uses k symbols of lookahead .", "label": "", "metadata": {}}
{"text": "When the grammar is not LR ( k ) , the generator will not be able to create a deterministic parser and reports this situations in form of \" shift - reduce \" and \" reduce - reduce\"-conflicts to the user .In this case , we do not know whether the parser generator might be successful for a larger k , and the question of ambiguity remains undecided .Applications .For our experiments , we used the MSTA parser generator of the COCOM compiler construction toolkit [ 11 ] .MSTA is capable of generating LR ( k ) parsers for arbitrary k. Note that compiler writers prefer other parser generators like yacc [ 12 ] and bison [ 13 ] , which for efficiency reasons only implement LR ( 1 ) parsers .", "label": "", "metadata": {}}
{"text": "Its successful construction is the proof of non - ambiguity ; for applying our SCFG , we need the original grammar and its CYK parser .MSTA accepts input files in the widely used yacc format .The following shows the input file for grammar G 5 : .This proves that G5 is LR ( 1 ) , has a deterministic LR ( 1 ) parser , and is therefore non - ambiguous .Table 1 summarizes the results for grammars G 1 to G 6 .For G 1 and G 2 , the results only show that both grammars are not LR ( 1 ) , LR ( 2 ) or LR ( 3 ) .", "label": "", "metadata": {}}
{"text": "Table 1 .Results of mechanical proof procedure .Number of shift - reduce ( SR ) and reduce - reduce ( RR ) conflicts when feeding example grammars G1 to G8 into parser generator MSTA .A 0/0 entry indicates a successful proof of non - ambiguity .Note that for increasing k , the number of conflicts may remain constant or even grow before it goes down to 0/0 .Grammar G 3 is LR ( 5 ) and G 4 to G 6 are LR ( 1 ) .Therefore , we have proved mechanically that the four \" good \" grammars studied by Dowell and Eddy are definitely non - ambiguous .", "label": "", "metadata": {}}
{"text": "ambiguous .In Table 1 we also report on the number of conflicts found by the parser generator for increasing values of k .While the nature of these conflicts is not relevant for us , the table shows that various behaviors are possible .Their numbers may grow ( G 3 ) or may remain constant ( G 7 ) before they go to zero for some k .Experience from a larger example .The parser generator test works quite well for the small grammars we presented so far .However , there exist cases where , due to the finite lookahead of the generated parser , the parser generator reports conflicts while the grammar is in fact non - ambiguous .", "label": "", "metadata": {}}
{"text": "In his thesis [ 14 ] , Bj\u00f6rn Voss introduced a new grammar that promises to handle dangling bases of multiloop components in a non - ambiguous way .With 28 nonterminal symbols and 79 rules , the grammar is quite large .In such a case , mechanical assistance is strongly required .Our first approach with the parser generator succeeded , except for one small part of the grammar for which it reports a con - flict .Figure 2 shows two example derivations where this conflict occurs .Two example derivations .Two example derivations of a grammar taken from [ 14 ] .", "label": "", "metadata": {}}
{"text": "The central nonterminal of the grammar is CL , which splits up into closed structures like hairpin loops , bulges , and multiloops .Due to the necessity to handle dangling bases in a non - ambiguous way , the rules for multiloops are the most complicated of this grammar .Altogether , 11 nonterminals and 35 rules are used exclusively for this purpose .The construction of these rules guarantees , that every derivation of a multiloop must lead to at least two closed substructures .One of these derivations is shown on the left side of Figure 2 .", "label": "", "metadata": {}}
{"text": "However , the parser generator runs into a conflict here .Consider the following annotation sequence : .Here , the string \" ( ( ... ( ( \" appears two times in the annotation sequence .The first appearance denotes a left bulge , the second the beginning of a multiloop .The decision which of these two is given can only be made after the first closed substructure is completely processed .Since the generated parser can only read a limited number of input characters ahead ( k ) , the parser generator is not able to construct a deterministic parser for this situation and reports a conflict .", "label": "", "metadata": {}}
{"text": "Since a multiloop 's derivation can not conflict with that of a bulge , this modification does not alter the ambiguity or non - ambiguity of the grammar .The important difference is that positional information is turned into symbolic information .After this modification , the parser generator runs smoothly through the grammar , which proves its non - ambiguity .Conclusion .In this work , we have presented testing methods and a partial proof procedure to analyze the semantic ambiguity of SCFGs .We have shown that the problem is not decidable for dynamic programming over sequence data in general , and that hence there is no standard solution that works for all cases .", "label": "", "metadata": {}}
{"text": "We have proposed several tests , and a partial , mechanical proof procedure .We mechanically proved that the six grammars that passed Dowell and Eddy 's test for non - ambiguity are actually non - ambiguous .We also reported on a proof of the non - ambiguity of a new and large grammar for RNA secondary structures , whose sophistication makes it inadvisable to rely solely on human reasoning .We want to point out that the non - ambiguity proofs for the grammars studied here do not solve the problem of ambiguity for modeling of RNA secondary structures once and for all .", "label": "", "metadata": {}}
{"text": "An example is a grammar that is restricted to a special class of structures of an RNA family .This allows us to define a thermodynamic matcher , which uses the minimum free energy as a scoring scheme and focuses only on a specific realm of secondary structures .Here , for every new RNA family , a new grammar must be devised .This demonstrates a continuous need for new , specialized grammars .Every time we develop a new grammar , the dragon of ambiguity raises its head , but with the weapons presented here , we can be confident to defeat it .", "label": "", "metadata": {}}
{"text": "Our way to describe various tests by combining a grammar with varying scoring schemes is derived from the algebraic dynamic programming method , described in detail in [ 6 ] .The theoretical framework of this method also underlies the proof of Theorem 1 .The parser generator MSTA used as a partial proof method is available at [ 11 ] .Appendix : Ambiguity in DP is undecidable .Dynamic programming is a very general programming technique , and its scope is not precisely circumscribed .We prove our undecidability result for the well defined class of algebraic dynamic programming [ 6 ] problems , which of course implies undecidability in general .", "label": "", "metadata": {}}
{"text": "Theorem 1 Semantic ambiguity in dynamic programming is formally undecidable .Proof .For an arbitrary context free grammar G , we can construct a DP problem where L ( G ) serves as the canonical model , and show that the context free grammar G is ambiguous if and only if the DP problem is semantically ambiguous .Let G be a context free grammar .We construct a scoring scheme \u03c3 for grammar G such that G ( \u03c3 , x ) computes all derivation trees for x .For each production \u03c0 we use a unique tree label T \u03c0 .", "label": "", "metadata": {}}
{"text": "By construction , the domain of v are the derivation trees of G , its range is L ( G ) .Hence , v is injective if and only if G is non - ambiguous .Could we formally decide the semantic ambiguity of an arbitrary DP problem , we could do so for the problem given by G and \u03c3 , and hence , ambiguity of context free languages would be decidable .Note . 1 For the same reason , this modification is also necessary in the rules for internal loops .Declarations .Acknowledgements .We are grateful to Jens Reeder for discussion and the anonymous referees for very detailed and helpful comments .", "label": "", "metadata": {}}
{"text": "Authors ' contributions .RG suggested the topic and contributed the undecid - ability proof .JR worked out the testing procedures and PS the mechanical proof procedure .All authors cooperated closely in writing the manuscript .Authors ' Affiliations .InternationaI NRW Graduate School of Bioinformatics and Genome Research , Center of Biotechnology ( CeBiTec ) , Bielefeld University .Practical Computer Science , Faculty of Technology , Bielefeld University .References .Dowell R , Eddy SR : Evaluation of several lightweight stochastic context - free grammars for RNA secondary structure prediction .BMC Bioinformatics 2004 , 5 : 71 .", "label": "", "metadata": {}}
{"text": "Wuchty S , Fontana W , Hofacker I , Schuster P : Complete Suboptimal Folding of RNA and the Stability of Secondary Structures .Biopolymers 1999 , 49 : 145 - 165 .View Article PubMed .Giegerich R : Explaining and Controlling Ambiguity in Dynamic Programming .Proc .Combinatorial Pattern Matching , Springer LNCS 1848 2000 , 46 - 59 .Chomsky N : Three Models for the Description of Language .IRE Transactions on information theory 1956 , 2 : 113 - 124 .View Article .Aho A , Ullman J : The Theory of Parsing , Translation and Compiling Englewood Cliffs , NJ : Prentice - Hall 1973 .", "label": "", "metadata": {}}
{"text": "Giegerich R , Meyer C , Steffen P : A Discipline of Dy namic Programming over Sequence Data .Science of Computer Programming 2004 , 51 ( 3 ) : 215 - 263 .View Article .Zuker M , Stiegler P : Optimal Computer Folding of Large RNA Sequences using Thermodynamics and Auxiliary Information .Nucleic Acids Research 1981 , 9 : 133 - 148 .View Article PubMed .Chomsky N , Sch\u00fctzenberger MP : The algebraic theory of context - free languages .Computer Programming and Formal Systems ( Edited by : Braffort P , Hirschberg D ) .", "label": "", "metadata": {}}
